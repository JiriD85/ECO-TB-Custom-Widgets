{
  "fqn": "eco_custom_widgets.eco_boxplot",
  "name": "Statistical Boxplot",
  "deprecated": false,
  "image": "tb-image;/api/images/system/chart.svg",
  "description": "Statistical boxplot chart showing quartiles, median, and outliers. Supports raw data mode (auto-calculates statistics) or pre-calculated mode with explicit min/q1/median/q3/max values.",
  "descriptor": {
    "type": "timeseries",
    "sizeX": 10,
    "sizeY": 6,
    "resources": [
      {
        "url": "https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"
      }
    ],
    "templateHtml": "<div id=\"chart-container\" style=\"width: 100%; height: 100%;\"></div>",
    "templateCss": "#chart-container { position: relative; }",
    "controllerScript": "var chart = null;\nvar chartContainer = null;\nvar zoomDebounceTimer = null;\nvar isExternalUpdate = false;\n\nself.onInit = function() {\n    chartContainer = self.ctx.$container.find('#chart-container')[0];\n    if (!chartContainer) {\n        console.error('Chart container not found');\n        return;\n    }\n    \n    if (typeof echarts === 'undefined') {\n        console.error('ECharts not loaded');\n        return;\n    }\n    \n    chart = echarts.init(chartContainer);\n    \n    var settings = self.ctx.settings || {};\n    if (settings.enableZoomSync !== false) {\n        chart.on('datazoom', handleZoomSync);\n    }\n    \n    updateChart();\n};\n\nfunction handleZoomSync(params) {\n    if (isExternalUpdate) return;\n    \n    var settings = self.ctx.settings || {};\n    if (settings.enableZoomSync === false) return;\n    \n    var debounceMs = settings.zoomSyncDebounce || 150;\n    \n    if (zoomDebounceTimer) {\n        clearTimeout(zoomDebounceTimer);\n    }\n    \n    zoomDebounceTimer = setTimeout(function() {\n        var option = chart.getOption();\n        var dataZoom = option.dataZoom && option.dataZoom[0];\n        if (!dataZoom) return;\n        \n        var timeWindow = self.ctx.timeWindow;\n        if (!timeWindow) return;\n        \n        var totalRange = timeWindow.maxTime - timeWindow.minTime;\n        var startPercent = dataZoom.start || 0;\n        var endPercent = dataZoom.end || 100;\n        \n        if (startPercent > 0.5 || endPercent < 99.5) {\n            var startTime = Math.round(timeWindow.minTime + (totalRange * startPercent / 100));\n            var endTime = Math.round(timeWindow.minTime + (totalRange * endPercent / 100));\n            \n            if (self.ctx.dashboard && self.ctx.dashboard.onUpdateTimewindow) {\n                self.ctx.dashboard.onUpdateTimewindow(startTime, endTime);\n            }\n        }\n    }, debounceMs);\n}\n\nself.onDataUpdated = function() {\n    isExternalUpdate = true;\n    updateChart();\n    setTimeout(function() { isExternalUpdate = false; }, 100);\n};\n\n// Helper functions for statistics\nfunction sortNumbers(arr) {\n    return arr.slice().sort(function(a, b) { return a - b; });\n}\n\nfunction percentile(sortedArr, p) {\n    var idx = (sortedArr.length - 1) * p;\n    var lower = Math.floor(idx);\n    var upper = Math.ceil(idx);\n    if (lower === upper) return sortedArr[lower];\n    return sortedArr[lower] * (upper - idx) + sortedArr[upper] * (idx - lower);\n}\n\nfunction calculateBoxplotStats(values) {\n    if (!values || values.length === 0) return null;\n    var sorted = sortNumbers(values);\n    var q1 = percentile(sorted, 0.25);\n    var median = percentile(sorted, 0.5);\n    var q3 = percentile(sorted, 0.75);\n    var iqr = q3 - q1;\n    var lowerFence = q1 - 1.5 * iqr;\n    var upperFence = q3 + 1.5 * iqr;\n    \n    var min = sorted[0];\n    var max = sorted[sorted.length - 1];\n    \n    // Whiskers extend to the most extreme data point within the fences\n    var whiskerMin = min;\n    var whiskerMax = max;\n    var outliers = [];\n    \n    for (var i = 0; i < sorted.length; i++) {\n        if (sorted[i] < lowerFence) {\n            outliers.push(sorted[i]);\n        } else {\n            whiskerMin = sorted[i];\n            break;\n        }\n    }\n    \n    for (var i = sorted.length - 1; i >= 0; i--) {\n        if (sorted[i] > upperFence) {\n            outliers.push(sorted[i]);\n        } else {\n            whiskerMax = sorted[i];\n            break;\n        }\n    }\n    \n    return {\n        min: whiskerMin,\n        q1: q1,\n        median: median,\n        q3: q3,\n        max: whiskerMax,\n        outliers: outliers\n    };\n}\n\nfunction getGroupKey(timestamp, groupBy) {\n    var d = new Date(timestamp);\n    switch (groupBy) {\n        case 'hour':\n            return d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate() + ' ' + d.getHours() + ':00';\n        case 'day':\n            return d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate();\n        case 'week':\n            var startOfYear = new Date(d.getFullYear(), 0, 1);\n            var weekNum = Math.ceil(((d - startOfYear) / 86400000 + startOfYear.getDay() + 1) / 7);\n            return d.getFullYear() + '-W' + weekNum;\n        case 'month':\n            return d.getFullYear() + '-' + (d.getMonth() + 1);\n        default:\n            return d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate();\n    }\n}\n\nfunction updateChart() {\n    if (!chart) return;\n    \n    var settings = self.ctx.settings || {};\n    var dataMode = settings.dataMode || 'raw';\n    var groupBy = settings.groupBy || 'day';\n    var boxColor = settings.boxColor || '#5470C6';\n    var borderColor = settings.borderColor || '#5470C6';\n    var whiskerColor = settings.whiskerColor || '#5470C6';\n    var showOutliers = settings.showOutliers !== false;\n    var outlierColor = settings.outlierColor || '#E91E63';\n    var showDataZoomSlider = settings.showDataZoomSlider !== false;\n    var showLegend = settings.showLegend !== false;\n    var showTooltip = settings.showTooltip !== false;\n    var enableExport = settings.enableExport !== false;\n    \n    var data = self.ctx.data || [];\n    if (!data.length) {\n        chart.setOption({\n            title: { text: 'No data', left: 'center', top: 'middle' }\n        });\n        return;\n    }\n    \n    var boxplotData = [];\n    var outlierData = [];\n    var categoryData = [];\n    var units = '';\n    \n    if (dataMode === 'precalculated') {\n        // Precalculated mode: expect min, q1, median, q3, max data keys\n        var minData = null, q1Data = null, medianData = null, q3Data = null, maxData = null;\n        \n        for (var i = 0; i < data.length; i++) {\n            var ds = data[i];\n            var keyName = ((ds.dataKey && ds.dataKey.name) || '').toLowerCase();\n            var keyLabel = ((ds.dataKey && ds.dataKey.label) || '').toLowerCase();\n            \n            if (keyName === 'min' || keyLabel === 'min') minData = ds;\n            else if (keyName === 'q1' || keyLabel === 'q1') q1Data = ds;\n            else if (keyName === 'median' || keyLabel === 'median') medianData = ds;\n            else if (keyName === 'q3' || keyLabel === 'q3') q3Data = ds;\n            else if (keyName === 'max' || keyLabel === 'max') maxData = ds;\n        }\n        \n        if (!minData || !q1Data || !medianData || !q3Data || !maxData) {\n            chart.setOption({\n                title: { text: 'Need min, q1, median, q3, max data keys', left: 'center', top: 'middle', textStyle: { fontSize: 11 } }\n            });\n            return;\n        }\n        \n        units = (minData.dataKey && minData.dataKey.units) || '';\n        \n        // Build maps\n        var maps = { min: {}, q1: {}, median: {}, q3: {}, max: {} };\n        [['min', minData], ['q1', q1Data], ['median', medianData], ['q3', q3Data], ['max', maxData]].forEach(function(pair) {\n            if (pair[1] && pair[1].data) {\n                pair[1].data.forEach(function(d) { maps[pair[0]][d[0]] = d[1]; });\n            }\n        });\n        \n        var timestamps = {};\n        [minData, q1Data, medianData, q3Data, maxData].forEach(function(ds) {\n            if (ds && ds.data) ds.data.forEach(function(d) { timestamps[d[0]] = true; });\n        });\n        \n        var sortedTs = Object.keys(timestamps).map(Number).sort(function(a, b) { return a - b; });\n        \n        sortedTs.forEach(function(ts) {\n            var min = maps.min[ts], q1 = maps.q1[ts], med = maps.median[ts], q3 = maps.q3[ts], max = maps.max[ts];\n            if (min !== undefined && q1 !== undefined && med !== undefined && q3 !== undefined && max !== undefined) {\n                categoryData.push(getGroupKey(ts, groupBy));\n                boxplotData.push([min, q1, med, q3, max]);\n            }\n        });\n    } else {\n        // Raw mode: group data and calculate statistics\n        var valueData = data[0];\n        if (!valueData || !valueData.data || !valueData.data.length) {\n            chart.setOption({\n                title: { text: 'No valid data', left: 'center', top: 'middle' }\n            });\n            return;\n        }\n        \n        units = (valueData.dataKey && valueData.dataKey.units) || '';\n        \n        // Auto-detect groupBy if set to 'auto'\n        if (groupBy === 'auto') {\n            var timeRange = self.ctx.timeWindow ? (self.ctx.timeWindow.maxTime - self.ctx.timeWindow.minTime) : 0;\n            if (timeRange > 30 * 86400000) groupBy = 'month';\n            else if (timeRange > 7 * 86400000) groupBy = 'week';\n            else if (timeRange > 86400000) groupBy = 'day';\n            else groupBy = 'hour';\n        }\n        \n        // Group values by time period\n        var groups = {};\n        valueData.data.forEach(function(d) {\n            if (d[1] === null || d[1] === undefined || isNaN(d[1])) return;\n            var key = getGroupKey(d[0], groupBy);\n            if (!groups[key]) groups[key] = [];\n            groups[key].push(d[1]);\n        });\n        \n        // Calculate boxplot stats for each group\n        var sortedKeys = Object.keys(groups).sort();\n        sortedKeys.forEach(function(key) {\n            var stats = calculateBoxplotStats(groups[key]);\n            if (stats) {\n                categoryData.push(key);\n                boxplotData.push([stats.min, stats.q1, stats.median, stats.q3, stats.max]);\n                if (showOutliers && stats.outliers.length > 0) {\n                    stats.outliers.forEach(function(o) {\n                        outlierData.push([categoryData.length - 1, o]);\n                    });\n                }\n            }\n        });\n    }\n    \n    if (boxplotData.length === 0) {\n        chart.setOption({\n            title: { text: 'No valid boxplot data', left: 'center', top: 'middle' }\n        });\n        return;\n    }\n    \n    var series = [{\n        name: 'Boxplot',\n        type: 'boxplot',\n        data: boxplotData,\n        itemStyle: {\n            color: boxColor,\n            borderColor: borderColor\n        },\n        boxWidth: ['40%', '70%']\n    }];\n    \n    if (showOutliers && outlierData.length > 0) {\n        series.push({\n            name: 'Outliers',\n            type: 'scatter',\n            data: outlierData,\n            itemStyle: {\n                color: outlierColor\n            },\n            symbolSize: 6\n        });\n    }\n    \n    var option = {\n        tooltip: showTooltip ? {\n            trigger: 'item',\n            formatter: function(params) {\n                if (params.seriesType === 'boxplot') {\n                    return params.name + '<br/>' +\n                        'Max: ' + params.data[5].toFixed(2) + ' ' + units + '<br/>' +\n                        'Q3: ' + params.data[4].toFixed(2) + ' ' + units + '<br/>' +\n                        'Median: ' + params.data[3].toFixed(2) + ' ' + units + '<br/>' +\n                        'Q1: ' + params.data[2].toFixed(2) + ' ' + units + '<br/>' +\n                        'Min: ' + params.data[1].toFixed(2) + ' ' + units;\n                } else {\n                    return 'Outlier: ' + params.data[1].toFixed(2) + ' ' + units;\n                }\n            }\n        } : {},\n        legend: showLegend ? {\n            data: showOutliers && outlierData.length > 0 ? ['Boxplot', 'Outliers'] : ['Boxplot'],\n            top: 5\n        } : {},\n        toolbox: enableExport ? {\n            feature: {\n                saveAsImage: { title: 'Save as PNG' },\n                dataView: { title: 'Data View', readOnly: true }\n            },\n            right: 10\n        } : {},\n        grid: {\n            left: 60,\n            right: enableExport ? 80 : 20,\n            top: showLegend ? 40 : 20,\n            bottom: showDataZoomSlider ? 60 : 40\n        },\n        xAxis: {\n            type: 'category',\n            data: categoryData,\n            axisLabel: { fontSize: 9, rotate: categoryData.length > 10 ? 45 : 0 },\n            splitLine: { show: false }\n        },\n        yAxis: {\n            type: 'value',\n            name: units,\n            axisLabel: { fontSize: 10 },\n            splitLine: { lineStyle: { type: 'dashed', opacity: 0.3 } }\n        },\n        dataZoom: [\n            { type: 'inside', xAxisIndex: 0 },\n            showDataZoomSlider ? { type: 'slider', xAxisIndex: 0, bottom: 5, height: 20 } : null\n        ].filter(function(x) { return x !== null; }),\n        series: series\n    };\n    \n    chart.setOption(option, true);\n}\n\nself.onResize = function() {\n    if (chart) {\n        chart.resize();\n    }\n};\n\nself.onDestroy = function() {\n    if (chart) {\n        chart.off('datazoom');\n        chart.dispose();\n        chart = null;\n    }\n    if (zoomDebounceTimer) {\n        clearTimeout(zoomDebounceTimer);\n    }\n};\n\nself.typeParameters = function() {\n    return {\n        previewWidth: '80%',\n        embedTitlePanel: true,\n        dataKeySettingsFunction: function() { return {}; },\n        defaultDataKeysFunction: function() {\n            return [{ name: 'value', label: 'Value', type: 'timeseries' }];\n        }\n    };\n};\n",
    "settingsSchema": {
      "schema": {
        "type": "object",
        "title": "Boxplot Settings",
        "properties": {
          "enableZoomSync": {
            "title": "Enable Zoom Sync",
            "type": "boolean",
            "default": true
          },
          "zoomSyncDebounce": {
            "title": "Zoom Sync Debounce (ms)",
            "type": "number",
            "default": 150,
            "minimum": 50,
            "maximum": 500
          },
          "showDataZoomSlider": {
            "title": "Show Zoom Slider",
            "type": "boolean",
            "default": true
          },
          "dataMode": {
            "title": "Data Mode",
            "type": "string",
            "default": "raw",
            "enum": ["raw", "precalculated"]
          },
          "groupBy": {
            "title": "Group By",
            "type": "string",
            "default": "day",
            "enum": ["auto", "hour", "day", "week", "month"]
          },
          "boxColor": {
            "title": "Box Fill Color",
            "type": "string",
            "default": "#5470C6"
          },
          "borderColor": {
            "title": "Border Color",
            "type": "string",
            "default": "#5470C6"
          },
          "whiskerColor": {
            "title": "Whisker Color",
            "type": "string",
            "default": "#5470C6"
          },
          "showOutliers": {
            "title": "Show Outliers",
            "type": "boolean",
            "default": true
          },
          "outlierColor": {
            "title": "Outlier Color",
            "type": "string",
            "default": "#E91E63"
          },
          "showLegend": {
            "title": "Show Legend",
            "type": "boolean",
            "default": true
          },
          "showTooltip": {
            "title": "Show Tooltip",
            "type": "boolean",
            "default": true
          },
          "enableExport": {
            "title": "Enable Export (PNG/Data)",
            "type": "boolean",
            "default": true
          }
        },
        "required": []
      },
      "form": [
        "enableZoomSync",
        {
          "key": "zoomSyncDebounce",
          "condition": "model.enableZoomSync === true"
        },
        "showDataZoomSlider",
        {
          "key": "dataMode",
          "type": "rc-select",
          "multiple": false,
          "items": [
            { "value": "raw", "label": "Raw Data (auto-calculate statistics)" },
            { "value": "precalculated", "label": "Pre-calculated (min/q1/median/q3/max)" }
          ]
        },
        {
          "key": "groupBy",
          "type": "rc-select",
          "multiple": false,
          "condition": "model.dataMode === 'raw'",
          "items": [
            { "value": "auto", "label": "Auto" },
            { "value": "hour", "label": "Hour" },
            { "value": "day", "label": "Day" },
            { "value": "week", "label": "Week" },
            { "value": "month", "label": "Month" }
          ]
        },
        {
          "key": "boxColor",
          "type": "color"
        },
        {
          "key": "borderColor",
          "type": "color"
        },
        {
          "key": "whiskerColor",
          "type": "color"
        },
        "showOutliers",
        {
          "key": "outlierColor",
          "type": "color",
          "condition": "model.showOutliers === true"
        },
        "showLegend",
        "showTooltip",
        "enableExport"
      ]
    },
    "dataKeySettingsSchema": {},
    "latestDataKeySettingsSchema": {},
    "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Value\",\"color\":\"#5470C6\",\"settings\":{},\"_hash\":0.1,\"funcBody\":\"var base = 50 + Math.sin(time / 86400000) * 10;\\nvar noise = (Math.random() - 0.5) * 30;\\nvar outlier = Math.random() > 0.95 ? (Math.random() > 0.5 ? 40 : -40) : 0;\\nreturn base + noise + outlier;\",\"units\":\"Â°C\",\"decimals\":1}]}],\"timewindow\":{\"hideInterval\":false,\"hideLastInterval\":false,\"hideQuickInterval\":false,\"hideAggregation\":false,\"hideAggInterval\":false,\"hideTimezone\":false,\"selectedTab\":0,\"realtime\":{\"realtimeType\":0,\"timewindowMs\":604800000,\"quickInterval\":\"CURRENT_WEEK\",\"interval\":3600000},\"aggregation\":{\"type\":\"NONE\",\"limit\":25000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"enableZoomSync\":true,\"zoomSyncDebounce\":150,\"showDataZoomSlider\":true,\"dataMode\":\"raw\",\"groupBy\":\"day\",\"boxColor\":\"#5470C6\",\"borderColor\":\"#5470C6\",\"whiskerColor\":\"#5470C6\",\"showOutliers\":true,\"outlierColor\":\"#E91E63\",\"showLegend\":true,\"showTooltip\":true,\"enableExport\":true},\"title\":\"Statistical Boxplot\",\"dropShadow\":true,\"enableFullscreen\":true,\"useDashboardTimewindow\":true,\"displayTimewindow\":true}"
  },
  "tags": [
    "chart",
    "timeseries",
    "boxplot",
    "statistics",
    "quartile",
    "median",
    "outliers",
    "echarts"
  ]
}
