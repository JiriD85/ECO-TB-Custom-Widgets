{
  "fqn": "eco_custom_widgets.eco_load_duration_curve",
  "name": "ECO Load Duration Curve",
  "deprecated": false,
  "image": "tb-image;/api/images/system/chart.svg",
  "description": "Duration curve and load profile with outlier detection, thresholds and statistical lines",
  "descriptor": {
    "type": "timeseries",
    "sizeX": 10,
    "sizeY": 8,
    "resources": [
      {
        "url": "https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"
      }
    ],
    "templateHtml": "<div id=\"widget-wrapper\" style=\"width: 100%; height: 100%; display: flex; flex-direction: column;\"><div id=\"timewindow-selector\" style=\"display: none;\"></div><div id=\"stats-card-top\" style=\"padding: 4px 8px; display: none;\"></div><div style=\"flex: 1; min-height: 0; display: flex;\"><div id=\"stats-card-left\" style=\"padding: 4px; display: none;\"></div><div id=\"chart-container\" style=\"flex: 1; min-height: 0;\"></div><div id=\"stats-card-right\" style=\"padding: 4px; display: none;\"></div></div><div id=\"stats-card-bottom\" style=\"padding: 4px 8px; display: none;\"></div></div>",
    "templateCss": "#widget-wrapper { position: relative; overflow: hidden; } #chart-container { position: relative; }",
    "controllerScript": "/**\n * ECO Load Duration Curve Widget\n *\n * Displays load data as a duration curve with optional load profile.\n * Supports energy-to-power conversion, data smoothing, outlier removal, and configurable thresholds.\n */\n\nvar chart = null;\nvar chartContainer = null;\nvar statsCardContainers = {};\nvar resizeObserver = null;\nvar timewindowContainer = null;\n\n// Timewindow Selector State\nvar twState = {\n    mode: 'custom',\n    currentDate: new Date(),\n    customStart: null,\n    customEnd: null\n};\n\n// Cached entity attributes\nvar entityAttributes = {};\n\n// User language\nvar userLanguage = 'en';\n\n// Translations\nvar translations = {\n    en: { selectPeriod: 'Select Period', from: 'From', to: 'To', cancel: 'Cancel', apply: 'Apply', day: 'Day', week: 'Week', month: 'Month', custom: 'Custom' },\n    de: { selectPeriod: 'Zeitraum wählen', from: 'Von', to: 'Bis', cancel: 'Abbrechen', apply: 'Anwenden', day: 'Tag', week: 'Woche', month: 'Monat', custom: 'Custom' }\n};\n\n// Energy analysis results\nvar energyAnalysis = {\n    operatingBaseline: null,\n    operatingMean: null,\n    operatingStdDev: null,\n    peakThreshold: null\n};\n\n\n// ============================================================\n// Timewindow Selector - Inline Implementation\n// ============================================================\n\nfunction t(key) {\n    var lang = userLanguage || 'en';\n    var langStrings = translations[lang] || translations.en;\n    return langStrings[key] || translations.en[key] || key;\n}\n\nfunction detectUserLanguage() {\n    try {\n        if (self.ctx && self.ctx.$scope && self.ctx.$scope.$injector) {\n            var translate = self.ctx.$scope.$injector.get('$translate');\n            if (translate && translate.use) {\n                var tbLang = translate.use();\n                if (tbLang) { userLanguage = tbLang.substring(0, 2).toLowerCase(); return; }\n            }\n        }\n    } catch (e) {}\n    try {\n        var tbSettings = localStorage.getItem('thingsboard');\n        if (tbSettings) {\n            var parsed = JSON.parse(tbSettings);\n            if (parsed && parsed.language) { userLanguage = parsed.language.substring(0, 2).toLowerCase(); return; }\n        }\n    } catch (e) {}\n    var browserLang = navigator.language || navigator.userLanguage || 'en';\n    userLanguage = browserLang.substring(0, 2).toLowerCase();\n}\n\nvar formatUtils = {\n    date: function(date, format, lang) {\n        lang = lang || userLanguage || 'en';\n        var monthsShort = {\n            en: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            de: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']\n        };\n        var monthsFull = {\n            en: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n            de: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']\n        };\n        var d = new Date(date);\n        var shortMonths = monthsShort[lang] || monthsShort.en;\n        var fullMonths = monthsFull[lang] || monthsFull.en;\n        format = format || 'D MMM YYYY';\n        var tokens = {\n            'YYYY': d.getFullYear(),\n            'YY': String(d.getFullYear()).slice(-2),\n            'MMMM': fullMonths[d.getMonth()],\n            'MMM': shortMonths[d.getMonth()],\n            'MM': String(d.getMonth() + 1).padStart(2, '0'),\n            'DD': String(d.getDate()).padStart(2, '0'),\n            'D': String(d.getDate()),\n            'M': String(d.getMonth() + 1)\n        };\n        return format.replace(/(YYYY|MMMM|MMM|MM|DD|YY|D|M)/g, function(match) {\n            return tokens[match] !== undefined ? tokens[match] : match;\n        });\n    }\n};\n\nfunction fetchEntityAttributes(callback) {\n    var settings = self.ctx.settings || {};\n    var attributesToFetch = [];\n    var settingsToCheck = [settings.twCustomStartTime, settings.twCustomEndTime];\n\n    settingsToCheck.forEach(function(val) {\n        if (val && typeof val === 'string') {\n            var match = val.match(/^\\$\\{(.+)\\}$/);\n            if (match && attributesToFetch.indexOf(match[1]) === -1) {\n                attributesToFetch.push(match[1]);\n            }\n        }\n    });\n\n    if (attributesToFetch.length === 0) { callback(); return; }\n    if (!self.ctx.datasources || self.ctx.datasources.length === 0) { callback(); return; }\n\n    var ds = self.ctx.datasources[0];\n    if (!ds.entity || !ds.entity.id) { callback(); return; }\n\n    var entityId = ds.entity.id.id;\n    var entityType = ds.entity.id.entityType;\n    var keysParam = attributesToFetch.join(',');\n\n    var loadedCount = 0;\n    var totalScopes = 2;\n\n    function checkComplete() {\n        loadedCount++;\n        if (loadedCount >= totalScopes) { callback(); }\n    }\n\n    if (self.ctx.http) {\n        var serverUrl = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/values/attributes/SERVER_SCOPE?keys=' + keysParam;\n        self.ctx.http.get(serverUrl).subscribe(\n            function(response) {\n                if (response && Array.isArray(response)) {\n                    response.forEach(function(attr) { entityAttributes[attr.key] = attr.value; });\n                }\n                checkComplete();\n            },\n            function(error) { checkComplete(); }\n        );\n\n        var clientUrl = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/values/attributes/CLIENT_SCOPE?keys=' + keysParam;\n        self.ctx.http.get(clientUrl).subscribe(\n            function(response) {\n                if (response && Array.isArray(response)) {\n                    response.forEach(function(attr) {\n                        if (entityAttributes[attr.key] === undefined) {\n                            entityAttributes[attr.key] = attr.value;\n                        }\n                    });\n                }\n                checkComplete();\n            },\n            function(error) { checkComplete(); }\n        );\n    } else {\n        callback();\n    }\n}\n\nfunction resolveTimeValue(valueStr) {\n    if (!valueStr || valueStr === '') return null;\n\n    var varMatch = valueStr.match(/^\\$\\{(.+)\\}$/);\n    if (varMatch) {\n        var attrName = varMatch[1];\n\n        if (entityAttributes[attrName] !== undefined) {\n            var val = Number(entityAttributes[attrName]);\n            if (!isNaN(val) && val > 0) return val;\n        }\n        if (self.ctx.datasources && self.ctx.datasources[0]) {\n            var ds = self.ctx.datasources[0];\n            if (ds.entity && ds.entity.attributes && ds.entity.attributes[attrName] !== undefined) {\n                var val2 = Number(ds.entity.attributes[attrName]);\n                if (!isNaN(val2) && val2 > 0) return val2;\n            }\n        }\n        if (self.ctx.latestData) {\n            for (var i = 0; i < self.ctx.latestData.length; i++) {\n                var ld = self.ctx.latestData[i];\n                if (ld.dataKey && ld.dataKey.name === attrName && ld.data && ld.data.length > 0) {\n                    var val3 = Number(ld.data[ld.data.length - 1][1]);\n                    if (!isNaN(val3) && val3 > 0) return val3;\n                }\n            }\n        }\n        return null;\n    }\n    var numVal = Number(valueStr);\n    if (!isNaN(numVal) && numVal > 0) return numVal;\n    var dateVal = Date.parse(valueStr);\n    if (!isNaN(dateVal)) return dateVal;\n    return null;\n}\n\nfunction initTimewindowSelector() {\n    var settings = self.ctx.settings || {};\n    twState.mode = settings.twSelectorDefaultMode || 'custom';\n    twState.currentDate = new Date();\n\n    if (twState.mode === 'custom') {\n        if (settings.twCustomStartTime) {\n            var startMs = resolveTimeValue(settings.twCustomStartTime);\n            var endMs = settings.twCustomEndTime ? resolveTimeValue(settings.twCustomEndTime) : Date.now();\n\n            if (startMs && startMs > 0) {\n                twState.customStart = startMs;\n                twState.customEnd = (endMs && endMs > 0) ? endMs : Date.now();\n            } else {\n                var today = new Date();\n                today.setHours(0, 0, 0, 0);\n                twState.customStart = today.getTime();\n                twState.customEnd = Date.now();\n            }\n        } else {\n            var useDashboardTw = self.ctx.widget && self.ctx.widget.config ? self.ctx.widget.config.useDashboardTimewindow !== false : true;\n            var tw = useDashboardTw\n                ? (self.ctx.dashboard && self.ctx.dashboard.dashboardTimewindow)\n                : self.ctx.timeWindow;\n            var now = Date.now();\n\n            if (tw && tw.fixedTimewindow && tw.fixedTimewindow.startTimeMs) {\n                twState.customStart = tw.fixedTimewindow.startTimeMs;\n                twState.customEnd = tw.fixedTimewindow.endTimeMs || now;\n            } else if (tw && tw.history && tw.history.fixedTimewindow && tw.history.fixedTimewindow.startTimeMs) {\n                twState.customStart = tw.history.fixedTimewindow.startTimeMs;\n                twState.customEnd = tw.history.fixedTimewindow.endTimeMs || now;\n            } else {\n                var today = new Date();\n                today.setHours(0, 0, 0, 0);\n                twState.customStart = today.getTime();\n                twState.customEnd = now;\n            }\n        }\n\n        applyTimewindow();\n    }\n}\n\nfunction renderTimewindowSelector() {\n    if (!timewindowContainer) return;\n    var settings = self.ctx.settings || {};\n    var showSelector = settings.showTimewindowSelector === true;\n\n    if (!showSelector) { timewindowContainer.style.display = 'none'; return; }\n\n    while (timewindowContainer.firstChild) timewindowContainer.removeChild(timewindowContainer.firstChild);\n\n    var accentColor = settings.twSelectorColor || '#2196F3';\n    if (!settings.twSelectorColor && self.ctx.data && self.ctx.data[0] && self.ctx.data[0].dataKey) {\n        accentColor = self.ctx.data[0].dataKey.color || '#2196F3';\n    }\n\n    var positionMap = { left: 'flex-start', center: 'center', right: 'flex-end' };\n    var position = settings.twSelectorPosition || 'center';\n\n    timewindowContainer.style.display = 'flex';\n    timewindowContainer.style.alignItems = 'center';\n    timewindowContainer.style.justifyContent = positionMap[position] || 'center';\n    timewindowContainer.style.padding = '8px';\n\n    var wrapper = document.createElement('div');\n    wrapper.style.cssText = 'display: flex; align-items: center; gap: 6px; background: ' + accentColor + '; border-radius: 6px; padding: 6px 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.12);';\n\n    if (twState.mode !== 'custom') {\n        var navLeft = createButton('\\u25C0', function() { navigate(-1); });\n        wrapper.appendChild(navLeft);\n    }\n\n    var btnContainer = document.createElement('div');\n    btnContainer.style.cssText = 'display: flex; gap: 4px;';\n\n    var modes = [\n        { id: 'day', label: 'D', title: t('day') },\n        { id: 'week', label: 'W', title: t('week') },\n        { id: 'month', label: 'M', title: t('month') },\n        { id: 'custom', label: 'C', title: t('custom') }\n    ];\n\n    modes.forEach(function(m) {\n        var isActive = twState.mode === m.id;\n        var btn = document.createElement('button');\n        btn.textContent = m.label;\n        btn.title = m.title;\n        btn.style.cssText = 'border: none; width: 28px; height: 24px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600; transition: all 0.2s;';\n        if (isActive) { btn.style.background = 'white'; btn.style.color = accentColor; }\n        else { btn.style.background = 'rgba(255,255,255,0.2)'; btn.style.color = 'white'; }\n        btn.onmouseover = function() { if (!isActive) btn.style.background = 'rgba(255,255,255,0.35)'; };\n        btn.onmouseout = function() { if (!isActive) btn.style.background = 'rgba(255,255,255,0.2)'; };\n        btn.onclick = function() { selectMode(m.id); };\n        btnContainer.appendChild(btn);\n    });\n\n    wrapper.appendChild(btnContainer);\n\n    if (twState.mode !== 'custom') {\n        var navRight = createButton('\\u25B6', function() { navigate(1); });\n        wrapper.appendChild(navRight);\n    }\n\n    var label = document.createElement('span');\n    label.style.cssText = 'color: white; font-size: 11px; margin-left: 8px; opacity: 0.9;';\n    label.textContent = formatLabel();\n    wrapper.appendChild(label);\n\n    if (twState.mode === 'custom') {\n        var calBtn = createButton('\\uD83D\\uDCC5', function(e) { e.stopPropagation(); showDatePicker(wrapper, accentColor); });\n        calBtn.title = t('selectPeriod');\n        calBtn.style.marginLeft = '4px';\n        wrapper.appendChild(calBtn);\n    }\n\n    timewindowContainer.appendChild(wrapper);\n}\n\nfunction createButton(text, onClick) {\n    var btn = document.createElement('button');\n    btn.textContent = text;\n    btn.style.cssText = 'background: rgba(255,255,255,0.2); border: none; color: white; width: 24px; height: 24px; border-radius: 4px; cursor: pointer; font-size: 10px; display: flex; align-items: center; justify-content: center; transition: background 0.2s;';\n    btn.onmouseover = function() { btn.style.background = 'rgba(255,255,255,0.35)'; };\n    btn.onmouseout = function() { btn.style.background = 'rgba(255,255,255,0.2)'; };\n    btn.onclick = onClick;\n    return btn;\n}\n\nfunction selectMode(mode) {\n    twState.mode = mode;\n    if (mode !== 'custom') { twState.currentDate = new Date(); twState.customStart = null; twState.customEnd = null; }\n    applyTimewindow();\n    renderTimewindowSelector();\n}\n\nfunction navigate(direction) {\n    var d = new Date(twState.currentDate);\n    switch (twState.mode) {\n        case 'day': d.setDate(d.getDate() + direction); break;\n        case 'week': d.setDate(d.getDate() + (direction * 7)); break;\n        case 'month': d.setMonth(d.getMonth() + direction); break;\n    }\n    twState.currentDate = d;\n    applyTimewindow();\n    renderTimewindowSelector();\n}\n\nfunction calculateRange() {\n    var settings = self.ctx.settings || {};\n    var d = new Date(twState.currentDate);\n    var start, end;\n    switch (twState.mode) {\n        case 'day':\n            start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);\n            end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999);\n            break;\n        case 'week':\n            var dayOfWeek = d.getDay();\n            var diffToMonday = (dayOfWeek === 0 ? -6 : 1) - dayOfWeek;\n            var monday = new Date(d);\n            monday.setDate(d.getDate() + diffToMonday);\n            start = new Date(monday.getFullYear(), monday.getMonth(), monday.getDate(), 0, 0, 0, 0);\n            var sunday = new Date(monday);\n            sunday.setDate(monday.getDate() + 6);\n            end = new Date(sunday.getFullYear(), sunday.getMonth(), sunday.getDate(), 23, 59, 59, 999);\n            break;\n        case 'month':\n            start = new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);\n            end = new Date(d.getFullYear(), d.getMonth() + 1, 0, 23, 59, 59, 999);\n            break;\n        case 'custom':\n            if (twState.customStart && twState.customEnd) {\n                return { start: twState.customStart, end: twState.customEnd };\n            }\n            if (settings.twCustomStartTime) {\n                var startMs = resolveTimeValue(settings.twCustomStartTime);\n                var endMs = settings.twCustomEndTime ? resolveTimeValue(settings.twCustomEndTime) : Date.now();\n                if (startMs) return { start: startMs, end: endMs || Date.now() };\n            }\n            var today = new Date();\n            today.setHours(0, 0, 0, 0);\n            return { start: today.getTime(), end: Date.now() };\n    }\n    return { start: start.getTime(), end: end.getTime() };\n}\n\nfunction applyTimewindow() {\n    var range = calculateRange();\n    if (!range) return;\n\n    if (self.ctx.timewindowFunctions && self.ctx.timewindowFunctions.onUpdateTimewindow) {\n        if (self.ctx.$scope && self.ctx.$scope.$postDigest) {\n            self.ctx.$scope.$postDigest(function() {\n                self.ctx.timewindowFunctions.onUpdateTimewindow(range.start, range.end);\n            });\n        } else {\n            setTimeout(function() {\n                self.ctx.timewindowFunctions.onUpdateTimewindow(range.start, range.end);\n            }, 0);\n        }\n    }\n}\n\nfunction formatLabel() {\n    var settings = self.ctx.settings || {};\n    var d = twState.currentDate;\n    switch (twState.mode) {\n        case 'day': return formatUtils.date(d, settings.twSelectorDayFormat || 'DD.MM.YYYY');\n        case 'week':\n            var range = calculateRange();\n            if (range) {\n                var startD = new Date(range.start);\n                var endD = new Date(range.end);\n                var fmt = settings.twSelectorWeekFormat || 'DD.MM.YYYY - DD.MM.YYYY';\n                if (fmt.indexOf(' - ') !== -1) {\n                    var parts = fmt.split(' - ');\n                    return formatUtils.date(startD, parts[0]) + ' - ' + formatUtils.date(endD, parts[1] || parts[0]);\n                }\n                return formatUtils.date(startD, 'DD.MM.YYYY') + ' - ' + formatUtils.date(endD, 'DD.MM.YYYY');\n            }\n            return '';\n        case 'month': return formatUtils.date(d, settings.twSelectorMonthFormat || 'MMMM YYYY');\n        case 'custom':\n            if (twState.customStart && twState.customEnd) {\n                return formatUtils.date(new Date(twState.customStart), 'DD.MM.YY') + ' - ' + formatUtils.date(new Date(twState.customEnd), 'DD.MM.YY');\n            }\n            if (self.ctx.dashboard && self.ctx.dashboard.dashboardTimewindow) {\n                var tw = self.ctx.dashboard.dashboardTimewindow;\n                if (tw.history && tw.history.fixedTimewindow) {\n                    return formatUtils.date(new Date(tw.history.fixedTimewindow.startTimeMs), 'DD.MM.YY') + ' - ' + formatUtils.date(new Date(tw.history.fixedTimewindow.endTimeMs), 'DD.MM.YY');\n                }\n            }\n            return 'Dashboard';\n    }\n    return '';\n}\n\nfunction showDatePicker(anchor, accentColor) {\n    var existing = document.getElementById('eco-tw-datepicker');\n    if (existing) { existing.remove(); return; }\n\n    var startDate = new Date();\n    var endDate = new Date();\n    startDate.setDate(startDate.getDate() - 7);\n\n    if (twState.customStart && twState.customEnd) {\n        startDate = new Date(twState.customStart);\n        endDate = new Date(twState.customEnd);\n    } else if (self.ctx.dashboard && self.ctx.dashboard.dashboardTimewindow) {\n        var tw = self.ctx.dashboard.dashboardTimewindow;\n        if (tw.history && tw.history.fixedTimewindow) {\n            startDate = new Date(tw.history.fixedTimewindow.startTimeMs);\n            endDate = new Date(tw.history.fixedTimewindow.endTimeMs);\n        }\n    }\n\n    function toInputDate(d) {\n        return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');\n    }\n\n    var picker = document.createElement('div');\n    picker.id = 'eco-tw-datepicker';\n    picker.style.cssText = 'position: absolute; top: 100%; left: 50%; transform: translateX(-50%); margin-top: 4px; background: white; border-radius: 8px; padding: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.25); z-index: 10000; min-width: 280px;';\n\n    var title = document.createElement('div');\n    title.style.cssText = 'font-size: 12px; font-weight: 600; color: #333; margin-bottom: 10px;';\n    title.textContent = t('selectPeriod');\n    picker.appendChild(title);\n\n    var inputsRow = document.createElement('div');\n    inputsRow.style.cssText = 'display: flex; gap: 8px;';\n\n    var startDiv = document.createElement('div');\n    startDiv.style.cssText = 'flex: 1;';\n    var startLabel = document.createElement('label');\n    startLabel.style.cssText = 'font-size: 10px; color: #666; display: block; margin-bottom: 2px;';\n    startLabel.textContent = t('from');\n    var startInput = document.createElement('input');\n    startInput.type = 'date';\n    startInput.value = toInputDate(startDate);\n    startInput.style.cssText = 'width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; box-sizing: border-box;';\n    startDiv.appendChild(startLabel);\n    startDiv.appendChild(startInput);\n    inputsRow.appendChild(startDiv);\n\n    var endDiv = document.createElement('div');\n    endDiv.style.cssText = 'flex: 1;';\n    var endLabel = document.createElement('label');\n    endLabel.style.cssText = 'font-size: 10px; color: #666; display: block; margin-bottom: 2px;';\n    endLabel.textContent = t('to');\n    var endInput = document.createElement('input');\n    endInput.type = 'date';\n    endInput.value = toInputDate(endDate);\n    endInput.style.cssText = 'width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; box-sizing: border-box;';\n    endDiv.appendChild(endLabel);\n    endDiv.appendChild(endInput);\n    inputsRow.appendChild(endDiv);\n\n    picker.appendChild(inputsRow);\n\n    var btnRow = document.createElement('div');\n    btnRow.style.cssText = 'display: flex; gap: 6px; justify-content: flex-end; margin-top: 10px;';\n\n    var cancelBtn = document.createElement('button');\n    cancelBtn.textContent = t('cancel');\n    cancelBtn.style.cssText = 'padding: 6px 12px; border: 1px solid #ddd; background: white; border-radius: 4px; font-size: 11px; cursor: pointer;';\n    cancelBtn.onclick = function(e) { e.stopPropagation(); picker.remove(); };\n\n    var applyBtn = document.createElement('button');\n    applyBtn.textContent = t('apply');\n    applyBtn.style.cssText = 'padding: 6px 12px; border: none; background: ' + accentColor + '; color: white; border-radius: 4px; font-size: 11px; cursor: pointer; font-weight: 500;';\n    applyBtn.onclick = function(e) {\n        e.stopPropagation();\n        var newStart = new Date(startInput.value);\n        var newEnd = new Date(endInput.value);\n        newEnd.setHours(23, 59, 59, 999);\n        twState.customStart = newStart.getTime();\n        twState.customEnd = newEnd.getTime();\n        applyTimewindow();\n        picker.remove();\n        renderTimewindowSelector();\n    };\n\n    btnRow.appendChild(cancelBtn);\n    btnRow.appendChild(applyBtn);\n    picker.appendChild(btnRow);\n\n    anchor.style.position = 'relative';\n    anchor.appendChild(picker);\n\n    setTimeout(function() {\n        document.addEventListener('click', function closeHandler(e) {\n            if (!picker.contains(e.target)) { picker.remove(); document.removeEventListener('click', closeHandler); }\n        });\n    }, 100);\n}\n\n\nself.onInit = function() {\n    chartContainer = self.ctx.$container.find('#chart-container')[0];\n    timewindowContainer = self.ctx.$container.find('#timewindow-selector')[0];\n    statsCardContainers = {\n        top: self.ctx.$container.find('#stats-card-top')[0],\n        bottom: self.ctx.$container.find('#stats-card-bottom')[0],\n        left: self.ctx.$container.find('#stats-card-left')[0],\n        right: self.ctx.$container.find('#stats-card-right')[0]\n    };\n\n    if (!chartContainer) {\n        console.error('ECO Load Duration Curve: Chart container not found');\n        return;\n    }\n\n    if (typeof echarts === 'undefined') {\n        console.error('ECO Load Duration Curve: ECharts library not loaded');\n        return;\n    }\n\n    detectUserLanguage();\n    chart = echarts.init(chartContainer);\n\n    // Fetch entity attributes for timewindow selector, then initialize\n    fetchEntityAttributes(function() {\n        var settings = self.ctx.settings || {};\n        if (settings.showTimewindowSelector) {\n            initTimewindowSelector();\n        }\n        updateChart();\n    });\n\n    // Multiple delayed resizes to handle ThingsBoard's async layout\n    // Container size may not be final until layout completes\n    // Use inline code to avoid any closure/scoping issues\n    [100, 250, 500, 1000].forEach(function(delay) {\n        setTimeout(function() {\n            if (chart && chartContainer) {\n                var w = chartContainer.offsetWidth;\n                var h = chartContainer.offsetHeight;\n                chart.resize({ width: w, height: h });\n            }\n        }, delay);\n    });\n\n    // ResizeObserver for dynamic container size changes\n    if (typeof ResizeObserver !== 'undefined') {\n        resizeObserver = new ResizeObserver(function() {\n            requestAnimationFrame(function() {\n                if (chart && chartContainer) {\n                    chart.resize({\n                        width: chartContainer.offsetWidth,\n                        height: chartContainer.offsetHeight\n                    });\n                }\n            });\n        });\n        resizeObserver.observe(chartContainer);\n    }\n};\n\nself.onDataUpdated = function() {\n    updateChart();\n};\n\n\nfunction getOperatingState(timestamp, isOnData) {\n    if (!isOnData || isOnData.length === 0) return null;\n\n    var closestValue = null;\n    var closestTs = -Infinity;\n\n    for (var i = 0; i < isOnData.length; i++) {\n        var ts = isOnData[i][0];\n        if (ts <= timestamp && ts > closestTs) {\n            closestTs = ts;\n            closestValue = isOnData[i][1];\n        }\n    }\n\n    if (closestValue === null) return null;\n\n    if (typeof closestValue === 'boolean') return closestValue;\n    if (typeof closestValue === 'number') return closestValue > 0;\n    if (typeof closestValue === 'string') {\n        var lower = closestValue.toLowerCase();\n        return lower === 'true' || lower === '1' || lower === 'on' || lower === 'yes';\n    }\n\n    return null;\n}\n\nfunction updateChart() {\n    if (!chart) return;\n\n    var settings = self.ctx.settings || {};\n\n    // Render timewindow selector\n    renderTimewindowSelector();\n\n    // Display settings\n    var showLoadProfile = settings.showLoadProfile === true;\n    var showDurationCurve = settings.showDurationCurve !== false;\n\n    // Data processing settings\n    var dataType = settings.dataType || 'power';\n    var energyToPower = settings.energyToPower === true;\n\n    // Outlier removal settings\n    var removeOutliers = settings.removeOutliers === true;\n    var outlierMethod = settings.outlierMethod || 'iqr';\n    var outlierIqrMultiplier = settings.outlierIqrMultiplier || 1.5;\n    var outlierZscoreThreshold = settings.outlierZscoreThreshold || 3;\n    var outlierMinValue = settings.outlierMinValue;\n    var outlierMaxValue = settings.outlierMaxValue;\n\n    // Smoothing settings\n    var smoothingEnabled = settings.smoothingEnabled === true;\n    var smoothingWindow = settings.smoothingWindow || 5;\n\n    // Threshold settings\n    var showThresholds = settings.showThresholds === true;\n    var autoDetectThresholds = settings.autoDetectThresholds !== false;\n    var baseLoadPercentile = settings.baseLoadPercentile !== undefined ? settings.baseLoadPercentile : 10;\n    var peakLoadPercentile = settings.peakLoadPercentile !== undefined ? settings.peakLoadPercentile : 90;\n    var manualBaseLoad = settings.manualBaseLoad;\n    var manualPeakLoad = settings.manualPeakLoad;\n    var baseLoadColor = settings.baseLoadColor || '#4CAF50';\n    var peakLoadColor = settings.peakLoadColor || '#F44336';\n\n    // Statistical lines\n    var showMean = settings.showMean === true;\n    var showMedian = settings.showMedian === true;\n    var meanColor = settings.meanColor || '#FF9800';\n    var medianColor = settings.medianColor || '#9C27B0';\n\n    // NEW: Also read from Energy Analysis settings (takes precedence)\n    if (settings.showMeanLine !== undefined) showMean = settings.showMeanLine === true;\n    if (settings.showMedianLine !== undefined) showMedian = settings.showMedianLine === true;\n    if (settings.meanLineColor) meanColor = settings.meanLineColor;\n    if (settings.medianLineColor) medianColor = settings.medianLineColor;\n    if (settings.showBaseloadLine !== undefined) showThresholds = showThresholds || settings.showBaseloadLine === true;\n    if (settings.showPeakloadLine !== undefined) showThresholds = showThresholds || settings.showPeakloadLine === true;\n    if (settings.baseloadLineColor) baseLoadColor = settings.baseloadLineColor;\n    if (settings.peakloadLineColor) peakLoadColor = settings.peakloadLineColor;\n\n    // Axis settings\n    var yAxisMin = settings.yAxisMin;\n    var yAxisMax = settings.yAxisMax;\n    var yAxisLabel = settings.yAxisLabel || '';\n\n    // Chart appearance\n    var defaultSeriesColor = '#2196F3';\n    var showLegend = settings.showLegend !== false;\n    var showTooltip = settings.showTooltip !== false;\n\n    // Legend settings\n    var legendPosition = settings.legendPosition || 'bottom';\n    var legendStyle = settings.legendStyle || 'classic'; // 'classic' or 'card'\n    var legendAlign = settings.legendAlign || 'center'; // 'left', 'center', 'right'\n    var legendCardColorMode = settings.legendCardColorMode || 'auto'; // 'auto', 'manual', 'gradient'\n    var legendCardColor = settings.legendCardColor || '#2196F3';\n    var legendValues = settings.legendValues || ['current']; // Array: ['current', 'min', 'max', 'avg', 'median', 'sum', 'count']\n\n    // Timestamp settings\n    var showTimestamp = settings.showTimestamp !== false;\n    var timestampFormat = settings.timestampFormat || 'YYYY-MM-DD HH:mm:ss';\n\n    // Toolbox settings\n    var showToolbox = settings.showToolbox !== false;\n    var enableMouseZoom = settings.enableMouseZoom === true;\n    var toolboxFeatures = settings.toolboxFeatures || ['saveAsImage', 'dataView', 'dataZoom', 'restore'];\n    var showSaveAsImage = toolboxFeatures.indexOf('saveAsImage') !== -1;\n    var showDataView = toolboxFeatures.indexOf('dataView') !== -1;\n    var showDataZoom = toolboxFeatures.indexOf('dataZoom') !== -1;\n    var showRestore = toolboxFeatures.indexOf('restore') !== -1;\n\n    // Get data from datasources\n    var data = self.ctx.data || [];\n    if (!data.length || !data[0].data || !data[0].data.length) {\n        showNoData('No data available');\n        return;\n    }\n\n    var seriesData = data[0].data;\n    var dataKey = data[0].dataKey || {};\n    var datasource = data[0].datasource || {};\n\n    // Determine display name: prefer label, then entityName, then key name\n    var label = dataKey.label || datasource.entityName || datasource.name || dataKey.name || 'Value';\n\n    // Use dataKey settings for units/decimals\n    var units = dataKey.units || self.ctx.units || '';\n    var decimals = dataKey.decimals !== undefined ? dataKey.decimals : 2;\n    var dataKeyColor = dataKey.color || null;\n\n    // Energy Analysis settings\n    var showBaselineAnalysis = settings.showBaselineAnalysis === true || settings.showBaseloadLine === true || settings.showPeakloadLine === true;\n    var baseloadMethod = settings.baseloadMethod || 'percentile';\n    var baseloadPercentile = settings.baseloadPercentile || 10;\n    var peakloadMethod = settings.peakloadMethod || 'percentile';\n    var peakloadPercentile = settings.peakloadPercentile || 95;\n    var peakloadSigma = settings.peakloadSigma || 2;\n\n    // Get is_on data if available\n    var isOnData = null;\n    var isOnKeyName = settings.isOnDataKey || 'is_on';\n\n    if (showBaselineAnalysis && data.length > 1) {\n        for (var idx = 1; idx < data.length; idx++) {\n            var dk = data[idx].dataKey;\n            if (dk && (dk.name === isOnKeyName || dk.label === isOnKeyName)) {\n                isOnData = data[idx].data;\n                break;\n            }\n        }\n    }\n\n    // Extract and process values\n    var rawValues = [];\n    var timestamps = [];\n\n    for (var i = 0; i < seriesData.length; i++) {\n        var ts = seriesData[i][0];\n        var val = seriesData[i][1];\n        // Convert to number (handles strings like \"54.0\")\n        var numVal = Number(val);\n        if (val !== null && val !== undefined && !isNaN(numVal) && isFinite(numVal)) {\n            timestamps.push(ts);\n            rawValues.push(numVal);\n\n        }\n    }\n\n    if (rawValues.length === 0) {\n        showNoData('No valid data points');\n        return;\n    }\n\n    // Energy to power conversion (kWh to kW)\n    var values = rawValues.slice();\n    if (energyToPower && dataType === 'energy' && timestamps.length > 1) {\n        values = convertEnergyToPower(rawValues, timestamps);\n        units = units.replace(/Wh/i, 'W').replace(/wh/i, 'w');\n        label = label + ' (Power)';\n    }\n\n    // Save raw copies for energy analysis (before outlier removal and smoothing)\n    // Energy analysis should bucket raw data, matching heatmap behavior\n    var rawValuesForAnalysis = values.slice();\n    var rawTimestampsForAnalysis = timestamps.slice();\n\n    // Remove outliers BEFORE other processing\n    var outlierInfo = { removed: 0, method: 'none' };\n    if (removeOutliers) {\n        var result = removeOutliersFromData(values, timestamps, {\n            method: outlierMethod,\n            iqrMultiplier: outlierIqrMultiplier,\n            zscoreThreshold: outlierZscoreThreshold,\n            minValue: outlierMinValue,\n            maxValue: outlierMaxValue\n        });\n        values = result.values;\n        timestamps = result.timestamps;\n        outlierInfo = { removed: result.removed, method: outlierMethod };\n\n        if (values.length === 0) {\n            showNoData('All data points removed as outliers');\n            return;\n        }\n    }\n\n    // Apply smoothing if enabled\n    if (smoothingEnabled && smoothingWindow > 1) {\n        values = movingAverage(values, smoothingWindow);\n    }\n\n    // Calculate statistics\n    var stats = calculateStatistics(values);\n\n    // Add current value and last timestamp\n    if (values.length > 0 && timestamps.length > 0) {\n        stats.current = values[values.length - 1];\n        stats.lastTimestamp = timestamps[timestamps.length - 1];\n    }\n\n    // Calculate energy analysis (baseload/peakload)\n    energyAnalysis = {\n        operatingBaseline: null,\n        operatingMean: null,\n        operatingStdDev: null,\n        peakThreshold: null\n    };\n\n    if (showBaselineAnalysis && rawValuesForAnalysis.length > 0) {\n        // Use RAW data with time-bucket aggregation (consistent with Heatmap Cartesian)\n        // Heatmap: raw data -> hourly cell averages -> percentile\n        // LDC: raw data -> 60-min bucket averages -> percentile (same pipeline)\n        var bucketSize = 60; // Fixed 60-min buckets to match heatmap time resolution\n        var bucketResult = aggregateTimeBucketsWithIsOn(\n            rawValuesForAnalysis, rawTimestampsForAnalysis, bucketSize, isOnData\n        );\n\n        // FIRST PASS: Use ALL bucket values for peakload (matches heatmap first pass)\n        var allBucketValues = bucketResult.allValues;\n        if (allBucketValues.length > 0) {\n            var sortedAll = allBucketValues.slice().sort(function(a, b) { return a - b; });\n            var allSum = 0;\n            for (var av = 0; av < allBucketValues.length; av++) allSum += allBucketValues[av];\n            var allMean = allSum / allBucketValues.length;\n            var allSquares = 0;\n            for (var as = 0; as < allBucketValues.length; as++) {\n                allSquares += Math.pow(allBucketValues[as] - allMean, 2);\n            }\n            var allStdDev = Math.sqrt(allSquares / allBucketValues.length);\n\n            // Initial values from all data\n            energyAnalysis.operatingMean = allMean;\n            energyAnalysis.operatingStdDev = allStdDev;\n\n            // Calculate baseload from all values (may be overridden by operating pass)\n            switch (baseloadMethod) {\n                case 'minimum':\n                    energyAnalysis.operatingBaseline = sortedAll[0];\n                    break;\n                case 'percentile':\n                    energyAnalysis.operatingBaseline = percentile(sortedAll, baseloadPercentile);\n                    break;\n                case 'rollingMin':\n                    var dailyMins = {};\n                    for (var dm = 0; dm < rawTimestampsForAnalysis.length; dm++) {\n                        var dayKey = new Date(rawTimestampsForAnalysis[dm]).toDateString();\n                        var v = rawValuesForAnalysis[dm];\n                        if (v > 0.1 && (dailyMins[dayKey] === undefined || v < dailyMins[dayKey])) {\n                            dailyMins[dayKey] = v;\n                        }\n                    }\n                    var minVals = Object.values(dailyMins);\n                    if (minVals.length > 0) {\n                        var minSum = 0;\n                        for (var ms = 0; ms < minVals.length; ms++) minSum += minVals[ms];\n                        energyAnalysis.operatingBaseline = minSum / minVals.length;\n                    } else {\n                        energyAnalysis.operatingBaseline = sortedAll[0];\n                    }\n                    break;\n                case 'integral':\n                    energyAnalysis.operatingBaseline = percentile(sortedAll, 5);\n                    break;\n                default:\n                    energyAnalysis.operatingBaseline = percentile(sortedAll, 10);\n            }\n\n            // Calculate peakload from ALL values (never overridden, matches heatmap)\n            switch (peakloadMethod) {\n                case 'percentile':\n                    energyAnalysis.peakThreshold = percentile(sortedAll, peakloadPercentile);\n                    break;\n                case 'integral':\n                    energyAnalysis.peakThreshold = allMean + (allStdDev * peakloadSigma);\n                    break;\n                case 'percentage':\n                    var peakPct = settings.peakThresholdValue || 150;\n                    energyAnalysis.peakThreshold = allMean * (peakPct / 100);\n                    break;\n                case 'absolute':\n                    energyAnalysis.peakThreshold = settings.peakThresholdValue || sortedAll[sortedAll.length - 1];\n                    break;\n                default:\n                    energyAnalysis.peakThreshold = percentile(sortedAll, 95);\n            }\n\n            // SECOND PASS: Override baseload with operating values if is_on data available\n            // Matches heatmap behavior: second pass only recalculates baseload, not peakload\n            if (isOnData && bucketResult.operatingValues.length > 0) {\n                // Filter > 0.1 to match heatmap's nonZeroOperatingCells filter\n                var opValues = bucketResult.operatingValues.filter(function(v) { return v > 0.1; });\n                if (opValues.length > 0) {\n                    var sortedOp = opValues.slice().sort(function(a, b) { return a - b; });\n                    var opSum = 0;\n                    for (var ov = 0; ov < opValues.length; ov++) opSum += opValues[ov];\n                    var opMean = opSum / opValues.length;\n                    var opSquares = 0;\n                    for (var os = 0; os < opValues.length; os++) {\n                        opSquares += Math.pow(opValues[os] - opMean, 2);\n                    }\n\n                    energyAnalysis.operatingMean = opMean;\n                    energyAnalysis.operatingStdDev = Math.sqrt(opSquares / opValues.length);\n\n                    // Override baseload with operating values\n                    switch (baseloadMethod) {\n                        case 'minimum':\n                            energyAnalysis.operatingBaseline = sortedOp[0];\n                            break;\n                        case 'percentile':\n                            energyAnalysis.operatingBaseline = percentile(sortedOp, baseloadPercentile);\n                            break;\n                        case 'integral':\n                            energyAnalysis.operatingBaseline = percentile(sortedOp, 5);\n                            break;\n                        default:\n                            energyAnalysis.operatingBaseline = percentile(sortedOp, 10);\n                    }\n                }\n            }\n        }\n    }\n\n    // Calculate thresholds - use energyAnalysis values (same as legend card)\n    var baseLoadValue, peakLoadValue;\n    if (showThresholds) {\n        // Use energyAnalysis values (calculated with baseloadMethod/peakloadMethod)\n        // This ensures chart lines match the legend card values\n        if (energyAnalysis.operatingBaseline !== null) {\n            baseLoadValue = energyAnalysis.operatingBaseline;\n        }\n        if (energyAnalysis.peakThreshold !== null) {\n            peakLoadValue = energyAnalysis.peakThreshold;\n        }\n    }\n\n    // Prepare duration curve data (sorted descending)\n    var sortedValues = values.slice().sort(function(a, b) { return b - a; });\n    var durationData = [];\n    for (var j = 0; j < sortedValues.length; j++) {\n        var pct = sortedValues.length > 1 ? (j / (sortedValues.length - 1)) * 100 : 0;\n        durationData.push([Math.round(pct * 10) / 10, sortedValues[j]]);\n    }\n\n    // Prepare load profile data (time series)\n    var loadProfileData = [];\n    for (var k = 0; k < timestamps.length; k++) {\n        loadProfileData.push([timestamps[k], values[k]]);\n    }\n\n    // Determine series color: prefer dataKey color, then default\n    var seriesColor = dataKeyColor || defaultSeriesColor;\n\n    // Build ECharts option\n    var option = buildChartOption({\n        showLoadProfile: showLoadProfile,\n        showDurationCurve: showDurationCurve,\n        loadProfileData: loadProfileData,\n        durationData: durationData,\n        label: label,\n        units: units,\n        decimals: decimals,\n        seriesColor: seriesColor,\n        showLegend: showLegend,\n        showTooltip: showTooltip,\n        showThresholds: showThresholds,\n        baseLoadValue: baseLoadValue,\n        peakLoadValue: peakLoadValue,\n        baseLoadColor: baseLoadColor,\n        peakLoadColor: peakLoadColor,\n        showMean: showMean,\n        showMedian: showMedian,\n        meanValue: stats.mean,\n        medianValue: stats.median,\n        meanColor: meanColor,\n        medianColor: medianColor,\n        yAxisMin: yAxisMin,\n        yAxisMax: yAxisMax,\n        yAxisLabel: yAxisLabel || (label + (units ? ' (' + units + ')' : '')),\n        outlierInfo: outlierInfo,\n        // Legend settings\n        stats: stats,\n        legendPosition: legendPosition,\n        legendStyle: legendStyle,\n        legendValues: legendValues,\n        // Toolbox settings\n        showToolbox: showToolbox,\n        showSaveAsImage: showSaveAsImage,\n        showDataView: showDataView,\n        showDataZoom: showDataZoom,\n        showRestore: showRestore,\n        enableMouseZoom: enableMouseZoom\n    });\n\n    chart.setOption(option, true);\n\n    // Render statistics card in DOM (outside ECharts)\n    renderStatsCard({\n        showLegend: showLegend,\n        legendStyle: legendStyle,\n        legendAlign: legendAlign,\n        legendCardColorMode: legendCardColorMode,\n        legendCardColor: legendCardColor,\n        legendValues: legendValues,\n        legendPosition: legendPosition,\n        showTimestamp: showTimestamp,\n        timestampFormat: timestampFormat,\n        stats: stats,\n        label: label,\n        units: units,\n        decimals: decimals,\n        seriesColor: seriesColor\n    });\n\n    // Resize chart after stats cards are rendered to fix container height\n    // Use multiple strategies to ensure resize happens after layout is complete\n    function doResize() {\n        if (chart && chartContainer) {\n            chart.resize({\n                width: chartContainer.offsetWidth,\n                height: chartContainer.offsetHeight\n            });\n        }\n    }\n\n    // Strategy 1: requestAnimationFrame for next paint\n    requestAnimationFrame(function() {\n        requestAnimationFrame(doResize);\n    });\n\n    // Strategy 2: setTimeout fallbacks at different intervals\n    setTimeout(doResize, 100);\n    setTimeout(doResize, 250);\n}\n\nfunction renderStatsCard(config) {\n    // Clear all containers first\n    ['top', 'bottom', 'left', 'right'].forEach(function(pos) {\n        var container = statsCardContainers[pos];\n        if (container) {\n            container.style.display = 'none';\n            while (container.firstChild) {\n                container.removeChild(container.firstChild);\n            }\n        }\n    });\n\n    var legendValues = config.legendValues || [];\n    var legendStyle = config.legendStyle || 'classic';\n    var showCard = config.showLegend && legendStyle === 'card' && legendValues.length > 0 && config.stats;\n\n    if (!showCard) return;\n\n    var position = config.legendPosition || 'bottom';\n    var align = config.legendAlign || 'center';\n    var container = statsCardContainers[position];\n    if (!container) return;\n\n    // Set container to flex for alignment\n    var isVertical = (position === 'left' || position === 'right');\n    var justifyMap = { left: 'flex-start', center: 'center', right: 'flex-end' };\n    var alignMap = { left: 'flex-start', center: 'center', right: 'flex-end' };\n\n    container.style.display = 'flex';\n    if (isVertical) {\n        container.style.flexDirection = 'column';\n        container.style.alignItems = alignMap[align];\n        container.style.justifyContent = 'flex-start';\n    } else {\n        container.style.flexDirection = 'row';\n        container.style.justifyContent = justifyMap[align];\n        container.style.alignItems = 'flex-start';\n    }\n\n    var stats = config.stats;\n    var unit = config.units || '';\n    var dec = config.decimals !== undefined ? config.decimals : 2;\n    var seriesColor = config.seriesColor || '#2196F3';\n    var colorMode = config.legendCardColorMode || 'auto';\n    var manualColor = config.legendCardColor || '#2196F3';\n\n    // Determine background color/style based on mode\n    var bgColor = colorMode === 'manual' ? manualColor : seriesColor;\n    var bgStyle;\n    if (colorMode === 'gradient') {\n        var gradientDir = isVertical ? '180deg' : '135deg';\n        bgStyle = 'linear-gradient(' + gradientDir + ', ' + bgColor + ' 0%, ' + adjustColor(bgColor, -40) + ' 100%)';\n    } else {\n        bgStyle = bgColor;\n    }\n\n    // Build the statistics card using DOM methods\n    var card = document.createElement('div');\n    card.style.cssText = 'background: ' + bgStyle + '; border-radius: 6px; padding: ' + (isVertical ? '10px 8px' : '8px 12px') + '; color: white; box-shadow: 0 2px 6px rgba(0,0,0,0.12); width: fit-content;';\n\n    var titleEl = document.createElement('div');\n    titleEl.style.cssText = 'font-size: ' + (isVertical ? '11px' : '12px') + '; font-weight: 600; margin-bottom: 8px; opacity: 0.95;' + (isVertical ? ' text-align: center;' : '');\n    titleEl.textContent = config.label + (unit ? ' (' + unit + ')' : '');\n    card.appendChild(titleEl);\n\n    var statsRow = document.createElement('div');\n    statsRow.style.cssText = 'display: flex; flex-wrap: wrap; gap: 6px;' + (isVertical ? ' flex-direction: column;' : '');\n\n    legendValues.forEach(function(val) {\n        var statValue, label, icon;\n        switch(val) {\n            case 'current': statValue = stats.current; label = 'Current'; icon = '\\u25CF'; break;\n            case 'min': statValue = stats.min; label = 'Min'; icon = '\\u2193'; break;\n            case 'max': statValue = stats.max; label = 'Max'; icon = '\\u2191'; break;\n            case 'avg': statValue = stats.mean; label = 'Avg'; icon = '\\u03BC'; break;\n            case 'mean': statValue = stats.mean; label = 'Mean'; icon = '\\u03BC'; break;\n            case 'median': statValue = stats.median; label = 'Median'; icon = '~'; break;\n            case 'sum': statValue = stats.sum; label = 'Sum'; icon = '\\u03A3'; break;\n            case 'count': statValue = stats.count; label = 'Count'; icon = 'n'; break;\n            case 'baseload': statValue = energyAnalysis.operatingBaseline; label = 'Baseload'; icon = ''; break;\n            case 'peak': statValue = energyAnalysis.peakThreshold; label = 'Peakload'; icon = ''; break;\n            default: return;\n        }\n        if (statValue !== undefined && statValue !== null) {\n            var formattedVal = val === 'count' ? String(statValue) : statValue.toFixed(dec);\n\n            var statBox = document.createElement('div');\n            statBox.style.cssText = 'background: rgba(255,255,255,0.18); border-radius: 4px; padding: ' + (isVertical ? '4px 6px' : '4px 8px') + ';' + (isVertical ? ' text-align: center;' : ' min-width: 60px;');\n\n            var labelEl = document.createElement('div');\n            labelEl.style.cssText = 'font-size: 9px; opacity: 0.85;';\n            labelEl.textContent = icon ? (icon + ' ' + label) : label;\n            statBox.appendChild(labelEl);\n\n            var valueEl = document.createElement('div');\n            valueEl.style.cssText = 'font-size: ' + (isVertical ? '12px' : '13px') + '; font-weight: 600;';\n            valueEl.textContent = formattedVal;\n            statBox.appendChild(valueEl);\n\n            statsRow.appendChild(statBox);\n        }\n    });\n\n    card.appendChild(statsRow);\n\n    // Timestamp display\n    if (config.showTimestamp && stats.lastTimestamp) {\n        var timestampEl = document.createElement('div');\n        timestampEl.style.cssText = 'font-size: 9px; opacity: 0.7; margin-top: 6px;' + (isVertical ? ' text-align: center;' : '');\n        timestampEl.textContent = formatTimestamp(stats.lastTimestamp, config.timestampFormat);\n        card.appendChild(timestampEl);\n    }\n\n    container.appendChild(card);\n}\n\n// Helper function to darken/lighten a hex color\nfunction adjustColor(color, amount) {\n    var usePound = false;\n    if (color[0] === '#') {\n        color = color.slice(1);\n        usePound = true;\n    }\n\n    var num = parseInt(color, 16);\n    var r = Math.min(255, Math.max(0, (num >> 16) + amount));\n    var g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));\n    var b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));\n\n    return (usePound ? '#' : '') + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');\n}\n\nfunction showNoData(message) {\n    if (!chart) return;\n    chart.setOption({\n        title: {\n            text: message,\n            left: 'center',\n            top: 'middle',\n            textStyle: { color: '#999', fontSize: 14 }\n        }\n    }, true);\n}\n\nfunction removeOutliersFromData(values, timestamps, options) {\n    var method = options.method || 'iqr';\n    var cleanValues = [];\n    var cleanTimestamps = [];\n    var removed = 0;\n\n    if (method === 'manual') {\n        var minVal = options.minValue !== undefined && options.minValue !== null ? options.minValue : -Infinity;\n        var maxVal = options.maxValue !== undefined && options.maxValue !== null ? options.maxValue : Infinity;\n\n        for (var i = 0; i < values.length; i++) {\n            if (values[i] >= minVal && values[i] <= maxVal) {\n                cleanValues.push(values[i]);\n                cleanTimestamps.push(timestamps[i]);\n            } else {\n                removed++;\n            }\n        }\n    } else if (method === 'zscore') {\n        var threshold = options.zscoreThreshold || 3;\n        var stats = calculateStatistics(values);\n        var stdDev = calculateStdDev(values, stats.mean);\n\n        if (stdDev === 0) {\n            return { values: values, timestamps: timestamps, removed: 0 };\n        }\n\n        for (var j = 0; j < values.length; j++) {\n            var zscore = Math.abs((values[j] - stats.mean) / stdDev);\n            if (zscore <= threshold) {\n                cleanValues.push(values[j]);\n                cleanTimestamps.push(timestamps[j]);\n            } else {\n                removed++;\n            }\n        }\n    } else {\n        var multiplier = options.iqrMultiplier || 1.5;\n        var sorted = values.slice().sort(function(a, b) { return a - b; });\n        var q1 = percentile(sorted, 25);\n        var q3 = percentile(sorted, 75);\n        var iqr = q3 - q1;\n\n        if (iqr === 0) {\n            var median = percentile(sorted, 50);\n            var range = Math.abs(median) * 0.5;\n            if (range === 0) range = 1;\n            var lowerBound = median - range;\n            var upperBound = median + range;\n\n            for (var m = 0; m < values.length; m++) {\n                if (values[m] >= lowerBound && values[m] <= upperBound) {\n                    cleanValues.push(values[m]);\n                    cleanTimestamps.push(timestamps[m]);\n                } else {\n                    removed++;\n                }\n            }\n        } else {\n            var lowerFence = q1 - (multiplier * iqr);\n            var upperFence = q3 + (multiplier * iqr);\n\n            for (var n = 0; n < values.length; n++) {\n                if (values[n] >= lowerFence && values[n] <= upperFence) {\n                    cleanValues.push(values[n]);\n                    cleanTimestamps.push(timestamps[n]);\n                } else {\n                    removed++;\n                }\n            }\n        }\n    }\n\n    return {\n        values: cleanValues,\n        timestamps: cleanTimestamps,\n        removed: removed\n    };\n}\n\nfunction calculateStdDev(values, mean) {\n    if (values.length === 0) return 0;\n    var sumSquares = 0;\n    for (var i = 0; i < values.length; i++) {\n        sumSquares += Math.pow(values[i] - mean, 2);\n    }\n    return Math.sqrt(sumSquares / values.length);\n}\n\nfunction convertEnergyToPower(energyValues, timestamps) {\n    var powerValues = [];\n    for (var i = 0; i < energyValues.length; i++) {\n        if (i === 0) {\n            powerValues.push(0);\n        } else {\n            var deltaEnergy = energyValues[i] - energyValues[i - 1];\n            var deltaTimeHours = (timestamps[i] - timestamps[i - 1]) / 3600000;\n            if (deltaTimeHours > 0) {\n                var power = deltaEnergy / deltaTimeHours;\n                powerValues.push(power);\n            } else {\n                powerValues.push(powerValues[i - 1] || 0);\n            }\n        }\n    }\n    if (powerValues.length > 1) {\n        powerValues[0] = powerValues[1];\n    }\n    return powerValues;\n}\n\nfunction aggregateTimeBuckets(values, timestamps, bucketSizeMinutes) {\n    if (!bucketSizeMinutes || bucketSizeMinutes <= 0 || values.length === 0) {\n        return values.slice();\n    }\n    var bucketMs = bucketSizeMinutes * 60 * 1000;\n    var buckets = {};\n    for (var i = 0; i < values.length; i++) {\n        var bucketKey = Math.floor(timestamps[i] / bucketMs);\n        if (!buckets[bucketKey]) {\n            buckets[bucketKey] = { sum: 0, count: 0 };\n        }\n        buckets[bucketKey].sum += values[i];\n        buckets[bucketKey].count++;\n    }\n    var result = [];\n    var keys = Object.keys(buckets).sort(function(a, b) { return a - b; });\n    for (var j = 0; j < keys.length; j++) {\n        var b = buckets[keys[j]];\n        result.push(b.sum / b.count);\n    }\n    return result;\n}\n\nfunction aggregateTimeBucketsWithIsOn(values, timestamps, bucketSizeMinutes, isOnData) {\n    if (!bucketSizeMinutes || bucketSizeMinutes <= 0 || values.length === 0) {\n        return { allValues: values.slice(), operatingValues: [] };\n    }\n    var bucketMs = bucketSizeMinutes * 60 * 1000;\n    var buckets = {};\n    for (var i = 0; i < values.length; i++) {\n        var bucketKey = Math.floor(timestamps[i] / bucketMs);\n        if (!buckets[bucketKey]) {\n            buckets[bucketKey] = { sum: 0, count: 0, isOnCount: 0, isOnTotal: 0 };\n        }\n        buckets[bucketKey].sum += values[i];\n        buckets[bucketKey].count++;\n\n        // Track is_on state per bucket\n        if (isOnData && isOnData.length > 0) {\n            buckets[bucketKey].isOnTotal++;\n            var isOn = getOperatingState(timestamps[i], isOnData);\n            if (isOn === true) {\n                buckets[bucketKey].isOnCount++;\n            }\n        }\n    }\n    var allValues = [];\n    var operatingValues = [];\n    var keys = Object.keys(buckets).sort(function(a, b) { return a - b; });\n    for (var j = 0; j < keys.length; j++) {\n        var b = buckets[keys[j]];\n        var avg = b.sum / b.count;\n        allValues.push(avg);\n\n        // Operating bucket: majority of readings have is_on=true\n        if (isOnData && isOnData.length > 0) {\n            if (b.isOnTotal > 0 && (b.isOnCount / b.isOnTotal) > 0.5) {\n                operatingValues.push(avg);\n            }\n        }\n    }\n    return { allValues: allValues, operatingValues: operatingValues };\n}\n\nfunction movingAverage(values, windowSize) {\n    var result = [];\n    var halfWindow = Math.floor(windowSize / 2);\n\n    for (var i = 0; i < values.length; i++) {\n        var start = Math.max(0, i - halfWindow);\n        var end = Math.min(values.length, i + halfWindow + 1);\n        var sum = 0;\n        for (var j = start; j < end; j++) {\n            sum += values[j];\n        }\n        result.push(sum / (end - start));\n    }\n    return result;\n}\n\nfunction calculateStatistics(values) {\n    if (values.length === 0) {\n        return { mean: 0, median: 0, min: 0, max: 0, sum: 0, count: 0 };\n    }\n\n    var sorted = values.slice().sort(function(a, b) { return a - b; });\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n\n    return {\n        mean: sum / values.length,\n        median: percentile(sorted, 50),\n        min: sorted[0],\n        max: sorted[sorted.length - 1],\n        sum: sum,\n        count: values.length\n    };\n}\n\nfunction percentile(sortedValues, p) {\n    if (sortedValues.length === 0) return 0;\n    if (sortedValues.length === 1) return sortedValues[0];\n\n    var index = (p / 100) * (sortedValues.length - 1);\n    var lower = Math.floor(index);\n    var upper = Math.ceil(index);\n    var weight = index - lower;\n\n    if (upper >= sortedValues.length) return sortedValues[sortedValues.length - 1];\n    return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;\n}\n\nfunction buildChartOption(config) {\n    var grids = [];\n    var xAxes = [];\n    var yAxes = [];\n    var series = [];\n    var titles = [];\n\n    var showBoth = config.showLoadProfile && config.showDurationCurve;\n\n    var subtitle = '';\n    if (config.outlierInfo && config.outlierInfo.removed > 0) {\n        subtitle = config.outlierInfo.removed + ' outliers removed (' + config.outlierInfo.method + ')';\n    }\n\n    if (showBoth) {\n        // Use percentage-based layout that doesn't overlap\n        // Top chart: from top to 48%, Bottom chart: from 52% to bottom\n        grids = [\n            { left: 60, right: 20, top: 40, bottom: '55%' },\n            { left: 60, right: 20, top: '55%', bottom: 45 }\n        ];\n\n        titles = [\n            {\n                text: 'Load Profile',\n                subtext: subtitle,\n                left: 'center',\n                top: 2,\n                textStyle: { fontSize: 12 },\n                subtextStyle: { fontSize: 9, color: '#999' }\n            },\n            { text: 'Duration Curve', left: 'center', top: '49%', textStyle: { fontSize: 12 } }\n        ];\n\n        xAxes.push({\n            type: 'time',\n            gridIndex: 0,\n            axisLabel: { fontSize: 10 },\n            splitLine: { show: false }\n        });\n\n        xAxes.push({\n            type: 'value',\n            gridIndex: 1,\n            name: '% of Time',\n            nameLocation: 'middle',\n            nameGap: 25,\n            min: 0,\n            max: 100,\n            axisLabel: { formatter: '{value}%', fontSize: 10 }\n        });\n\n        yAxes.push({\n            type: 'value',\n            gridIndex: 0,\n            name: config.yAxisLabel,\n            nameLocation: 'middle',\n            nameGap: 45,\n            min: config.yAxisMin,\n            max: config.yAxisMax,\n            axisLabel: { fontSize: 10 },\n            splitLine: { lineStyle: { type: 'dashed', opacity: 0.3 } }\n        });\n\n        yAxes.push({\n            type: 'value',\n            gridIndex: 1,\n            name: config.yAxisLabel,\n            nameLocation: 'middle',\n            nameGap: 45,\n            min: config.yAxisMin,\n            max: config.yAxisMax,\n            axisLabel: { fontSize: 10 },\n            splitLine: { lineStyle: { type: 'dashed', opacity: 0.3 } }\n        });\n\n        // Both charts use the same data source - use unified color and label\n        var seriesColor = config.seriesColor;\n\n        series.push({\n            name: config.label,\n            type: 'line',\n            xAxisIndex: 0,\n            yAxisIndex: 0,\n            data: config.loadProfileData,\n            smooth: false,\n            symbol: 'none',\n            lineStyle: { color: seriesColor, width: 1.5 },\n            areaStyle: { color: seriesColor, opacity: 0.1 },\n            markLine: buildLoadProfileMarkLines(config)\n        });\n\n        series.push({\n            name: config.label,\n            type: 'line',\n            xAxisIndex: 1,\n            yAxisIndex: 1,\n            data: config.durationData,\n            smooth: true,\n            symbol: 'none',\n            lineStyle: { color: seriesColor, width: 2 },\n            areaStyle: {\n                color: {\n                    type: 'linear',\n                    x: 0, y: 0, x2: 0, y2: 1,\n                    colorStops: [\n                        { offset: 0, color: seriesColor },\n                        { offset: 1, color: 'rgba(255,255,255,0.1)' }\n                    ]\n                }\n            },\n            markLine: buildDurationCurveMarkLines(config),\n            markArea: buildThresholdAreas(config)\n        });\n\n    } else if (config.showLoadProfile) {\n        grids = [{ left: 60, right: 20, top: 40, bottom: 45 }];\n        titles = [{\n            text: 'Load Profile - ' + config.label,\n            subtext: subtitle,\n            left: 'center',\n            textStyle: { fontSize: 14 },\n            subtextStyle: { fontSize: 10, color: '#999' }\n        }];\n\n        xAxes.push({\n            type: 'time',\n            axisLabel: { fontSize: 10 },\n            splitLine: { show: false }\n        });\n\n        yAxes.push({\n            type: 'value',\n            name: config.yAxisLabel,\n            nameLocation: 'middle',\n            nameGap: 45,\n            min: config.yAxisMin,\n            max: config.yAxisMax,\n            axisLabel: { fontSize: 10 },\n            splitLine: { lineStyle: { type: 'dashed', opacity: 0.3 } }\n        });\n\n        series.push({\n            name: config.label,\n            type: 'line',\n            data: config.loadProfileData,\n            smooth: false,\n            symbol: 'none',\n            lineStyle: { color: config.seriesColor, width: 1.5 },\n            areaStyle: { color: config.seriesColor, opacity: 0.1 },\n            markLine: buildLoadProfileMarkLines(config)\n        });\n\n    } else {\n        grids = [{ left: 60, right: 20, top: 40, bottom: 45 }];\n        titles = [{\n            text: 'Duration Curve - ' + config.label,\n            subtext: subtitle,\n            left: 'center',\n            textStyle: { fontSize: 13 },\n            subtextStyle: { fontSize: 9, color: '#999' }\n        }];\n\n        xAxes.push({\n            type: 'value',\n            name: '% of Time',\n            nameLocation: 'middle',\n            nameGap: 30,\n            min: 0,\n            max: 100,\n            axisLabel: { formatter: '{value}%' }\n        });\n\n        yAxes.push({\n            type: 'value',\n            name: config.yAxisLabel,\n            nameLocation: 'middle',\n            nameGap: 45,\n            min: config.yAxisMin,\n            max: config.yAxisMax,\n            axisLabel: { fontSize: 10 },\n            splitLine: { lineStyle: { type: 'dashed', opacity: 0.3 } }\n        });\n\n        series.push({\n            name: config.label,\n            type: 'line',\n            data: config.durationData,\n            smooth: true,\n            symbol: 'none',\n            lineStyle: { color: config.seriesColor, width: 2 },\n            areaStyle: {\n                color: {\n                    type: 'linear',\n                    x: 0, y: 0, x2: 0, y2: 1,\n                    colorStops: [\n                        { offset: 0, color: config.seriesColor },\n                        { offset: 1, color: 'rgba(255,255,255,0.1)' }\n                    ]\n                }\n            },\n            markLine: buildDurationCurveMarkLines(config),\n            markArea: buildThresholdAreas(config)\n        });\n    }\n\n    // Build legend - use DOM stats card when legendStyle='card', otherwise ECharts legend\n    var legendConfig = null;\n    var legendValues = config.legendValues || [];\n    var legendStyle = config.legendStyle || 'classic';\n    var useStatsCard = legendStyle === 'card' && legendValues.length > 0 && config.stats;\n\n    // Only show ECharts legend if showLegend is true AND using classic style\n    if (config.showLegend && !useStatsCard) {\n        var legendData = [config.label];\n        var position = config.legendPosition || 'bottom';\n        var decimals = config.decimals !== undefined ? config.decimals : 2;\n        var unit = config.units || '';\n\n        legendConfig = {\n            data: legendData,\n            textStyle: { fontSize: 11 }\n        };\n\n        // Add formatter with stats if legendValues are selected\n        if (legendValues.length > 0 && config.stats) {\n            legendConfig.formatter = function(name) {\n                var parts = [name];\n                legendValues.forEach(function(val) {\n                    var statValue, label;\n                    switch(val) {\n                        case 'min': statValue = config.stats.min; label = 'Min'; break;\n                        case 'max': statValue = config.stats.max; label = 'Max'; break;\n                        case 'avg': statValue = config.stats.mean; label = 'Avg'; break;\n                        case 'median': statValue = config.stats.median; label = 'Median'; break;\n                        case 'sum': statValue = config.stats.sum; label = 'Sum'; break;\n                        case 'count':\n                            parts.push('n=' + config.stats.count);\n                            return;\n                        default: return;\n                    }\n                    if (statValue !== undefined) {\n                        parts.push(label + ': ' + statValue.toFixed(decimals) + (unit ? ' ' + unit : ''));\n                    }\n                });\n                return parts.join('  |  ');\n            };\n        }\n\n        // Set position and orientation based on setting\n        switch (position) {\n            case 'top':\n                legendConfig.top = 5;\n                legendConfig.left = 'center';\n                legendConfig.orient = 'horizontal';\n                break;\n            case 'bottom':\n                legendConfig.bottom = 5;\n                legendConfig.left = 'center';\n                legendConfig.orient = 'horizontal';\n                break;\n            case 'left':\n                legendConfig.left = 5;\n                legendConfig.top = 'middle';\n                legendConfig.orient = 'vertical';\n                break;\n            case 'right':\n                legendConfig.right = 5;\n                legendConfig.top = 'middle';\n                legendConfig.orient = 'vertical';\n                break;\n            default:\n                legendConfig.bottom = 5;\n                legendConfig.left = 'center';\n                legendConfig.orient = 'horizontal';\n        }\n    }\n\n    // Adjust grid margins based on legend position (only for classic ECharts legend)\n    var legendMargin = (config.showLegend && !useStatsCard) ? 35 : 0;\n    var position = config.legendPosition || 'bottom';\n\n    // Recalculate grids with legend position consideration\n    if (showBoth) {\n        var topOffset = position === 'top' ? 40 + legendMargin : 40;\n        var bottomOffset = position === 'bottom' ? 45 + legendMargin : 45;\n        var leftOffset = position === 'left' ? 60 + legendMargin : 60;\n        var rightOffset = position === 'right' ? 20 + legendMargin : 20;\n\n        // Use bottom-based layout to prevent overlap\n        grids = [\n            { left: leftOffset, right: rightOffset, top: topOffset, bottom: '55%' },\n            { left: leftOffset, right: rightOffset, top: '55%', bottom: bottomOffset }\n        ];\n\n        // Adjust title positions\n        titles[0].top = topOffset - 38;\n        titles[1].top = '50%';\n    } else {\n        var topOffset = position === 'top' ? 40 + legendMargin : 40;\n        var bottomOffset = position === 'bottom' ? 45 + legendMargin : 45;\n        var leftOffset = position === 'left' ? 60 + legendMargin : 60;\n        var rightOffset = position === 'right' ? 20 + legendMargin : 20;\n\n        grids = [{ left: leftOffset, right: rightOffset, top: topOffset, bottom: bottomOffset }];\n    }\n\n    // Build toolbox\n    var toolboxConfig = null;\n    if (config.showToolbox) {\n        toolboxConfig = {\n            show: true,\n            right: 10,\n            top: 5,\n            feature: {}\n        };\n\n        if (config.showSaveAsImage) {\n            toolboxConfig.feature.saveAsImage = {\n                show: true,\n                title: 'Save as PNG',\n                pixelRatio: 2\n            };\n        }\n\n        if (config.showDataView) {\n            toolboxConfig.feature.dataView = {\n                show: true,\n                title: 'Data View',\n                readOnly: true,\n                lang: ['Data View', 'Close', 'Refresh'],\n                optionToContent: function(opt) {\n                    var series = opt.series || [];\n                    var unit = config.units || '';\n                    var dec = config.decimals !== undefined ? config.decimals : 2;\n                    var legendValues = config.legendValues || [];\n                    var stats = config.stats;\n                    var showLegend = config.showLegend && legendValues.length > 0 && stats;\n\n                    // Container with full height\n                    var html = '<div style=\"display: flex; flex-direction: column; height: 100%; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif;\">';\n\n                    // Statistics Card (if legend enabled)\n                    if (showLegend) {\n                        html += '<div style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; padding: 16px; margin: 12px; color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1);\">';\n                        html += '<div style=\"font-size: 14px; font-weight: 600; margin-bottom: 12px; opacity: 0.9;\">' + config.label + (unit ? ' (' + unit + ')' : '') + '</div>';\n                        html += '<div style=\"display: flex; flex-wrap: wrap; gap: 16px;\">';\n\n                        legendValues.forEach(function(val) {\n                            var statValue, label, icon;\n                            switch(val) {\n                                case 'min': statValue = stats.min; label = 'Min'; icon = '↓'; break;\n                                case 'max': statValue = stats.max; label = 'Max'; icon = '↑'; break;\n                                case 'avg': statValue = stats.mean; label = 'Avg'; icon = 'μ'; break;\n                                case 'median': statValue = stats.median; label = 'Median'; icon = '~'; break;\n                                case 'sum': statValue = stats.sum; label = 'Sum'; icon = 'Σ'; break;\n                                case 'count': statValue = stats.count; label = 'Count'; icon = 'n'; break;\n                                default: return;\n                            }\n                            if (statValue !== undefined) {\n                                var formattedVal = val === 'count' ? statValue : statValue.toFixed(dec);\n                                html += '<div style=\"background: rgba(255,255,255,0.15); border-radius: 6px; padding: 8px 12px; min-width: 80px;\">';\n                                html += '<div style=\"font-size: 11px; opacity: 0.8; margin-bottom: 2px;\">' + icon + ' ' + label + '</div>';\n                                html += '<div style=\"font-size: 16px; font-weight: 600;\">' + formattedVal + '</div>';\n                                html += '</div>';\n                            }\n                        });\n\n                        html += '</div></div>';\n                    }\n\n                    // Data tables container\n                    html += '<div style=\"flex: 1; overflow: hidden; display: flex; flex-direction: column; padding: 0 12px 12px 12px;\">';\n\n                    for (var i = 0; i < series.length; i++) {\n                        var s = series[i];\n                        var data = s.data || [];\n                        if (data.length === 0) continue;\n\n                        // Check if first value is timestamp (> year 2000 in ms)\n                        var isTimeSeries = data[0] && data[0][0] > 946684800000;\n                        var tableTitle = isTimeSeries ? 'Load Profile' : 'Duration Curve';\n\n                        html += '<div style=\"font-size: 13px; font-weight: 600; color: #374151; margin: 8px 0 6px 0;\">' + tableTitle + ' <span style=\"font-weight: 400; color: #6b7280;\">(' + data.length + ' points)</span></div>';\n\n                        // Table wrapper with scroll\n                        html += '<div style=\"flex: 1; overflow: auto; border: 1px solid #e5e7eb; border-radius: 6px; min-height: 150px;\">';\n                        html += '<table style=\"width: 100%; border-collapse: collapse; font-size: 12px;\">';\n\n                        // Fixed header\n                        html += '<thead style=\"position: sticky; top: 0; z-index: 1;\">';\n                        html += '<tr style=\"background: #f9fafb;\">';\n                        if (isTimeSeries) {\n                            html += '<th style=\"border-bottom: 2px solid #e5e7eb; padding: 8px 12px; text-align: left; font-weight: 600; color: #374151; white-space: nowrap;\">Timestamp</th>';\n                        } else {\n                            html += '<th style=\"border-bottom: 2px solid #e5e7eb; padding: 8px 12px; text-align: center; font-weight: 600; color: #374151; width: 80px;\">%</th>';\n                        }\n                        html += '<th style=\"border-bottom: 2px solid #e5e7eb; padding: 8px 12px; text-align: right; font-weight: 600; color: #374151;\">' + (unit || 'Value') + '</th>';\n                        html += '</tr></thead>';\n\n                        html += '<tbody>';\n                        for (var j = 0; j < data.length; j++) {\n                            var row = data[j];\n                            var xVal = row[0];\n                            var yVal = row[1];\n                            var rowBg = j % 2 === 0 ? '#ffffff' : '#f9fafb';\n\n                            html += '<tr style=\"background: ' + rowBg + ';\">';\n                            if (isTimeSeries) {\n                                var d = new Date(xVal);\n                                var ts = d.getFullYear() + '-' +\n                                    String(d.getMonth() + 1).padStart(2, '0') + '-' +\n                                    String(d.getDate()).padStart(2, '0') + ' ' +\n                                    String(d.getHours()).padStart(2, '0') + ':' +\n                                    String(d.getMinutes()).padStart(2, '0') + ':' +\n                                    String(d.getSeconds()).padStart(2, '0');\n                                html += '<td style=\"padding: 6px 12px; color: #6b7280; font-family: monospace; font-size: 11px; white-space: nowrap;\">' + ts + '</td>';\n                            } else {\n                                html += '<td style=\"padding: 6px 12px; text-align: center; color: #6b7280;\">' + xVal.toFixed(1) + '</td>';\n                            }\n                            html += '<td style=\"padding: 6px 12px; text-align: right; font-weight: 500; color: #111827;\">' + yVal.toFixed(dec) + '</td>';\n                            html += '</tr>';\n                        }\n                        html += '</tbody></table></div>';\n                    }\n\n                    html += '</div></div>';\n                    return html;\n                }\n            };\n        }\n\n        if (config.showDataZoom) {\n            toolboxConfig.feature.dataZoom = {\n                show: true,\n                title: { zoom: 'Zoom', back: 'Reset Zoom' }\n            };\n        }\n\n        if (config.showRestore) {\n            toolboxConfig.feature.restore = {\n                show: true,\n                title: 'Restore'\n            };\n        }\n    }\n\n    return {\n        title: titles,\n        toolbox: toolboxConfig,\n        tooltip: config.showTooltip ? {\n            trigger: 'axis',\n            formatter: function(params) {\n                if (!params || !params.length) return '';\n                var p = params[0];\n                var dec = config.decimals !== undefined ? config.decimals : 2;\n                // Check if this is a time-based axis (Load Profile) or value axis (Duration Curve)\n                var isTimeAxis = p.axisType === 'xAxis.time' || (typeof p.value[0] === 'number' && p.value[0] > 1000000000000);\n                if (isTimeAxis) {\n                    var d = new Date(p.value[0]);\n                    return d.toLocaleString() + '<br/>' +\n                           p.seriesName + ': ' + formatValueWithDecimals(p.value[1], dec) + ' ' + config.units;\n                } else {\n                    return p.value[0].toFixed(1) + '% of time<br/>' +\n                           p.seriesName + ': ' + formatValueWithDecimals(p.value[1], dec) + ' ' + config.units;\n                }\n            }\n        } : null,\n        legend: legendConfig,\n        grid: grids,\n        xAxis: xAxes,\n        yAxis: yAxes,\n        dataZoom: config.enableMouseZoom ? [\n            { type: 'inside', xAxisIndex: showBoth ? [0, 1] : [0] }\n        ] : [],\n        series: series\n    };\n}\n\nfunction buildLoadProfileMarkLines(config) {\n    var markLineData = [];\n\n    if (config.showMean && config.meanValue !== undefined) {\n        markLineData.push({\n            yAxis: config.meanValue,\n            lineStyle: { color: config.meanColor, type: 'dashed', width: 2 },\n            label: {\n                formatter: 'Mean: ' + formatValue(config.meanValue),\n                position: 'insideEndTop',\n                color: config.meanColor\n            }\n        });\n    }\n\n    if (config.showMedian && config.medianValue !== undefined) {\n        markLineData.push({\n            yAxis: config.medianValue,\n            lineStyle: { color: config.medianColor, type: 'dotted', width: 2 },\n            label: {\n                formatter: 'Median: ' + formatValue(config.medianValue),\n                position: 'insideEndBottom',\n                color: config.medianColor\n            }\n        });\n    }\n\n    // Also show baseload/peakload in Load Profile\n    if (config.showThresholds && config.baseLoadValue !== undefined && config.baseLoadValue !== null) {\n        markLineData.push({\n            yAxis: config.baseLoadValue,\n            lineStyle: { color: config.baseLoadColor, type: 'dashed', width: 2 },\n            label: {\n                formatter: 'Base: ' + formatValue(config.baseLoadValue),\n                position: 'insideStartTop',\n                color: config.baseLoadColor\n            }\n        });\n    }\n\n    if (config.showThresholds && config.peakLoadValue !== undefined && config.peakLoadValue !== null) {\n        markLineData.push({\n            yAxis: config.peakLoadValue,\n            lineStyle: { color: config.peakLoadColor, type: 'dashed', width: 2 },\n            label: {\n                formatter: 'Peak: ' + formatValue(config.peakLoadValue),\n                position: 'insideStartBottom',\n                color: config.peakLoadColor\n            }\n        });\n    }\n\n    if (markLineData.length === 0) return null;\n\n    return {\n        silent: true,\n        data: markLineData\n    };\n}\n\nfunction buildDurationCurveMarkLines(config) {\n    var markLineData = [];\n\n    // Show mean/median lines in Duration Curve too\n    if (config.showMean && config.meanValue !== undefined) {\n        markLineData.push({\n            yAxis: config.meanValue,\n            lineStyle: { color: config.meanColor, type: 'dashed', width: 2 },\n            label: {\n                formatter: 'Mean: ' + formatValue(config.meanValue),\n                position: 'insideEndTop',\n                color: config.meanColor\n            }\n        });\n    }\n\n    if (config.showMedian && config.medianValue !== undefined) {\n        markLineData.push({\n            yAxis: config.medianValue,\n            lineStyle: { color: config.medianColor, type: 'dotted', width: 2 },\n            label: {\n                formatter: 'Median: ' + formatValue(config.medianValue),\n                position: 'insideEndBottom',\n                color: config.medianColor\n            }\n        });\n    }\n\n    // Show baseload/peakload lines\n    if (config.showThresholds && config.baseLoadValue !== undefined && config.baseLoadValue !== null) {\n        markLineData.push({\n            yAxis: config.baseLoadValue,\n            lineStyle: { color: config.baseLoadColor, type: 'dashed', width: 2 },\n            label: {\n                formatter: 'Base: ' + formatValue(config.baseLoadValue),\n                position: 'insideStartTop',\n                color: config.baseLoadColor\n            }\n        });\n    }\n\n    if (config.showThresholds && config.peakLoadValue !== undefined && config.peakLoadValue !== null) {\n        markLineData.push({\n            yAxis: config.peakLoadValue,\n            lineStyle: { color: config.peakLoadColor, type: 'dashed', width: 2 },\n            label: {\n                formatter: 'Peak: ' + formatValue(config.peakLoadValue),\n                position: 'insideStartBottom',\n                color: config.peakLoadColor\n            }\n        });\n    }\n\n    if (markLineData.length === 0) return null;\n\n    return {\n        silent: true,\n        data: markLineData\n    };\n}\n\nfunction buildThresholdAreas(config) {\n    if (!config.showThresholds) return null;\n\n    var areaData = [];\n\n    if (config.baseLoadValue !== undefined && config.baseLoadValue !== null) {\n        areaData.push([\n            { yAxis: 0, itemStyle: { color: config.baseLoadColor, opacity: 0.05 } },\n            { yAxis: config.baseLoadValue }\n        ]);\n    }\n\n    if (config.peakLoadValue !== undefined && config.peakLoadValue !== null) {\n        areaData.push([\n            { yAxis: config.peakLoadValue, itemStyle: { color: config.peakLoadColor, opacity: 0.05 } },\n            { yAxis: 'max' }\n        ]);\n    }\n\n    if (areaData.length === 0) return null;\n\n    return {\n        silent: true,\n        data: areaData\n    };\n}\n\nfunction formatValue(value) {\n    if (value === null || value === undefined) return '-';\n    if (Math.abs(value) >= 1000) {\n        return value.toFixed(0);\n    } else if (Math.abs(value) >= 100) {\n        return value.toFixed(1);\n    } else {\n        return value.toFixed(2);\n    }\n}\n\nfunction formatValueWithDecimals(value, decimals) {\n    if (value === null || value === undefined) return '-';\n    if (decimals === undefined || decimals === null) {\n        return formatValue(value);\n    }\n    return value.toFixed(decimals);\n}\n\nfunction formatTimestamp(ts, format) {\n    var d = new Date(ts);\n    var year = d.getFullYear();\n    var month = String(d.getMonth() + 1).padStart(2, '0');\n    var day = String(d.getDate()).padStart(2, '0');\n    var hours = String(d.getHours()).padStart(2, '0');\n    var minutes = String(d.getMinutes()).padStart(2, '0');\n    var seconds = String(d.getSeconds()).padStart(2, '0');\n\n    // Simple format replacement\n    var result = format\n        .replace('YYYY', year)\n        .replace('MM', month)\n        .replace('DD', day)\n        .replace('HH', hours)\n        .replace('mm', minutes)\n        .replace('ss', seconds);\n\n    return result;\n}\n\nself.onResize = function() {\n    if (chart && chartContainer) {\n        // Use explicit dimensions for reliable resize\n        chart.resize({\n            width: chartContainer.offsetWidth,\n            height: chartContainer.offsetHeight\n        });\n    }\n};\n\nself.onDestroy = function() {\n    if (resizeObserver) {\n        resizeObserver.disconnect();\n        resizeObserver = null;\n    }\n    if (chart) {\n        chart.dispose();\n        chart = null;\n    }\n};\n\nself.typeParameters = function() {\n    return {\n        previewWidth: '100%',\n        embedTitlePanel: false,\n        hasDataExportAction: true,\n        hasAdditionalLatestDataKeys: true,\n        singleEntity: false,\n        dataKeySettingsFunction: function() { return {}; },\n        defaultDataKeysFunction: function() {\n            return [{\n                name: 'power',\n                label: 'Power',\n                type: 'timeseries',\n                units: 'kW',\n                decimals: 2\n            }];\n        },\n        defaultLatestDataKeysFunction: function() { return []; }\n    };\n};",
    "settingsSchema": {
      "schema": {
        "type": "object",
        "title": "Duration Curve Settings",
        "properties": {
          "showDurationCurve": {
            "title": "Show Duration Curve",
            "type": "boolean",
            "default": true
          },
          "showLoadProfile": {
            "title": "Show Load Profile",
            "type": "boolean",
            "default": false
          },
          "showLegend": {
            "title": "Show Legend",
            "type": "boolean",
            "default": true
          },
          "legendPosition": {
            "title": "Legend Position",
            "type": "string",
            "default": "bottom",
            "enum": [
              "top",
              "bottom",
              "left",
              "right"
            ]
          },
          "showTooltip": {
            "title": "Show Tooltip",
            "type": "boolean",
            "default": true
          },
          "legendStyle": {
            "title": "Legend Style",
            "type": "string",
            "default": "classic",
            "enum": [
              "classic",
              "card"
            ]
          },
          "legendAlign": {
            "title": "Legend Alignment",
            "type": "string",
            "default": "center",
            "enum": [
              "left",
              "center",
              "right"
            ]
          },
          "legendCardColorMode": {
            "title": "Card Color Mode",
            "type": "string",
            "default": "auto",
            "enum": [
              "auto",
              "manual",
              "gradient"
            ]
          },
          "legendCardColor": {
            "title": "Card Color",
            "type": "string",
            "default": "#2196F3"
          },
          "legendValues": {
            "title": "Legend Values",
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "current",
                "min",
                "max",
                "avg",
                "mean",
                "median",
                "sum",
                "count",
                "baseload",
                "peak"
              ]
            },
            "default": [
              "current"
            ]
          },
          "dataType": {
            "title": "Data Type",
            "type": "string",
            "default": "power",
            "enum": [
              "power",
              "energy"
            ]
          },
          "energyToPower": {
            "title": "Convert Energy to Power (kWh to kW)",
            "type": "boolean",
            "default": false
          },
          "removeOutliers": {
            "title": "Remove Outliers",
            "type": "boolean",
            "default": false
          },
          "outlierMethod": {
            "title": "Outlier Method",
            "type": "string",
            "default": "iqr",
            "enum": [
              "iqr",
              "zscore",
              "manual"
            ]
          },
          "outlierIqrMultiplier": {
            "title": "IQR Multiplier",
            "type": "number",
            "default": 1.5
          },
          "outlierZscoreThreshold": {
            "title": "Z-Score Threshold",
            "type": "number",
            "default": 3
          },
          "outlierMinValue": {
            "title": "Minimum Value (manual)",
            "type": "number"
          },
          "outlierMaxValue": {
            "title": "Maximum Value (manual)",
            "type": "number"
          },
          "smoothingEnabled": {
            "title": "Enable Smoothing",
            "type": "boolean",
            "default": false
          },
          "smoothingWindow": {
            "title": "Smoothing Window (Minutes)",
            "type": "integer",
            "default": 5,
            "minimum": 3,
            "maximum": 50
          },
          "showThresholds": {
            "title": "Show Thresholds",
            "type": "boolean",
            "default": false
          },
          "autoDetectThresholds": {
            "title": "Auto-detect Thresholds",
            "type": "boolean",
            "default": true
          },
          "baseLoadPercentile": {
            "title": "Base Load Percentile",
            "type": "integer",
            "default": 10,
            "minimum": 1,
            "maximum": 50
          },
          "peakLoadPercentile": {
            "title": "Peak Load Percentile",
            "type": "integer",
            "default": 90,
            "minimum": 50,
            "maximum": 99
          },
          "manualBaseLoad": {
            "title": "Manual Base Load",
            "type": "number"
          },
          "manualPeakLoad": {
            "title": "Manual Peak Load",
            "type": "number"
          },
          "baseLoadColor": {
            "title": "Base Load Color",
            "type": "string",
            "default": "#4CAF50"
          },
          "peakLoadColor": {
            "title": "Peak Load Color",
            "type": "string",
            "default": "#F44336"
          },
          "showMean": {
            "title": "Show Mean Line",
            "type": "boolean",
            "default": false
          },
          "showMedian": {
            "title": "Show Median Line",
            "type": "boolean",
            "default": false
          },
          "meanColor": {
            "title": "Mean Color",
            "type": "string",
            "default": "#FF9800"
          },
          "medianColor": {
            "title": "Median Color",
            "type": "string",
            "default": "#9C27B0"
          },
          "showDataZoomSlider": {
            "title": "Show Zoom Slider",
            "type": "boolean",
            "default": true
          },
          "yAxisLabel": {
            "title": "Y-Axis Label",
            "type": "string",
            "default": ""
          },
          "yAxisMin": {
            "title": "Y-Axis Minimum",
            "type": "number"
          },
          "yAxisMax": {
            "title": "Y-Axis Maximum",
            "type": "number"
          },
          "showToolbox": {
            "title": "Show Toolbox",
            "type": "boolean",
            "default": true
          },
          "toolboxFeatures": {
            "title": "Toolbox Features",
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "saveAsImage",
                "dataView",
                "dataZoom",
                "restore"
              ]
            },
            "default": [
              "saveAsImage",
              "dataView",
              "dataZoom",
              "restore"
            ]
          },
          "showTimestamp": {
            "title": "Show Timestamp",
            "type": "boolean",
            "default": true
          },
          "timestampFormat": {
            "title": "Timestamp Format",
            "type": "string",
            "default": "YYYY-MM-DD HH:mm:ss"
          },
          "showTimewindowSelector": {
            "title": "Show Timewindow Selector",
            "type": "boolean",
            "default": false
          },
          "twSelectorColor": {
            "title": "Selector Color",
            "type": "string",
            "default": ""
          },
          "twSelectorPosition": {
            "title": "Selector Position",
            "type": "string",
            "default": "center",
            "enum": [
              "left",
              "center",
              "right"
            ]
          },
          "twSelectorDayFormat": {
            "title": "Day Format",
            "type": "string",
            "default": "D MMM YYYY"
          },
          "twSelectorWeekFormat": {
            "title": "Week Format",
            "type": "string",
            "default": "D-D MMM"
          },
          "twSelectorMonthFormat": {
            "title": "Month Format",
            "type": "string",
            "default": "MMM YYYY"
          },
          "twCustomStartTime": {
            "title": "Custom Start Time",
            "type": "string",
            "default": ""
          },
          "twCustomEndTime": {
            "title": "Custom End Time",
            "type": "string",
            "default": ""
          },
          "twAggregationType": {
            "title": "Aggregation",
            "type": "string",
            "default": "NONE",
            "enum": [
              "NONE",
              "AVG",
              "MIN",
              "MAX",
              "SUM",
              "COUNT"
            ]
          },
          "twMaxDataPoints": {
            "title": "Max Data Points",
            "type": "number",
            "default": 100000
          },
          "baseloadMethod": {
            "title": "Baseload Calculation Method",
            "type": "string",
            "default": "percentile",
            "enum": [
              "minimum",
              "percentile",
              "rollingMin",
              "integral"
            ]
          },
          "baseloadPercentile": {
            "title": "Baseload Percentile",
            "type": "number",
            "default": 10,
            "minimum": 1,
            "maximum": 50
          },
          "peakloadMethod": {
            "title": "Peakload Calculation Method",
            "type": "string",
            "default": "percentile",
            "enum": [
              "percentile",
              "integral",
              "percentage",
              "absolute"
            ]
          },
          "peakloadPercentile": {
            "title": "Peakload Percentile",
            "type": "number",
            "default": 95,
            "minimum": 50,
            "maximum": 99
          },
          "peakloadSigma": {
            "title": "Peak Sigma (μ + n×σ)",
            "type": "number",
            "default": 2,
            "minimum": 1,
            "maximum": 4
          },
          "showMeanLine": {
            "title": "Show Mean Line",
            "type": "boolean",
            "default": false
          },
          "showMedianLine": {
            "title": "Show Median Line",
            "type": "boolean",
            "default": false
          },
          "showBaseloadLine": {
            "title": "Show Baseload Line",
            "type": "boolean",
            "default": false
          },
          "showPeakloadLine": {
            "title": "Show Peakload Line",
            "type": "boolean",
            "default": false
          },
          "meanLineColor": {
            "title": "Mean Line Color",
            "type": "string",
            "default": "#FF9800"
          },
          "medianLineColor": {
            "title": "Median Line Color",
            "type": "string",
            "default": "#9C27B0"
          },
          "baseloadLineColor": {
            "title": "Baseload Line Color",
            "type": "string",
            "default": "#4CAF50"
          },
          "peakloadLineColor": {
            "title": "Peakload Line Color",
            "type": "string",
            "default": "#F44336"
          },
          "enableMouseZoom": {
            "title": "Enable Mouse Zoom",
            "type": "boolean",
            "default": false
          },
          "twSelectorDefaultMode": {
            "title": "Default Mode",
            "type": "string",
            "default": "custom",
            "enum": [
              "day",
              "week",
              "month",
              "custom"
            ]
          }
        },
        "required": []
      },
      "form": [
        [
          "showDurationCurve",
          "showLoadProfile",
          {
            "key": "dataType",
            "type": "rc-select",
            "multiple": false,
            "items": [
              {
                "value": "power",
                "label": "Power (kW)"
              },
              {
                "value": "energy",
                "label": "Energy (kWh)"
              }
            ]
          },
          {
            "key": "energyToPower",
            "condition": "model.dataType === 'energy'"
          },
          "showDataZoomSlider",
          "enableMouseZoom"
        ],
        [
          "showLegend",
          {
            "key": "legendStyle",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true",
            "items": [
              {
                "value": "classic",
                "label": "Classic (Text)"
              },
              {
                "value": "card",
                "label": "Statistics Card"
              }
            ]
          },
          {
            "key": "legendPosition",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true",
            "items": [
              {
                "value": "top",
                "label": "Top"
              },
              {
                "value": "bottom",
                "label": "Bottom"
              },
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "legendAlign",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "center",
                "label": "Center"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "legendCardColorMode",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "auto",
                "label": "Auto (Series Color)"
              },
              {
                "value": "manual",
                "label": "Manual Color"
              },
              {
                "value": "gradient",
                "label": "Gradient"
              }
            ]
          },
          {
            "key": "legendCardColor",
            "type": "color",
            "condition": "model.showLegend === true && model.legendStyle === 'card' && model.legendCardColorMode === 'manual'"
          },
          {
            "key": "legendValues",
            "type": "rc-select",
            "multiple": true,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "current",
                "label": "Current Value"
              },
              {
                "value": "min",
                "label": "Minimum"
              },
              {
                "value": "max",
                "label": "Maximum"
              },
              {
                "value": "mean",
                "label": "Mean"
              },
              {
                "value": "median",
                "label": "Median"
              },
              {
                "value": "sum",
                "label": "Sum"
              },
              {
                "value": "count",
                "label": "Count"
              },
              {
                "value": "baseload",
                "label": "Baseload (energy analysis)"
              },
              {
                "value": "peak",
                "label": "Peakload (energy analysis)"
              }
            ]
          },
          {
            "key": "showTimestamp",
            "condition": "model.showLegend === true && model.legendStyle === 'card'"
          },
          {
            "key": "timestampFormat",
            "condition": "model.showLegend === true && model.legendStyle === 'card' && model.showTimestamp === true"
          },
          "showTooltip"
        ],
        [
          "yAxisLabel",
          "yAxisMin",
          "yAxisMax"
        ],
        [
          "removeOutliers",
          {
            "key": "outlierMethod",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.removeOutliers === true",
            "items": [
              {
                "value": "iqr",
                "label": "IQR (Interquartile Range)"
              },
              {
                "value": "zscore",
                "label": "Z-Score"
              },
              {
                "value": "manual",
                "label": "Manual Thresholds"
              }
            ]
          },
          {
            "key": "outlierIqrMultiplier",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'iqr'"
          },
          {
            "key": "outlierZscoreThreshold",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'zscore'"
          },
          {
            "key": "outlierMinValue",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'manual'"
          },
          {
            "key": "outlierMaxValue",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'manual'"
          },
          "smoothingEnabled",
          {
            "key": "smoothingWindow",
            "condition": "model.smoothingEnabled === true"
          }
        ],
        [
          "showToolbox",
          {
            "key": "toolboxFeatures",
            "type": "rc-select",
            "multiple": true,
            "condition": "model.showToolbox === true",
            "items": [
              {
                "value": "saveAsImage",
                "label": "Save as Image"
              },
              {
                "value": "dataView",
                "label": "Data View"
              },
              {
                "value": "dataZoom",
                "label": "Data Zoom"
              },
              {
                "value": "restore",
                "label": "Restore"
              }
            ]
          }
        ],
        [
          "showTimewindowSelector",
          {
            "key": "twSelectorDefaultMode",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "day",
                "label": "Day"
              },
              {
                "value": "week",
                "label": "Week"
              },
              {
                "value": "month",
                "label": "Month"
              },
              {
                "value": "custom",
                "label": "Custom (Date Range)"
              }
            ]
          },
          {
            "key": "twSelectorColor",
            "type": "color",
            "condition": "model.showTimewindowSelector === true",
            "description": "Leave empty for auto (uses series color)"
          },
          {
            "key": "twSelectorPosition",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "center",
                "label": "Center"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "twSelectorDayFormat",
            "condition": "model.showTimewindowSelector === true",
            "description": "Format: D=day, DD=day(2), MMM=month, YYYY=year"
          },
          {
            "key": "twSelectorWeekFormat",
            "condition": "model.showTimewindowSelector === true"
          },
          {
            "key": "twSelectorMonthFormat",
            "condition": "model.showTimewindowSelector === true"
          },
          {
            "key": "twCustomStartTime",
            "condition": "model.showTimewindowSelector === true",
            "description": "Use ${attributeName} for entity attributes"
          },
          {
            "key": "twCustomEndTime",
            "condition": "model.showTimewindowSelector === true",
            "description": "Use ${attributeName} for entity attributes"
          },
          {
            "key": "twAggregationType",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "NONE",
                "label": "None (Raw Data)"
              },
              {
                "value": "AVG",
                "label": "Average"
              },
              {
                "value": "MIN",
                "label": "Minimum"
              },
              {
                "value": "MAX",
                "label": "Maximum"
              },
              {
                "value": "SUM",
                "label": "Sum"
              },
              {
                "value": "COUNT",
                "label": "Count"
              }
            ]
          },
          {
            "key": "twMaxDataPoints",
            "condition": "model.showTimewindowSelector === true",
            "description": "Maximum number of data points to fetch (default: 100000)"
          }
        ],
        [
          "showMeanLine",
          {
            "key": "meanLineColor",
            "type": "color",
            "condition": "model.showMeanLine === true"
          },
          "showMedianLine",
          {
            "key": "medianLineColor",
            "type": "color",
            "condition": "model.showMedianLine === true"
          },
          "showBaseloadLine",
          {
            "key": "baseloadMethod",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showBaseloadLine === true",
            "items": [
              {
                "value": "minimum",
                "label": "Minimum (absolute lowest value)"
              },
              {
                "value": "percentile",
                "label": "Percentile (recommended: 10th)"
              },
              {
                "value": "rollingMin",
                "label": "Rolling Min (average of daily minimums)"
              },
              {
                "value": "integral",
                "label": "Integral (5th percentile floor)"
              }
            ]
          },
          {
            "key": "baseloadPercentile",
            "condition": "model.showBaseloadLine === true && model.baseloadMethod === 'percentile'",
            "description": "Percentile for baseload (10 = value exceeded 90% of time)"
          },
          {
            "key": "baseloadLineColor",
            "type": "color",
            "condition": "model.showBaseloadLine === true"
          },
          "showPeakloadLine",
          {
            "key": "peakloadMethod",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showPeakloadLine === true",
            "items": [
              {
                "value": "percentile",
                "label": "Percentile (recommended: 95th)"
              },
              {
                "value": "integral",
                "label": "Integral (μ + n×σ)"
              },
              {
                "value": "percentage",
                "label": "Percentage above mean"
              },
              {
                "value": "absolute",
                "label": "Absolute value threshold"
              }
            ]
          },
          {
            "key": "peakloadPercentile",
            "condition": "model.showPeakloadLine === true && model.peakloadMethod === 'percentile'",
            "description": "Percentile for peak threshold (95 = top 5% of values)"
          },
          {
            "key": "peakloadSigma",
            "condition": "model.showPeakloadLine === true && model.peakloadMethod === 'integral'",
            "description": "Peak = Mean + (Sigma × StdDev). Default 2 = ~95% coverage"
          },
          {
            "key": "peakloadLineColor",
            "type": "color",
            "condition": "model.showPeakloadLine === true"
          }
        ]
      ],
      "groupInfoes": [
        {
          "formIndex": 0,
          "GroupTitle": "Chart Settings"
        },
        {
          "formIndex": 1,
          "GroupTitle": "Legend Settings"
        },
        {
          "formIndex": 2,
          "GroupTitle": "Y-Axis Settings"
        },
        {
          "formIndex": 3,
          "GroupTitle": "Data Processing"
        },
        {
          "formIndex": 4,
          "GroupTitle": "Toolbox Settings"
        },
        {
          "formIndex": 5,
          "GroupTitle": "Timewindow Selector"
        },
        {
          "formIndex": 6,
          "GroupTitle": "Energy Analysis"
        }
      ]
    },
    "dataKeySettingsSchema": {},
    "latestDataKeySettingsSchema": {},
    "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Power\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.123,\"funcBody\":\"var baseValue = 50;\\nvar variation = Math.sin(time / 3600000) * 20;\\nvar noise = Math.random() * 10 - 5;\\nvar spike = Math.random() > 0.95 ? 30 : 0;\\nreturn Math.max(0, baseValue + variation + noise + spike);\",\"units\":\"kW\",\"decimals\":2}]}],\"timewindow\":{\"hideInterval\":false,\"hideLastInterval\":false,\"hideQuickInterval\":false,\"hideAggregation\":false,\"hideAggInterval\":false,\"hideTimezone\":false,\"selectedTab\":0,\"realtime\":{\"realtimeType\":0,\"timewindowMs\":86400000,\"quickInterval\":\"CURRENT_DAY\",\"interval\":60000},\"aggregation\":{\"type\":\"AVG\",\"limit\":25000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"showDurationCurve\":true,\"showLoadProfile\":false,\"showThresholds\":false,\"showLegend\":true,\"showTooltip\":true,\"enablePngExport\":true,\"enableDataViewer\":true,\"showDataZoomSlider\":true},\"title\":\"Duration Curve\",\"dropShadow\":true,\"enableFullscreen\":true,\"enableDataExport\":true,\"useDashboardTimewindow\":true,\"displayTimewindow\":true,\"hasAdditionalLatestDataKeys\":true}"
  },
  "externalId": {
    "entityType": "WIDGET_TYPE",
    "id": "fc279310-f866-11f0-9979-9f3434877bb4"
  },
  "resources": null,
  "id": {
    "entityType": "WIDGET_TYPE",
    "id": "fc279310-f866-11f0-9979-9f3434877bb4"
  },
  "createdTime": 1769178164929,
  "tenantId": {
    "entityType": "TENANT",
    "id": "efb63c10-b576-11ee-a6c2-a149ed03c64d"
  },
  "scada": false,
  "version": 180,
  "tags": [
    "chart",
    "timeseries",
    "duration curve",
    "load profile",
    "power",
    "energy",
    "threshold",
    "echarts",
    "outlier"
  ]
}