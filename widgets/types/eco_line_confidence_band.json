{
  "fqn": "eco_custom_widgets.eco_line_confidence_band",
  "name": "Line with Confidence Band",
  "deprecated": false,
  "image": "tb-image;/api/images/system/chart.svg",
  "description": "Time series line chart with confidence band (upper/lower bounds). Perfect for displaying forecasts, uncertainty ranges, or statistical confidence intervals.",
  "descriptor": {
    "type": "timeseries",
    "sizeX": 10,
    "sizeY": 6,
    "resources": [
      {
        "url": "https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"
      }
    ],
    "templateHtml": "<div id=\"chart-container\" style=\"width: 100%; height: 100%;\"></div>",
    "templateCss": "#chart-container { position: relative; }",
    "controllerScript": "var chart = null;\n// Timewindow selector state\nvar twState = {\n    mode: 'day',  // 'day', 'week', 'month', 'custom'\n    currentDate: new Date()  // Reference date for navigation\n};\n\n// Cached settings for timewindow selector\nvar twSettings = {};\nvar timewindowSelectorContainer = null;\n\nvar chartContainer = null;\nvar zoomDebounceTimer = null;\nvar isExternalUpdate = false;\n\nself.onInit = function() {\n    chartContainer = self.ctx.$container.find('#chart-container')[0];\n    if (!chartContainer) {\n        console.error('Chart container not found');\n        return;\n    }\n    \n    if (typeof echarts === 'undefined') {\n        console.error('ECharts not loaded');\n        return;\n    }\n    \n    chart = echarts.init(chartContainer);\n    \n    var settings = self.ctx.settings || {};\n    // Timewindow selector settings\n    var showTimewindowSelector = settings.showTimewindowSelector === true;\n\n    // Cache timewindow selector settings for use in render function\n    twSettings = {\n        color: settings.twSelectorColor || '',\n        position: settings.twSelectorPosition || 'center',\n        dayFormat: settings.twSelectorDayFormat || 'D MMM YYYY',\n        weekFormat: settings.twSelectorWeekFormat || 'D-D MMM',\n        monthFormat: settings.twSelectorMonthFormat || 'MMM YYYY',\n        customStartTime: settings.twCustomStartTime || '',\n        customEndTime: settings.twCustomEndTime || '',\n        aggregationType: settings.twAggregationType || 'NONE',\n        maxDataPoints: settings.twMaxDataPoints || 100000\n    };\n\n    // Render timewindow selector if enabled\n    if (showTimewindowSelector && self.ctx.dashboard) {\n        renderTimewindowSelector();\n    } else if (timewindowSelectorContainer) {\n        timewindowSelectorContainer.style.display = 'none';\n    }\n\n    if (settings.enableZoomSync !== false) {\n        chart.on('datazoom', handleZoomSync);\n    }\n    \n    if (settings.enableExport !== false) {\n        chart.on('contextmenu', function(e) {\n            e.event.preventDefault();\n        });\n    }\n    \n    updateChart();\n};\n\nfunction handleZoomSync(params) {\n    if (isExternalUpdate) return;\n    \n    var settings = self.ctx.settings || {};\n    if (settings.enableZoomSync === false) return;\n    \n    var debounceMs = settings.zoomSyncDebounce || 150;\n    \n    if (zoomDebounceTimer) {\n        clearTimeout(zoomDebounceTimer);\n    }\n    \n    zoomDebounceTimer = setTimeout(function() {\n        var option = chart.getOption();\n        var dataZoom = option.dataZoom && option.dataZoom[0];\n        if (!dataZoom) return;\n        \n        var timeWindow = self.ctx.timeWindow;\n        if (!timeWindow) return;\n        \n        var totalRange = timeWindow.maxTime - timeWindow.minTime;\n        var startPercent = dataZoom.start || 0;\n        var endPercent = dataZoom.end || 100;\n        \n        if (startPercent > 0.5 || endPercent < 99.5) {\n            var startTime = Math.round(timeWindow.minTime + (totalRange * startPercent / 100));\n            var endTime = Math.round(timeWindow.minTime + (totalRange * endPercent / 100));\n            \n            if (self.ctx.dashboard && self.ctx.dashboard.onUpdateTimewindow) {\n                self.ctx.dashboard.onUpdateTimewindow(startTime, endTime);\n            }\n        }\n    }, debounceMs);\n}\n\nself.onDataUpdated = function() {\n    isExternalUpdate = true;\n    updateChart();\n    setTimeout(function() { isExternalUpdate = false; }, 100);\n};\n\nfunction updateChart() {\n    if (!chart) return;\n    \n    var settings = self.ctx.settings || {};\n    var lineColor = settings.lineColor || '#2196F3';\n    var bandColor = settings.bandColor || '#2196F3';\n    var bandOpacity = settings.bandOpacity !== undefined ? settings.bandOpacity : 0.2;\n    var smoothLine = settings.smoothLine !== false;\n    var showDataZoomSlider = settings.showDataZoomSlider !== false;\n    var showLegend = settings.showLegend !== false;\n    var showTooltip = settings.showTooltip !== false;\n    var enableExport = settings.enableExport !== false;\n    \n    var data = self.ctx.data || [];\n    if (!data.length) {\n        chart.setOption({\n            title: { text: 'No data', left: 'center', top: 'middle' }\n        });\n        return;\n    }\n    \n    // Find value, upper, lower data keys\n    var valueData = null, upperData = null, lowerData = null;\n    var units = '';\n    \n    for (var i = 0; i < data.length; i++) {\n        var ds = data[i];\n        var keyName = (ds.dataKey && ds.dataKey.name) || '';\n        var keyLabel = (ds.dataKey && ds.dataKey.label) || keyName;\n        \n        if (keyName === 'value' || keyLabel.toLowerCase() === 'value' || i === 0) {\n            if (!valueData) {\n                valueData = ds;\n                units = (ds.dataKey && ds.dataKey.units) || '';\n            }\n        }\n        if (keyName === 'upper' || keyLabel.toLowerCase().includes('upper')) {\n            upperData = ds;\n        }\n        if (keyName === 'lower' || keyLabel.toLowerCase().includes('lower')) {\n            lowerData = ds;\n        }\n    }\n    \n    // If no explicit upper/lower, check if we have 3 series\n    if (!upperData && !lowerData && data.length >= 3) {\n        valueData = data[0];\n        upperData = data[1];\n        lowerData = data[2];\n    } else if (!upperData && !lowerData && data.length === 2) {\n        valueData = data[0];\n        upperData = data[1];\n    }\n    \n    if (!valueData || !valueData.data || !valueData.data.length) {\n        chart.setOption({\n            title: { text: 'No valid data', left: 'center', top: 'middle' }\n        });\n        return;\n    }\n    \n    var valueLabel = (valueData.dataKey && valueData.dataKey.label) || 'Value';\n    \n    // Prepare data series\n    var mainLineData = valueData.data.map(function(d) { return [d[0], d[1]]; });\n    \n    var series = [];\n    var legendData = [valueLabel];\n    \n    // If we have upper and lower bounds, create band using stacked area\n    if (upperData && lowerData && upperData.data && lowerData.data) {\n        // Lower bound (invisible base)\n        var lowerLine = lowerData.data.map(function(d) { return [d[0], d[1]]; });\n        \n        // Difference (upper - lower) for the band\n        var bandData = [];\n        var upperMap = {};\n        upperData.data.forEach(function(d) { upperMap[d[0]] = d[1]; });\n        \n        lowerData.data.forEach(function(d) {\n            var ts = d[0];\n            var low = d[1];\n            var high = upperMap[ts];\n            if (high !== undefined && low !== undefined) {\n                bandData.push([ts, high - low]);\n            }\n        });\n        \n        // Lower bound line (invisible, serves as stack base)\n        series.push({\n            name: 'Lower Bound',\n            type: 'line',\n            data: lowerLine,\n            smooth: smoothLine,\n            symbol: 'none',\n            lineStyle: { opacity: 0 },\n            areaStyle: { opacity: 0 },\n            stack: 'confidence',\n            z: 1\n        });\n        \n        // Band (stacked on lower)\n        series.push({\n            name: 'Confidence Band',\n            type: 'line',\n            data: bandData,\n            smooth: smoothLine,\n            symbol: 'none',\n            lineStyle: { opacity: 0 },\n            areaStyle: {\n                color: bandColor,\n                opacity: bandOpacity\n            },\n            stack: 'confidence',\n            z: 2\n        });\n        \n        legendData.push('Confidence Band');\n    } else if (upperData && upperData.data) {\n        // Only upper bound - show as separate line\n        series.push({\n            name: 'Upper Bound',\n            type: 'line',\n            data: upperData.data.map(function(d) { return [d[0], d[1]]; }),\n            smooth: smoothLine,\n            symbol: 'none',\n            lineStyle: { color: bandColor, type: 'dashed', width: 1 }\n        });\n        legendData.push('Upper Bound');\n    }\n    \n    // Main value line (on top)\n    series.push({\n        name: valueLabel,\n        type: 'line',\n        data: mainLineData,\n        smooth: smoothLine,\n        symbol: 'none',\n        lineStyle: { color: lineColor, width: 2 },\n        z: 10\n    });\n    \n    var option = {\n        tooltip: showTooltip ? {\n            trigger: 'axis',\n            axisPointer: { type: 'cross' },\n            formatter: function(params) {\n                if (!params || !params.length) return '';\n                var d = new Date(params[0].value[0]);\n                var result = d.toLocaleString() + '<br/>';\n                for (var i = 0; i < params.length; i++) {\n                    var p = params[i];\n                    if (p.value && p.value[1] !== null && p.value[1] !== undefined && p.seriesName !== 'Lower Bound') {\n                        result += '<span style=\"display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + (p.color || lineColor) + ';\"></span>';\n                        result += p.seriesName + ': ' + p.value[1].toFixed(2) + ' ' + units + '<br/>';\n                    }\n                }\n                return result;\n            }\n        } : {},\n        legend: showLegend ? {\n            data: legendData,\n            top: 5\n        } : {},\n        toolbox: enableExport ? {\n            feature: {\n                saveAsImage: { title: 'Save as PNG' },\n                dataView: { title: 'Data View', readOnly: true }\n            },\n            right: 10\n        } : {},\n        grid: {\n            left: 50,\n            right: enableExport ? 80 : 20,\n            top: showLegend ? 40 : 20,\n            bottom: showDataZoomSlider ? 50 : 30\n        },\n        xAxis: {\n            type: 'time',\n            axisLabel: { fontSize: 10 },\n            splitLine: { show: false }\n        },\n        yAxis: {\n            type: 'value',\n            name: units,\n            axisLabel: { fontSize: 10 },\n            splitLine: { lineStyle: { type: 'dashed', opacity: 0.3 } }\n        },\n        dataZoom: [\n            { type: 'inside', xAxisIndex: 0 },\n            showDataZoomSlider ? { type: 'slider', xAxisIndex: 0, bottom: 5, height: 20 } : null\n        ].filter(function(x) { return x !== null; }),\n        series: series\n    };\n    \n    chart.setOption(option, true);\n}\n\n\n// ========================================\n// Timewindow Selector Functions\n// ========================================\n\nfunction renderTimewindowSelector() {\n    if (!timewindowSelectorContainer) return;\n\n    while (timewindowSelectorContainer.firstChild) {\n        timewindowSelectorContainer.removeChild(timewindowSelectorContainer.firstChild);\n    }\n\n    var positionMap = { left: 'flex-start', center: 'center', right: 'flex-end' };\n    var position = twSettings.position || 'center';\n\n    timewindowSelectorContainer.style.display = 'flex';\n    timewindowSelectorContainer.style.alignItems = 'center';\n    timewindowSelectorContainer.style.justifyContent = positionMap[position] || 'center';\n    timewindowSelectorContainer.style.gap = '8px';\n    timewindowSelectorContainer.style.padding = '8px';\n\n    var accentColor = '#2196F3';\n    if (twSettings.color && twSettings.color !== '') {\n        accentColor = twSettings.color;\n    } else if (self.ctx.data && self.ctx.data[0] && self.ctx.data[0].dataKey && self.ctx.data[0].dataKey.color) {\n        accentColor = self.ctx.data[0].dataKey.color;\n    }\n\n    var wrapper = document.createElement('div');\n    wrapper.style.cssText = 'display: flex; align-items: center; gap: 6px; background: ' + accentColor + '; border-radius: 6px; padding: 6px 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.12);';\n\n    var hasCustomRange = twSettings.customStartTime || twSettings.customEndTime;\n\n    if (twState.mode !== 'custom') {\n        var prevBtn = createNavButton('◀', accentColor, function() { navigateTimewindow(-1); });\n        wrapper.appendChild(prevBtn);\n    }\n\n    var periodBtns = document.createElement('div');\n    periodBtns.style.cssText = 'display: flex; gap: 4px;';\n\n    ['day', 'week', 'month'].forEach(function(mode) {\n        var btn = createPeriodButton(mode, accentColor);\n        periodBtns.appendChild(btn);\n    });\n\n    if (hasCustomRange) {\n        var customBtn = createPeriodButton('custom', accentColor);\n        periodBtns.appendChild(customBtn);\n    }\n\n    wrapper.appendChild(periodBtns);\n\n    if (twState.mode !== 'custom') {\n        var nextBtn = createNavButton('▶', accentColor, function() { navigateTimewindow(1); });\n        wrapper.appendChild(nextBtn);\n    }\n\n    var periodLabel = document.createElement('span');\n    periodLabel.id = 'tw-period-label';\n    periodLabel.style.cssText = 'color: white; font-size: 11px; margin-left: 8px; opacity: 0.9;';\n    periodLabel.textContent = formatPeriodLabel(twState.mode, twState.currentDate);\n    wrapper.appendChild(periodLabel);\n\n    timewindowSelectorContainer.appendChild(wrapper);\n}\n\nfunction createNavButton(symbol, accentColor, onClick) {\n    var btn = document.createElement('button');\n    btn.textContent = symbol;\n    btn.style.cssText = 'background: rgba(255,255,255,0.2); border: none; color: white; width: 24px; height: 24px; border-radius: 4px; cursor: pointer; font-size: 10px; display: flex; align-items: center; justify-content: center; transition: background 0.2s;';\n    btn.onmouseover = function() { btn.style.background = 'rgba(255,255,255,0.35)'; };\n    btn.onmouseout = function() { btn.style.background = 'rgba(255,255,255,0.2)'; };\n    btn.onclick = onClick;\n    return btn;\n}\n\nfunction createPeriodButton(mode, accentColor) {\n    var labels = { day: 'D', week: 'W', month: 'M', custom: 'C' };\n    var titles = { day: 'Day', week: 'Week', month: 'Month', custom: 'Custom Range' };\n\n    var btn = document.createElement('button');\n    btn.textContent = labels[mode];\n    btn.title = titles[mode];\n    btn.setAttribute('data-mode', mode);\n\n    var isActive = twState.mode === mode;\n    var baseStyle = 'border: none; width: 28px; height: 24px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600; transition: all 0.2s;';\n    var activeStyle = 'background: white; color: ' + accentColor + ';';\n    var inactiveStyle = 'background: rgba(255,255,255,0.2); color: white;';\n\n    btn.style.cssText = baseStyle + (isActive ? activeStyle : inactiveStyle);\n\n    btn.onmouseover = function() { if (twState.mode !== mode) { btn.style.background = 'rgba(255,255,255,0.35)'; } };\n    btn.onmouseout = function() { if (twState.mode !== mode) { btn.style.background = 'rgba(255,255,255,0.2)'; } };\n    btn.onclick = function() { selectPeriodMode(mode); };\n\n    return btn;\n}\n\nfunction selectPeriodMode(mode) {\n    twState.mode = mode;\n    if (mode !== 'custom') {\n        twState.currentDate = new Date();\n    }\n    applyTimewindow();\n    renderTimewindowSelector();\n}\n\nfunction navigateTimewindow(direction) {\n    var d = new Date(twState.currentDate);\n\n    switch (twState.mode) {\n        case 'day': d.setDate(d.getDate() + direction); break;\n        case 'week': d.setDate(d.getDate() + (direction * 7)); break;\n        case 'month': d.setMonth(d.getMonth() + direction); break;\n    }\n\n    twState.currentDate = d;\n    applyTimewindow();\n    updatePeriodLabel();\n}\n\nfunction applyTimewindow() {\n    var range;\n\n    if (twState.mode === 'custom') {\n        range = calculateCustomTimeRange();\n    } else {\n        range = calculateTimeRange(twState.mode, twState.currentDate);\n    }\n\n    if (!range) return;\n\n    var timewindow = {\n        history: {\n            fixedTimewindow: { startTimeMs: range.start, endTimeMs: range.end },\n            historyType: 0\n        },\n        aggregation: {\n            type: twSettings.aggregationType || 'NONE',\n            limit: twSettings.maxDataPoints || 100000\n        }\n    };\n\n    var useDashboardTimewindow = self.ctx.widget.config.useDashboardTimewindow;\n\n    if (useDashboardTimewindow !== false) {\n        if (self.ctx.dashboard && self.ctx.dashboard.updateDashboardTimewindow) {\n            self.ctx.dashboard.updateDashboardTimewindow(timewindow);\n        } else if (self.ctx.dashboard && self.ctx.dashboard.onUpdateTimewindow) {\n            self.ctx.dashboard.onUpdateTimewindow(range.start, range.end);\n        }\n    } else {\n        if (self.ctx.timewindowFunctions && self.ctx.timewindowFunctions.onUpdateTimewindow) {\n            self.ctx.timewindowFunctions.onUpdateTimewindow(range.start, range.end);\n        }\n    }\n}\n\nfunction calculateCustomTimeRange() {\n    var startStr = twSettings.customStartTime || '';\n    var endStr = twSettings.customEndTime || '';\n\n    var startMs = resolveTimeValue(startStr);\n    var endMs = resolveTimeValue(endStr);\n\n    if (startMs === null) {\n        var now = new Date();\n        startMs = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0).getTime();\n    }\n    if (endMs === null) {\n        var now2 = new Date();\n        endMs = new Date(now2.getFullYear(), now2.getMonth(), now2.getDate(), 23, 59, 59, 999).getTime();\n    }\n\n    return { start: startMs, end: endMs };\n}\n\nfunction resolveTimeValue(valueStr) {\n    if (!valueStr || valueStr === '') return null;\n\n    var varMatch = valueStr.match(/^\\$\\{(.+)\\}$/);\n    if (varMatch) {\n        var attrName = varMatch[1];\n        return resolveEntityAttribute(attrName);\n    }\n\n    var numVal = Number(valueStr);\n    if (!isNaN(numVal) && numVal > 0) return numVal;\n\n    var dateVal = Date.parse(valueStr);\n    if (!isNaN(dateVal)) return dateVal;\n\n    return null;\n}\n\nfunction resolveEntityAttribute(attrName) {\n    if (self.ctx.datasources && self.ctx.datasources.length > 0) {\n        var ds = self.ctx.datasources[0];\n        if (ds.entity) {\n            if (ds.entity.attributes && ds.entity.attributes[attrName] !== undefined) {\n                return Number(ds.entity.attributes[attrName]);\n            }\n            if (ds.entity.sharedAttributes && ds.entity.sharedAttributes[attrName] !== undefined) {\n                return Number(ds.entity.sharedAttributes[attrName]);\n            }\n        }\n        if (self.ctx.latestData) {\n            for (var i = 0; i < self.ctx.latestData.length; i++) {\n                var ld = self.ctx.latestData[i];\n                if (ld.dataKey && ld.dataKey.name === attrName && ld.data && ld.data.length > 0) {\n                    return Number(ld.data[ld.data.length - 1][1]);\n                }\n            }\n        }\n    }\n    return null;\n}\n\nfunction calculateTimeRange(mode, referenceDate) {\n    var start, end;\n    var d = new Date(referenceDate);\n\n    switch (mode) {\n        case 'day':\n            start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);\n            end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999);\n            break;\n        case 'week':\n            var dayOfWeek = d.getDay();\n            var diffToMonday = (dayOfWeek === 0 ? -6 : 1) - dayOfWeek;\n            var monday = new Date(d);\n            monday.setDate(d.getDate() + diffToMonday);\n            start = new Date(monday.getFullYear(), monday.getMonth(), monday.getDate(), 0, 0, 0, 0);\n            var sunday = new Date(monday);\n            sunday.setDate(monday.getDate() + 6);\n            end = new Date(sunday.getFullYear(), sunday.getMonth(), sunday.getDate(), 23, 59, 59, 999);\n            break;\n        case 'month':\n            start = new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);\n            end = new Date(d.getFullYear(), d.getMonth() + 1, 0, 23, 59, 59, 999);\n            break;\n    }\n\n    return { start: start.getTime(), end: end.getTime() };\n}\n\nfunction formatPeriodLabel(mode, date) {\n    var d = new Date(date);\n\n    switch (mode) {\n        case 'day':\n            return formatDateString(d, twSettings.dayFormat || 'D MMM YYYY');\n        case 'week':\n            var range = calculateTimeRange('week', d);\n            var startD = new Date(range.start);\n            var endD = new Date(range.end);\n            if (startD.getMonth() === endD.getMonth()) {\n                return startD.getDate() + '-' + endD.getDate() + ' ' + getMonthShort(startD.getMonth());\n            } else {\n                return startD.getDate() + ' ' + getMonthShort(startD.getMonth()) + ' - ' + endD.getDate() + ' ' + getMonthShort(endD.getMonth());\n            }\n        case 'month':\n            return formatDateString(d, twSettings.monthFormat || 'MMM YYYY');\n        case 'custom':\n            var customRange = calculateCustomTimeRange();\n            if (customRange) {\n                var startDate = new Date(customRange.start);\n                var endDate = new Date(customRange.end);\n                return formatDateString(startDate, 'DD.MM.YY') + ' - ' + formatDateString(endDate, 'DD.MM.YY');\n            }\n            return 'Custom';\n    }\n\n    return '';\n}\n\nfunction formatDateString(date, format) {\n    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n    var d = new Date(date);\n\n    return format\n        .replace('YYYY', d.getFullYear())\n        .replace('YY', String(d.getFullYear()).slice(-2))\n        .replace('MMM', months[d.getMonth()])\n        .replace('MM', String(d.getMonth() + 1).padStart(2, '0'))\n        .replace('DD', String(d.getDate()).padStart(2, '0'))\n        .replace('D', d.getDate());\n}\n\nfunction getMonthShort(monthIndex) {\n    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n    return months[monthIndex];\n}\n\nfunction updatePeriodLabel() {\n    var labelEl = document.getElementById('tw-period-label');\n    if (labelEl) {\n        labelEl.textContent = formatPeriodLabel(twState.mode, twState.currentDate);\n    }\n}\n\n// ========================================\n// End Timewindow Selector Functions\n// ========================================\n\n\nself.onResize = function() {\n    if (chart) {\n        chart.resize();\n    }\n};\n\nself.onDestroy = function() {\n    if (chart) {\n        chart.off('datazoom');\n        chart.dispose();\n        chart = null;\n    }\n    if (zoomDebounceTimer) {\n        clearTimeout(zoomDebounceTimer);\n    }\n};\n\nself.typeParameters = function() {\n    return {\n        previewWidth: '80%',\n        embedTitlePanel: true,\n        dataKeySettingsFunction: function() { return {}; },\n        defaultDataKeysFunction: function() {\n            return [\n                { name: 'value', label: 'Value', type: 'timeseries' },\n                { name: 'upper', label: 'Upper', type: 'timeseries' },\n                { name: 'lower', label: 'Lower', type: 'timeseries' }\n            ];\n        }\n    };\n};\n",
    "settingsSchema": {
      "schema": {
        "type": "object",
        "title": "Line Confidence Band Settings",
        "properties": {
          "enableZoomSync": {
            "title": "Enable Zoom Sync",
            "type": "boolean",
            "default": true
          },
          "zoomSyncDebounce": {
            "title": "Zoom Sync Debounce (ms)",
            "type": "number",
            "default": 150,
            "minimum": 50,
            "maximum": 500
          },
          "showDataZoomSlider": {
            "title": "Show Zoom Slider",
            "type": "boolean",
            "default": true
          },
          "lineColor": {
            "title": "Line Color",
            "type": "string",
            "default": "#2196F3"
          },
          "bandColor": {
            "title": "Band Color",
            "type": "string",
            "default": "#2196F3"
          },
          "bandOpacity": {
            "title": "Band Opacity",
            "type": "number",
            "default": 0.2,
            "minimum": 0,
            "maximum": 1
          },
          "smoothLine": {
            "title": "Smooth Line",
            "type": "boolean",
            "default": true
          },
          "showLegend": {
            "title": "Show Legend",
            "type": "boolean",
            "default": true
          },
          "showTooltip": {
            "title": "Show Tooltip",
            "type": "boolean",
            "default": true
          },
          "enableExport": {
            "title": "Enable Export (PNG/Data)",
            "type": "boolean",
            "default": true
          },
          "showTimewindowSelector": {
            "title": "Show Timewindow Selector",
            "type": "boolean",
            "default": false
          },
          "twSelectorColor": {
            "title": "Selector Color",
            "type": "string",
            "default": ""
          },
          "twSelectorPosition": {
            "title": "Selector Position",
            "type": "string",
            "default": "center",
            "enum": [
              "left",
              "center",
              "right"
            ]
          },
          "twSelectorDayFormat": {
            "title": "Day Format",
            "type": "string",
            "default": "D MMM YYYY"
          },
          "twSelectorWeekFormat": {
            "title": "Week Format",
            "type": "string",
            "default": "D-D MMM"
          },
          "twSelectorMonthFormat": {
            "title": "Month Format",
            "type": "string",
            "default": "MMM YYYY"
          },
          "twCustomStartTime": {
            "title": "Custom Start Time",
            "type": "string",
            "default": ""
          },
          "twCustomEndTime": {
            "title": "Custom End Time",
            "type": "string",
            "default": ""
          },
          "twAggregationType": {
            "title": "Aggregation",
            "type": "string",
            "default": "NONE",
            "enum": [
              "NONE",
              "AVG",
              "MIN",
              "MAX",
              "SUM",
              "COUNT"
            ]
          },
          "twMaxDataPoints": {
            "title": "Max Data Points",
            "type": "number",
            "default": 100000
          },
          "legendStyle": {
            "title": "Legend Style",
            "type": "string",
            "default": "classic",
            "enum": [
              "classic",
              "card"
            ]
          },
          "legendPosition": {
            "title": "Legend Position",
            "type": "string",
            "default": "bottom",
            "enum": [
              "top",
              "bottom",
              "left",
              "right"
            ]
          },
          "legendAlign": {
            "title": "Legend Alignment",
            "type": "string",
            "default": "center",
            "enum": [
              "left",
              "center",
              "right"
            ]
          },
          "legendCardColorMode": {
            "title": "Card Color Mode",
            "type": "string",
            "default": "auto",
            "enum": [
              "auto",
              "manual",
              "gradient"
            ]
          },
          "legendCardColor": {
            "title": "Card Color",
            "type": "string",
            "default": "#2196F3"
          },
          "legendValues": {
            "title": "Statistics to Display",
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": [
              "current"
            ]
          },
          "showTimestamp": {
            "title": "Show Timestamp",
            "type": "boolean",
            "default": true
          },
          "timestampFormat": {
            "title": "Timestamp Format",
            "type": "string",
            "default": "YYYY-MM-DD HH:mm:ss"
          },
          "removeOutliers": {
            "title": "Remove Outliers",
            "type": "boolean",
            "default": false
          },
          "outlierMethod": {
            "title": "Outlier Method",
            "type": "string",
            "default": "iqr",
            "enum": [
              "iqr",
              "zscore",
              "manual"
            ]
          },
          "outlierIqrMultiplier": {
            "title": "IQR Multiplier",
            "type": "number",
            "default": 1.5
          },
          "outlierZscoreThreshold": {
            "title": "Z-Score Threshold",
            "type": "number",
            "default": 3
          },
          "outlierMinValue": {
            "title": "Minimum Value",
            "type": "number"
          },
          "outlierMaxValue": {
            "title": "Maximum Value",
            "type": "number"
          },
          "smoothingEnabled": {
            "title": "Enable Smoothing",
            "type": "boolean",
            "default": false
          },
          "smoothingWindowMinutes": {
            "title": "Smoothing Window (minutes)",
            "type": "number",
            "default": 15
          },
          "showToolbox": {
            "title": "Show Toolbox",
            "type": "boolean",
            "default": true
          },
          "toolboxFeatures": {
            "title": "Toolbox Features",
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": [
              "saveAsImage",
              "dataView",
              "dataZoom",
              "restore"
            ]
          }
        },
        "required": []
      },
      "form": [
        "enableZoomSync",
        {
          "key": "zoomSyncDebounce",
          "condition": "model.enableZoomSync === true"
        },
        "showDataZoomSlider",
        {
          "key": "lineColor",
          "type": "color"
        },
        {
          "key": "bandColor",
          "type": "color"
        },
        "bandOpacity",
        "smoothLine",
        "showLegend",
        "showTooltip",
        "enableExport"
      ]
    },
    "dataKeySettingsSchema": {},
    "latestDataKeySettingsSchema": {},
    "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Value\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.1,\"funcBody\":\"var base = 50 + Math.sin(time / 3600000) * 20;\\nreturn base + Math.random() * 5;\",\"units\":\"°C\",\"decimals\":1},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Upper\",\"color\":\"#4CAF50\",\"settings\":{},\"_hash\":0.2,\"funcBody\":\"var base = 50 + Math.sin(time / 3600000) * 20;\\nreturn base + 10 + Math.random() * 3;\",\"units\":\"°C\",\"decimals\":1},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Lower\",\"color\":\"#FF9800\",\"settings\":{},\"_hash\":0.3,\"funcBody\":\"var base = 50 + Math.sin(time / 3600000) * 20;\\nreturn base - 10 - Math.random() * 3;\",\"units\":\"°C\",\"decimals\":1}]}],\"timewindow\":{\"hideInterval\":false,\"hideLastInterval\":false,\"hideQuickInterval\":false,\"hideAggregation\":false,\"hideAggInterval\":false,\"hideTimezone\":false,\"selectedTab\":0,\"realtime\":{\"realtimeType\":0,\"timewindowMs\":3600000,\"quickInterval\":\"CURRENT_HOUR\",\"interval\":5000},\"aggregation\":{\"type\":\"AVG\",\"limit\":25000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"enableZoomSync\":true,\"zoomSyncDebounce\":150,\"showDataZoomSlider\":true,\"lineColor\":\"#2196F3\",\"bandColor\":\"#2196F3\",\"bandOpacity\":0.2,\"smoothLine\":true,\"showLegend\":true,\"showTooltip\":true,\"enableExport\":true},\"title\":\"Line with Confidence Band\",\"dropShadow\":true,\"enableFullscreen\":true,\"useDashboardTimewindow\":true,\"displayTimewindow\":true}"
  },
  "tags": [
    "chart",
    "timeseries",
    "line",
    "confidence",
    "band",
    "forecast",
    "uncertainty",
    "interval",
    "echarts"
  ]
}