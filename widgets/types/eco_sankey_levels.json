{
  "fqn": "eco_custom_widgets.eco_sankey_levels",
  "name": "Sankey Diagram with Levels",
  "deprecated": false,
  "image": "tb-image;/api/images/system/chart.svg",
  "description": "Sankey diagram showing flow between nodes with level-based coloring. Supports ThingsBoard entity relations for automatic flow building or manual data mode.",
  "descriptor": {
    "type": "latest",
    "sizeX": 12,
    "sizeY": 8,
    "resources": [
      {
        "url": "https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"
      },
      {
        "url": "https://cdn.jsdelivr.net/gh/JiriD85/ECO-TB-Custom-Widgets@main/widgets/resources/eco-widget-utils.js"
      }
    ],
    "templateHtml": "<div id=\"chart-container\" style=\"width: 100%; height: 100%;\"></div>",
    "templateCss": "#chart-container { position: relative; }",
    "controllerScript": "var chart = null;\nvar chartContainer = null;\nvar utils = null;\n\nself.onInit = function() {\n    chartContainer = self.ctx.$container.find('#chart-container')[0];\n    if (!chartContainer) {\n        console.error('Chart container not found');\n        return;\n    }\n    \n    if (typeof echarts === 'undefined') {\n        console.error('ECharts not loaded');\n        return;\n    }\n    \n    // Initialize ECOWidgetUtils library\n    utils = window.ECOWidgetUtils;\n    if (!utils) {\n        console.warn('ECOWidgetUtils not loaded, using fallback functions');\n    }\n    \n    chart = echarts.init(chartContainer);\n    updateChart();\n};\n\nself.onDataUpdated = function() {\n    updateChart();\n};\n\nfunction getLevelColors(levelColors) {\n    if (levelColors && levelColors.length > 0) {\n        return levelColors.split(',').map(function(c) { return c.trim(); });\n    }\n    // Use ECOWidgetUtils color palette if available\n    if (utils && utils.color && utils.color.getDefault) {\n        var colors = [];\n        for (var i = 0; i < 8; i++) {\n            colors.push(utils.color.getDefault(i));\n        }\n        return colors;\n    }\n    return ['#5470C6', '#91CC75', '#FAC858', '#EE6666', '#73C0DE', '#3BA272', '#FC8452', '#9A60B4'];\n}\n\nfunction formatValue(val, decimals) {\n    // Use ECOWidgetUtils formatting if available\n    if (utils && utils.format && utils.format.value) {\n        return utils.format.value(val, decimals);\n    }\n    // Fallback formatting\n    if (val === null || val === undefined) return '-';\n    if (decimals === undefined || decimals === null) {\n        if (Math.abs(val) >= 1000) return val.toFixed(0);\n        if (Math.abs(val) >= 100) return val.toFixed(1);\n        return val.toFixed(2);\n    }\n    return val.toFixed(decimals);\n}\n\nfunction buildManualSankeyData(data, settings) {\n    // Manual mode: expect source, target, value keys OR build from entity relationships in data\n    var nodes = [];\n    var links = [];\n    var nodeSet = {};\n    \n    // Check if we have explicit source/target/value data keys\n    var sourceData = null, targetData = null, valueData = null;\n    \n    for (var i = 0; i < data.length; i++) {\n        var ds = data[i];\n        var keyName = ((ds.dataKey && ds.dataKey.name) || '').toLowerCase();\n        var keyLabel = ((ds.dataKey && ds.dataKey.label) || '').toLowerCase();\n        \n        if (keyName === 'source' || keyLabel === 'source') sourceData = ds;\n        else if (keyName === 'target' || keyLabel === 'target') targetData = ds;\n        else if (keyName === 'value' || keyLabel === 'value' || keyName === 'flow' || keyLabel === 'flow') valueData = ds;\n    }\n    \n    if (sourceData && targetData && valueData) {\n        // Explicit source/target/value mode\n        var sourceMap = {}, targetMap = {}, valueMap = {};\n        if (sourceData.data) sourceData.data.forEach(function(d) { sourceMap[d[0]] = d[1]; });\n        if (targetData.data) targetData.data.forEach(function(d) { targetMap[d[0]] = d[1]; });\n        if (valueData.data) valueData.data.forEach(function(d) { valueMap[d[0]] = d[1]; });\n        \n        var timestamps = {};\n        [sourceData, targetData, valueData].forEach(function(ds) {\n            if (ds && ds.data) ds.data.forEach(function(d) { timestamps[d[0]] = true; });\n        });\n        \n        Object.keys(timestamps).forEach(function(ts) {\n            var source = sourceMap[ts];\n            var target = targetMap[ts];\n            var value = valueMap[ts];\n            \n            if (source && target && value) {\n                if (!nodeSet[source]) {\n                    nodeSet[source] = true;\n                    nodes.push({ name: source });\n                }\n                if (!nodeSet[target]) {\n                    nodeSet[target] = true;\n                    nodes.push({ name: target });\n                }\n                links.push({ source: source, target: target, value: parseFloat(value) || 1 });\n            }\n        });\n    } else {\n        // Fallback: treat each datasource as a flow from one entity to another\n        // Create a simple chain from first to last entity\n        for (var i = 0; i < data.length; i++) {\n            var ds = data[i];\n            var entityName = (ds.datasource && ds.datasource.name) || (ds.dataKey && ds.dataKey.label) || 'Node ' + (i + 1);\n            \n            if (!nodeSet[entityName]) {\n                nodeSet[entityName] = true;\n                nodes.push({ name: entityName, depth: i });\n            }\n            \n            // Get value from first data point\n            var flowValue = 100;\n            if (ds.data && ds.data.length > 0 && ds.data[0].length > 1) {\n                flowValue = parseFloat(ds.data[0][1]) || 100;\n            }\n            \n            if (i > 0) {\n                var prevName = (data[i - 1].datasource && data[i - 1].datasource.name) || \n                               (data[i - 1].dataKey && data[i - 1].dataKey.label) || 'Node ' + i;\n                links.push({ source: prevName, target: entityName, value: flowValue });\n            }\n        }\n    }\n    \n    return { nodes: nodes, links: links };\n}\n\nasync function buildRelationsSankeyData(ctx, settings) {\n    var relationType = settings.relationType || 'Contains';\n    var relationDirection = settings.relationDirection || 'FROM';\n    var flowAttribute = settings.flowAttribute || 'value';\n    \n    var data = ctx.data || [];\n    if (!data.length || !data[0].datasource) {\n        return null;\n    }\n    \n    var rootEntity = data[0].datasource.entity;\n    if (!rootEntity || !rootEntity.id) {\n        return null;\n    }\n    \n    var $injector = ctx.$scope.$injector;\n    var entityRelationService = $injector.get(ctx.servicesMap.get('entityRelationService'));\n    var attributeService = $injector.get(ctx.servicesMap.get('attributeService'));\n    \n    var nodes = [];\n    var links = [];\n    var nodeSet = {};\n    var visited = {};\n    \n    async function loadEntityRelations(entityId, depth) {\n        var entityKey = entityId.entityType + ':' + entityId.id;\n        if (visited[entityKey]) return;\n        visited[entityKey] = true;\n        \n        // Get entity name\n        var nodeName = entityId.entityType + ':' + entityId.id.substring(0, 8);\n        try {\n            var nameAttrs = await attributeService.getEntityAttributes(entityId, 'SERVER_SCOPE', ['name']).toPromise();\n            if (nameAttrs && nameAttrs.length > 0) {\n                nodeName = nameAttrs[0].value || nodeName;\n            }\n        } catch (e) {}\n        \n        if (!nodeSet[nodeName]) {\n            nodeSet[nodeName] = true;\n            nodes.push({ name: nodeName, depth: depth });\n        }\n        \n        try {\n            var query = {\n                parameters: {\n                    rootId: entityId.id,\n                    rootType: entityId.entityType,\n                    direction: relationDirection,\n                    relationTypeGroup: 'COMMON',\n                    maxLevel: 1\n                },\n                filters: [{\n                    relationType: relationType,\n                    entityTypes: []\n                }]\n            };\n            \n            var relations = await entityRelationService.findByQuery(query).toPromise();\n            \n            if (relations && relations.length > 0) {\n                for (var i = 0; i < relations.length; i++) {\n                    var rel = relations[i];\n                    var childId = relationDirection === 'FROM' ? rel.to : rel.from;\n                    \n                    // Get child name\n                    var childName = childId.entityType + ':' + childId.id.substring(0, 8);\n                    try {\n                        var childNameAttrs = await attributeService.getEntityAttributes(childId, 'SERVER_SCOPE', ['name']).toPromise();\n                        if (childNameAttrs && childNameAttrs.length > 0) {\n                            childName = childNameAttrs[0].value || childName;\n                        }\n                    } catch (e) {}\n                    \n                    // Get flow value\n                    var flowValue = 100;\n                    try {\n                        var flowAttrs = await attributeService.getEntityAttributes(childId, 'SERVER_SCOPE', [flowAttribute]).toPromise();\n                        if (flowAttrs && flowAttrs.length > 0) {\n                            flowValue = parseFloat(flowAttrs[0].value) || 100;\n                        }\n                    } catch (e) {}\n                    \n                    if (!nodeSet[childName]) {\n                        nodeSet[childName] = true;\n                        nodes.push({ name: childName, depth: depth + 1 });\n                    }\n                    \n                    links.push({\n                        source: nodeName,\n                        target: childName,\n                        value: flowValue\n                    });\n                    \n                    // Recursively load children (up to depth 4)\n                    if (depth < 4) {\n                        await loadEntityRelations(childId, depth + 1);\n                    }\n                }\n            }\n        } catch (e) {\n            console.warn('Failed to load relations:', e);\n        }\n    }\n    \n    await loadEntityRelations(rootEntity.id, 0);\n    \n    return nodes.length > 0 ? { nodes: nodes, links: links } : null;\n}\n\nfunction updateChart() {\n    if (!chart) return;\n    \n    var settings = self.ctx.settings || {};\n    var dataMode = settings.dataMode || 'manual';\n    var orient = settings.orient || 'horizontal';\n    var nodeWidth = settings.nodeWidth || 20;\n    var nodeGap = settings.nodeGap || 10;\n    var levelColors = settings.levelColors || '';\n    var linkOpacity = settings.linkOpacity || 0.4;\n    var linkColorMode = settings.linkColorMode || 'gradient';\n    var labelPosition = settings.labelPosition || 'right';\n    var showTooltip = settings.showTooltip !== false;\n    var enableExport = settings.enableExport !== false;\n    \n    var data = self.ctx.data || [];\n    \n    if (dataMode === 'relations') {\n        chart.showLoading();\n        \n        buildRelationsSankeyData(self.ctx, settings).then(function(sankeyData) {\n            chart.hideLoading();\n            if (sankeyData && sankeyData.nodes.length > 0) {\n                renderSankey(sankeyData, settings);\n            } else {\n                var manualData = buildManualSankeyData(data, settings);\n                renderSankey(manualData, settings);\n            }\n        }).catch(function(e) {\n            chart.hideLoading();\n            console.error('Relations loading failed:', e);\n            var manualData = buildManualSankeyData(data, settings);\n            renderSankey(manualData, settings);\n        });\n    } else {\n        var sankeyData = buildManualSankeyData(data, settings);\n        renderSankey(sankeyData, settings);\n    }\n}\n\nfunction renderSankey(sankeyData, settings) {\n    if (!chart || !sankeyData) return;\n    \n    var orient = settings.orient || 'horizontal';\n    var nodeWidth = settings.nodeWidth || 20;\n    var nodeGap = settings.nodeGap || 10;\n    var levelColors = settings.levelColors || '';\n    var linkOpacity = settings.linkOpacity || 0.4;\n    var linkColorMode = settings.linkColorMode || 'gradient';\n    var labelPosition = settings.labelPosition || 'right';\n    var showTooltip = settings.showTooltip !== false;\n    var enableExport = settings.enableExport !== false;\n    var valueDecimals = settings.valueDecimals !== undefined ? settings.valueDecimals : 2;\n    \n    if (sankeyData.nodes.length === 0 || sankeyData.links.length === 0) {\n        chart.setOption({\n            title: { text: 'No valid Sankey data', left: 'center', top: 'middle' }\n        });\n        return;\n    }\n    \n    var colors = getLevelColors(levelColors);\n    \n    // Assign colors based on depth\n    var maxDepth = 0;\n    sankeyData.nodes.forEach(function(node) {\n        if (node.depth !== undefined && node.depth > maxDepth) {\n            maxDepth = node.depth;\n        }\n    });\n    \n    sankeyData.nodes.forEach(function(node, i) {\n        var depth = node.depth !== undefined ? node.depth : i;\n        node.itemStyle = { color: colors[depth % colors.length] };\n    });\n    \n    // Build levels configuration\n    var levels = [];\n    for (var i = 0; i <= maxDepth; i++) {\n        levels.push({\n            depth: i,\n            itemStyle: {\n                color: colors[i % colors.length]\n            },\n            lineStyle: {\n                color: linkColorMode === 'source' ? 'source' : (linkColorMode === 'target' ? 'target' : 'gradient'),\n                opacity: linkOpacity\n            }\n        });\n    }\n    \n    var option = {\n        tooltip: showTooltip ? {\n            trigger: 'item',\n            formatter: function(params) {\n                if (params.dataType === 'edge') {\n                    return params.data.source + ' \\u2192 ' + params.data.target + '<br/>Flow: ' + formatValue(params.data.value, valueDecimals);\n                } else {\n                    return params.data.name;\n                }\n            }\n        } : {},\n        toolbox: enableExport ? {\n            feature: {\n                saveAsImage: { title: 'Save as PNG' },\n                dataView: { title: 'Data View', readOnly: true }\n            },\n            right: 10\n        } : {},\n        series: [{\n            type: 'sankey',\n            data: sankeyData.nodes,\n            links: sankeyData.links,\n            orient: orient,\n            nodeWidth: nodeWidth,\n            nodeGap: nodeGap,\n            layoutIterations: 32,\n            emphasis: {\n                focus: 'adjacency'\n            },\n            label: {\n                position: labelPosition,\n                fontSize: 11\n            },\n            lineStyle: {\n                color: linkColorMode === 'source' ? 'source' : (linkColorMode === 'target' ? 'target' : 'gradient'),\n                opacity: linkOpacity,\n                curveness: 0.5\n            },\n            levels: levels,\n            left: 50,\n            right: enableExport ? 80 : 50,\n            top: 20,\n            bottom: 20\n        }]\n    };\n    \n    chart.setOption(option, true);\n}\n\nself.onResize = function() {\n    if (chart) {\n        chart.resize();\n    }\n};\n\nself.onDestroy = function() {\n    if (chart) {\n        chart.dispose();\n        chart = null;\n    }\n};\n\nself.typeParameters = function() {\n    return {\n        previewWidth: '100%',\n        embedTitlePanel: true,\n        dataKeySettingsFunction: function() { return {}; },\n        defaultDataKeysFunction: function() {\n            return [\n                { name: 'source', label: 'Source', type: 'attribute' },\n                { name: 'target', label: 'Target', type: 'attribute' },\n                { name: 'value', label: 'Flow Value', type: 'attribute' }\n            ];\n        }\n    };\n};\n",
    "settingsSchema": {
      "schema": {
        "type": "object",
        "title": "Sankey Diagram Settings",
        "properties": {
          "dataMode": {
            "title": "Data Mode",
            "type": "string",
            "default": "manual",
            "enum": ["manual", "relations"]
          },
          "relationDirection": {
            "title": "Relation Direction",
            "type": "string",
            "default": "FROM",
            "enum": ["FROM", "TO"]
          },
          "relationType": {
            "title": "Relation Type",
            "type": "string",
            "default": "Contains"
          },
          "flowAttribute": {
            "title": "Flow Attribute",
            "type": "string",
            "default": "value"
          },
          "orient": {
            "title": "Orientation",
            "type": "string",
            "default": "horizontal",
            "enum": ["horizontal", "vertical"]
          },
          "nodeWidth": {
            "title": "Node Width (px)",
            "type": "number",
            "default": 20,
            "minimum": 5,
            "maximum": 50
          },
          "nodeGap": {
            "title": "Node Gap (px)",
            "type": "number",
            "default": 10,
            "minimum": 2,
            "maximum": 30
          },
          "levelColors": {
            "title": "Level Colors (comma separated)",
            "type": "string",
            "default": ""
          },
          "linkOpacity": {
            "title": "Link Opacity",
            "type": "number",
            "default": 0.4,
            "minimum": 0.1,
            "maximum": 1
          },
          "linkColorMode": {
            "title": "Link Color Mode",
            "type": "string",
            "default": "gradient",
            "enum": ["source", "target", "gradient"]
          },
          "labelPosition": {
            "title": "Label Position",
            "type": "string",
            "default": "right",
            "enum": ["left", "right", "inside"]
          },
          "valueDecimals": {
            "title": "Value Decimals",
            "type": "number",
            "default": 2,
            "minimum": 0,
            "maximum": 6
          },
          "showTooltip": {
            "title": "Show Tooltip",
            "type": "boolean",
            "default": true
          },
          "enableExport": {
            "title": "Enable Export (PNG/Data)",
            "type": "boolean",
            "default": true
          }
        },
        "required": []
      },
      "form": [
        {
          "key": "dataMode",
          "type": "rc-select",
          "multiple": false,
          "items": [
            { "value": "manual", "label": "Manual (source/target/value keys)" },
            { "value": "relations", "label": "Entity Relations (load flows)" }
          ]
        },
        {
          "key": "relationDirection",
          "type": "rc-select",
          "multiple": false,
          "condition": "model.dataMode === 'relations'",
          "items": [
            { "value": "FROM", "label": "From parent to children" },
            { "value": "TO", "label": "From children to parent" }
          ]
        },
        {
          "key": "relationType",
          "condition": "model.dataMode === 'relations'"
        },
        {
          "key": "flowAttribute",
          "condition": "model.dataMode === 'relations'"
        },
        {
          "key": "orient",
          "type": "rc-select",
          "multiple": false,
          "items": [
            { "value": "horizontal", "label": "Horizontal (left to right)" },
            { "value": "vertical", "label": "Vertical (top to bottom)" }
          ]
        },
        "nodeWidth",
        "nodeGap",
        "levelColors",
        "linkOpacity",
        {
          "key": "linkColorMode",
          "type": "rc-select",
          "multiple": false,
          "items": [
            { "value": "gradient", "label": "Gradient (source to target)" },
            { "value": "source", "label": "Source node color" },
            { "value": "target", "label": "Target node color" }
          ]
        },
        {
          "key": "labelPosition",
          "type": "rc-select",
          "multiple": false,
          "items": [
            { "value": "left", "label": "Left" },
            { "value": "right", "label": "Right" },
            { "value": "inside", "label": "Inside node" }
          ]
        },
        "valueDecimals",
        "showTooltip",
        "enableExport"
      ]
    },
    "dataKeySettingsSchema": {},
    "latestDataKeySettingsSchema": {},
    "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Stage 1\",\"color\":\"#5470C6\",\"settings\":{},\"_hash\":0.1,\"funcBody\":\"return 1000;\",\"units\":\"\",\"decimals\":0},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Stage 2A\",\"color\":\"#91CC75\",\"settings\":{},\"_hash\":0.2,\"funcBody\":\"return 600;\",\"units\":\"\",\"decimals\":0},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Stage 2B\",\"color\":\"#FAC858\",\"settings\":{},\"_hash\":0.3,\"funcBody\":\"return 400;\",\"units\":\"\",\"decimals\":0},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Stage 3\",\"color\":\"#EE6666\",\"settings\":{},\"_hash\":0.4,\"funcBody\":\"return 800;\",\"units\":\"\",\"decimals\":0}]}],\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"dataMode\":\"manual\",\"relationDirection\":\"FROM\",\"relationType\":\"Contains\",\"flowAttribute\":\"value\",\"orient\":\"horizontal\",\"nodeWidth\":20,\"nodeGap\":10,\"levelColors\":\"\",\"linkOpacity\":0.4,\"linkColorMode\":\"gradient\",\"labelPosition\":\"right\",\"valueDecimals\":2,\"showTooltip\":true,\"enableExport\":true},\"title\":\"Sankey Diagram with Levels\",\"dropShadow\":true,\"enableFullscreen\":true}"
  },
  "tags": [
    "chart",
    "latest",
    "sankey",
    "flow",
    "relations",
    "levels",
    "energy",
    "echarts"
  ]
}
