{
  "fqn": "eco_custom_widgets.eco_timeseries_zoom_sync",
  "name": "ECO Timeseries Zoom Sync",
  "deprecated": false,
  "image": "tb-image;/api/images/system/chart.svg",
  "description": "Time series visualization with configurable chart types (line, bar, area, scatter), multi-series support, dual Y-axes, statistics cards, and internal zoom. Reference implementation for ECO Custom Widgets.",
  "descriptor": {
    "type": "timeseries",
    "sizeX": 8,
    "sizeY": 5,
    "resources": [
      {
        "url": "https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"
      }
    ],
    "templateHtml": "<div id=\"widget-wrapper\" style=\"width: 100%; height: 100%; display: flex; flex-direction: column;\">\n  <div id=\"timewindow-selector\" style=\"display: none;\"></div>\n  <div id=\"stats-card-top\" style=\"padding: 4px 8px; display: none;\"></div>\n  <div style=\"flex: 1; min-height: 0; display: flex;\">\n    <div id=\"stats-card-left\" style=\"padding: 4px; display: none;\"></div>\n    <div id=\"chart-container\" style=\"flex: 1; min-height: 0;\"></div>\n    <div id=\"stats-card-right\" style=\"padding: 4px; display: none;\"></div>\n  </div>\n  <div id=\"stats-card-bottom\" style=\"padding: 4px 8px; display: none;\"></div>\n</div>",
    "templateCss": "#widget-wrapper { position: relative; }\n#chart-container { position: relative; }",
    "controllerScript": "/**\n * ECO Timeseries Zoom Sync Widget\n *\n * Time series visualization with configurable display modes:\n * - Single Chart: All series overlaid in one chart\n * - Stacked Charts: Each series in its own chart (vertically stacked)\n *\n * Features: Multi-series support, dual Y-axes, statistics cards, timewindow selector\n */\n\nvar chart = null;\nvar chartContainer = null;\nvar statsCardContainers = {};\nvar timewindowContainer = null;\nvar resizeObserver = null;\n\n// Timewindow Selector State\nvar twState = {\n    mode: 'custom',\n    currentDate: new Date(),\n    customStart: null,\n    customEnd: null\n};\n\n// Cached entity attributes\nvar entityAttributes = {};\n\n// User language\nvar userLanguage = 'en';\n\n// ========================================\n// Utility Functions - Statistics\n// ========================================\nvar statsUtils = {\n    calculate: function(values) {\n        if (!values || values.length === 0) {\n            return { mean: 0, median: 0, min: 0, max: 0, sum: 0, count: 0, current: null };\n        }\n        var sorted = values.slice().sort(function(a, b) { return a - b; });\n        var sum = 0;\n        for (var i = 0; i < values.length; i++) sum += values[i];\n        return {\n            mean: sum / values.length,\n            median: this.percentile(sorted, 50),\n            min: sorted[0],\n            max: sorted[sorted.length - 1],\n            sum: sum,\n            count: values.length,\n            current: values[values.length - 1]\n        };\n    },\n    percentile: function(sortedValues, p) {\n        if (sortedValues.length === 0) return 0;\n        if (sortedValues.length === 1) return sortedValues[0];\n        var index = (p / 100) * (sortedValues.length - 1);\n        var lower = Math.floor(index);\n        var upper = Math.ceil(index);\n        var weight = index - lower;\n        if (upper >= sortedValues.length) return sortedValues[sortedValues.length - 1];\n        return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;\n    },\n    stdDev: function(values, mean) {\n        if (values.length === 0) return 0;\n        var sumSquares = 0;\n        for (var i = 0; i < values.length; i++) sumSquares += Math.pow(values[i] - mean, 2);\n        return Math.sqrt(sumSquares / values.length);\n    }\n};\n\n// ========================================\n// Utility Functions - Data Processing\n// ========================================\nvar dataProcessingUtils = {\n    removeOutliers: function(values, timestamps, options) {\n        var method = (options && options.method) || 'iqr';\n        var cleanValues = [];\n        var cleanTimestamps = [];\n        var removed = 0;\n\n        if (method === 'manual') {\n            var minVal = (options.minValue !== undefined && options.minValue !== null) ? options.minValue : -Infinity;\n            var maxVal = (options.maxValue !== undefined && options.maxValue !== null) ? options.maxValue : Infinity;\n            for (var i = 0; i < values.length; i++) {\n                if (values[i] >= minVal && values[i] <= maxVal) {\n                    cleanValues.push(values[i]);\n                    cleanTimestamps.push(timestamps[i]);\n                } else removed++;\n            }\n        } else if (method === 'zscore') {\n            var threshold = (options && options.zscoreThreshold) || 3;\n            var stats = statsUtils.calculate(values);\n            var stdDev = statsUtils.stdDev(values, stats.mean);\n            if (stdDev === 0) return { values: values, timestamps: timestamps, removed: 0 };\n            for (var j = 0; j < values.length; j++) {\n                var zscore = Math.abs((values[j] - stats.mean) / stdDev);\n                if (zscore <= threshold) {\n                    cleanValues.push(values[j]);\n                    cleanTimestamps.push(timestamps[j]);\n                } else removed++;\n            }\n        } else {\n            var multiplier = (options && options.iqrMultiplier) || 1.5;\n            var sorted = values.slice().sort(function(a, b) { return a - b; });\n            var q1 = statsUtils.percentile(sorted, 25);\n            var q3 = statsUtils.percentile(sorted, 75);\n            var iqr = q3 - q1;\n            var lowerFence, upperFence;\n            if (iqr === 0) {\n                var median = statsUtils.percentile(sorted, 50);\n                var range = Math.abs(median) * 0.5;\n                if (range === 0) range = 1;\n                lowerFence = median - range;\n                upperFence = median + range;\n            } else {\n                lowerFence = q1 - (multiplier * iqr);\n                upperFence = q3 + (multiplier * iqr);\n            }\n            for (var k = 0; k < values.length; k++) {\n                if (values[k] >= lowerFence && values[k] <= upperFence) {\n                    cleanValues.push(values[k]);\n                    cleanTimestamps.push(timestamps[k]);\n                } else removed++;\n            }\n        }\n        return { values: cleanValues, timestamps: cleanTimestamps, removed: removed };\n    },\n    movingAverage: function(values, windowSize) {\n        var result = [];\n        var halfWindow = Math.floor(windowSize / 2);\n        for (var i = 0; i < values.length; i++) {\n            var start = Math.max(0, i - halfWindow);\n            var end = Math.min(values.length, i + halfWindow + 1);\n            var sum = 0;\n            for (var j = start; j < end; j++) sum += values[j];\n            result.push(sum / (end - start));\n        }\n        return result;\n    },\n    getWindowSizeFromMinutes: function(timestamps, minutes) {\n        if (timestamps.length < 2) return 1;\n        var totalTimeMs = timestamps[timestamps.length - 1] - timestamps[0];\n        var avgIntervalMs = totalTimeMs / (timestamps.length - 1);\n        var windowMs = minutes * 60 * 1000;\n        return Math.max(1, Math.round(windowMs / avgIntervalMs));\n    }\n};\n\n// ========================================\n// Utility Functions - Color\n// ========================================\nvar colorUtils = {\n    adjust: function(color, amount) {\n        var usePound = false;\n        if (color[0] === '#') { color = color.slice(1); usePound = true; }\n        var num = parseInt(color, 16);\n        var r = Math.min(255, Math.max(0, (num >> 16) + amount));\n        var g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));\n        var b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));\n        return (usePound ? '#' : '') + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);\n    },\n    getDefault: function(index) {\n        var colors = ['#2196F3', '#4CAF50', '#FF9800', '#E91E63', '#9C27B0', '#00BCD4', '#795548', '#607D8B'];\n        return colors[index % colors.length];\n    }\n};\n\n// ========================================\n// Utility Functions - Axis\n// ========================================\nvar axisUtils = {\n    /**\n     * Calculate nice axis bounds (rounded to clean numbers like 0, 5, 10, 50, 100, etc.)\n     * @param {number} dataMin - Minimum data value\n     * @param {number} dataMax - Maximum data value\n     * @returns {object} { min, max } - Nice rounded bounds\n     */\n    niceAxisBounds: function(dataMin, dataMax) {\n        var range = dataMax - dataMin;\n\n        // Handle edge cases\n        if (range === 0) {\n            // All values are the same - create artificial range\n            if (dataMax === 0) return { min: 0, max: 1 };\n            var singleValue = Math.abs(dataMax);\n            var magnitude = Math.pow(10, Math.floor(Math.log10(singleValue)));\n            return {\n                min: Math.floor(dataMin / magnitude) * magnitude,\n                max: Math.ceil(dataMax / magnitude + 0.5) * magnitude\n            };\n        }\n\n        // Calculate order of magnitude for tick spacing\n        var exponent = Math.floor(Math.log10(range));\n        var magnitude = Math.pow(10, exponent);\n\n        // Normalized range (typically 1-10)\n        var normalized = range / magnitude;\n\n        // Choose nice tick interval based on normalized range\n        // This gives us ~4-8 ticks on the axis\n        var tickInterval;\n        if (normalized <= 1.5) tickInterval = 0.2 * magnitude;\n        else if (normalized <= 3) tickInterval = 0.5 * magnitude;\n        else if (normalized <= 6) tickInterval = 1 * magnitude;\n        else tickInterval = 2 * magnitude;\n\n        // Round min DOWN and max UP to nearest tick interval\n        var niceMin = Math.floor(dataMin / tickInterval) * tickInterval;\n        var niceMax = Math.ceil(dataMax / tickInterval) * tickInterval;\n\n        // Ensure there's at least one tick of padding\n        if (niceMin === dataMin) niceMin -= tickInterval;\n        if (niceMax === dataMax) niceMax += tickInterval;\n\n        // Round to avoid floating point artifacts (e.g., 0.30000000000000004)\n        var decimals = Math.max(0, -exponent + 1);\n        niceMin = Number(niceMin.toFixed(decimals));\n        niceMax = Number(niceMax.toFixed(decimals));\n\n        return { min: niceMin, max: niceMax };\n    }\n};\n\n// ========================================\n// Migration Helpers\n// ========================================\nfunction migrateSettings(settings) {\n    // Migrate old appearance settings to global\n    if (settings.axisLabelFontSize === undefined) {\n        settings.axisLabelFontSize = settings.yAxisLeftTitleFontSize || 11;\n    }\n    if (settings.axisLabelColor === undefined) {\n        settings.axisLabelColor = settings.yAxisLeftTitleColor || '#666666';\n    }\n    if (settings.axisTickFontSize === undefined) {\n        settings.axisTickFontSize = settings.yAxisLeftTicksFontSize || 10;\n    }\n    return settings;\n}\n\nfunction migrateDataKeySettings(dkSettings) {\n    // Migrate chartIndex (number) to chartsAssignment (array)\n    if (dkSettings.chartIndex !== undefined && !dkSettings.chartsAssignment) {\n        dkSettings.chartsAssignment = dkSettings.chartIndex > 0 ? [dkSettings.chartIndex] : [1];\n    }\n    return dkSettings;\n}\n\n// ========================================\n// Utility Functions - Formatting\n// ========================================\nvar formatUtils = {\n    value: function(value, decimals) {\n        if (value === null || value === undefined) return '-';\n        if (decimals === undefined || decimals === null) {\n            if (Math.abs(value) >= 1000) return value.toFixed(0);\n            if (Math.abs(value) >= 100) return value.toFixed(1);\n            return value.toFixed(2);\n        }\n        return value.toFixed(decimals);\n    },\n    timestamp: function(ts, format) {\n        var d = new Date(ts);\n        format = format || 'YYYY-MM-DD HH:mm:ss';\n        return format\n            .replace('YYYY', d.getFullYear())\n            .replace('MM', String(d.getMonth() + 1).padStart(2, '0'))\n            .replace('DD', String(d.getDate()).padStart(2, '0'))\n            .replace('HH', String(d.getHours()).padStart(2, '0'))\n            .replace('mm', String(d.getMinutes()).padStart(2, '0'))\n            .replace('ss', String(d.getSeconds()).padStart(2, '0'));\n    },\n    date: function(date, format, lang) {\n        lang = lang || userLanguage || 'en';\n        var monthsShort = {\n            en: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            de: ['Jan', 'Feb', 'MÃ¤r', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']\n        };\n        var monthsFull = {\n            en: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n            de: ['Januar', 'Februar', 'MÃ¤rz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']\n        };\n        var d = new Date(date);\n        var shortMonths = monthsShort[lang] || monthsShort.en;\n        var fullMonths = monthsFull[lang] || monthsFull.en;\n        format = format || 'D MMM YYYY';\n        var tokens = {\n            'YYYY': d.getFullYear(),\n            'YY': String(d.getFullYear()).slice(-2),\n            'MMMM': fullMonths[d.getMonth()],\n            'MMM': shortMonths[d.getMonth()],\n            'MM': String(d.getMonth() + 1).padStart(2, '0'),\n            'DD': String(d.getDate()).padStart(2, '0'),\n            'D': String(d.getDate()),\n            'M': String(d.getMonth() + 1)\n        };\n        return format.replace(/(YYYY|MMMM|MMM|MM|DD|YY|D|M)/g, function(match) {\n            return tokens[match] !== undefined ? tokens[match] : match;\n        });\n    }\n};\n\n// ========================================\n// Translations\n// ========================================\nvar translations = {\n    en: { selectPeriod: 'Select Period', from: 'From', to: 'To', cancel: 'Cancel', apply: 'Apply', day: 'Day', week: 'Week', month: 'Month', custom: 'Custom' },\n    de: { selectPeriod: 'Zeitraum wÃ¤hlen', from: 'Von', to: 'Bis', cancel: 'Abbrechen', apply: 'Anwenden', day: 'Tag', week: 'Woche', month: 'Monat', custom: 'Custom' }\n};\n\nfunction t(key) {\n    var lang = userLanguage || 'en';\n    var langStrings = translations[lang] || translations.en;\n    return langStrings[key] || translations.en[key] || key;\n}\n\n// ========================================\n// Language Detection\n// ========================================\nfunction detectUserLanguage() {\n    try {\n        if (self.ctx && self.ctx.$scope && self.ctx.$scope.$injector) {\n            var translate = self.ctx.$scope.$injector.get('$translate');\n            if (translate && translate.use) {\n                var tbLang = translate.use();\n                if (tbLang) { userLanguage = tbLang.substring(0, 2).toLowerCase(); return; }\n            }\n        }\n    } catch (e) {}\n    try {\n        var tbSettings = localStorage.getItem('thingsboard');\n        if (tbSettings) {\n            var parsed = JSON.parse(tbSettings);\n            if (parsed && parsed.language) { userLanguage = parsed.language.substring(0, 2).toLowerCase(); return; }\n        }\n    } catch (e) {}\n    var browserLang = navigator.language || navigator.userLanguage || 'en';\n    userLanguage = browserLang.substring(0, 2).toLowerCase();\n}\n\n// ========================================\n// Stats Card Rendering\n// ========================================\nfunction renderStatsCard(config) {\n    ['top', 'bottom', 'left', 'right'].forEach(function(pos) {\n        var container = statsCardContainers[pos];\n        if (container) {\n            container.style.display = 'none';\n            while (container.firstChild) container.removeChild(container.firstChild);\n        }\n    });\n\n    var legendValues = config.legendValues || [];\n    var legendStyle = config.legendStyle || 'classic';\n    var showCard = config.showLegend && legendStyle === 'card' && config.allStats && config.allStats.length > 0;\n\n    if (!showCard) return;\n\n    var position = config.legendPosition || 'bottom';\n    var align = config.legendAlign || 'center';\n    var container = statsCardContainers[position];\n    if (!container) return;\n\n    var isVertical = (position === 'left' || position === 'right');\n    var justifyMap = { left: 'flex-start', center: 'center', right: 'flex-end' };\n\n    container.style.display = 'flex';\n    container.style.flexWrap = 'wrap';\n    container.style.gap = '8px';\n\n    if (isVertical) {\n        container.style.flexDirection = 'column';\n        container.style.alignItems = justifyMap[align];\n        container.style.justifyContent = 'flex-start';\n    } else {\n        container.style.flexDirection = 'row';\n        container.style.justifyContent = justifyMap[align];\n        container.style.alignItems = 'flex-start';\n    }\n\n    config.allStats.forEach(function(seriesInfo) {\n        var card = createStatsCard(seriesInfo, config, isVertical);\n        container.appendChild(card);\n    });\n}\n\nfunction createStatsCard(seriesInfo, config, isVertical) {\n    var stats = seriesInfo.stats;\n    var unit = seriesInfo.units || '';\n    var dec = seriesInfo.decimals !== undefined ? seriesInfo.decimals : 2;\n    var seriesColor = seriesInfo.color || '#2196F3';\n    var colorMode = config.legendCardColorMode || 'auto';\n    var manualColor = config.legendCardColor || '#2196F3';\n    var legendValues = config.legendValues || [];\n\n    var bgColor = colorMode === 'manual' ? manualColor : seriesColor;\n    var bgStyle;\n    if (colorMode === 'gradient') {\n        var gradientDir = isVertical ? '180deg' : '135deg';\n        bgStyle = 'linear-gradient(' + gradientDir + ', ' + bgColor + ' 0%, ' + colorUtils.adjust(bgColor, -40) + ' 100%)';\n    } else {\n        bgStyle = bgColor;\n    }\n\n    var card = document.createElement('div');\n    card.style.cssText = 'background: ' + bgStyle + '; border-radius: 6px; padding: ' + (isVertical ? '10px 8px' : '8px 12px') + '; color: white; box-shadow: 0 2px 6px rgba(0,0,0,0.12); width: fit-content;';\n\n    var titleEl = document.createElement('div');\n    titleEl.style.cssText = 'font-size: ' + (isVertical ? '11px' : '12px') + '; font-weight: 600; margin-bottom: 8px; opacity: 0.95;' + (isVertical ? ' text-align: center;' : '');\n    titleEl.textContent = seriesInfo.label + (unit ? ' (' + unit + ')' : '');\n    card.appendChild(titleEl);\n\n    var statsRow = document.createElement('div');\n    statsRow.style.cssText = 'display: flex; flex-wrap: wrap; gap: 6px;' + (isVertical ? ' flex-direction: column;' : '');\n\n    var statDefs = {\n        current: { label: 'Current', icon: 'â—', value: stats.current },\n        min: { label: 'Min', icon: 'â†“', value: stats.min },\n        max: { label: 'Max', icon: 'â†‘', value: stats.max },\n        mean: { label: 'Mean', icon: 'Î¼', value: stats.mean },\n        median: { label: 'Median', icon: '~', value: stats.median },\n        sum: { label: 'Sum', icon: 'Î£', value: stats.sum },\n        count: { label: 'Count', icon: 'n', value: stats.count }\n    };\n\n    legendValues.forEach(function(val) {\n        var def = statDefs[val];\n        if (def && def.value !== undefined && def.value !== null) {\n            var formattedVal = val === 'count' ? String(def.value) : formatUtils.value(def.value, dec);\n            var statBox = document.createElement('div');\n            statBox.style.cssText = 'background: rgba(255,255,255,0.18); border-radius: 4px; padding: ' + (isVertical ? '4px 6px' : '4px 8px') + ';' + (isVertical ? ' text-align: center;' : ' min-width: 60px;');\n            var labelEl = document.createElement('div');\n            labelEl.style.cssText = 'font-size: 9px; opacity: 0.85;';\n            labelEl.textContent = def.icon + ' ' + def.label;\n            statBox.appendChild(labelEl);\n            var valueEl = document.createElement('div');\n            valueEl.style.cssText = 'font-size: ' + (isVertical ? '12px' : '13px') + '; font-weight: 600;';\n            valueEl.textContent = formattedVal;\n            statBox.appendChild(valueEl);\n            statsRow.appendChild(statBox);\n        }\n    });\n\n    card.appendChild(statsRow);\n\n    if (config.showTimestamp && stats.lastTimestamp) {\n        var timestampEl = document.createElement('div');\n        timestampEl.style.cssText = 'font-size: 9px; opacity: 0.7; margin-top: 6px;' + (isVertical ? ' text-align: center;' : '');\n        timestampEl.textContent = formatUtils.timestamp(stats.lastTimestamp, config.timestampFormat);\n        card.appendChild(timestampEl);\n    }\n\n    return card;\n}\n\n// ========================================\n// Initialization\n// ========================================\nself.onInit = function() {\n    detectUserLanguage();\n\n    chartContainer = self.ctx.$container.find('#chart-container')[0];\n    timewindowContainer = self.ctx.$container.find('#timewindow-selector')[0];\n    statsCardContainers = {\n        top: self.ctx.$container.find('#stats-card-top')[0],\n        bottom: self.ctx.$container.find('#stats-card-bottom')[0],\n        left: self.ctx.$container.find('#stats-card-left')[0],\n        right: self.ctx.$container.find('#stats-card-right')[0]\n    };\n\n    if (!chartContainer) { console.error('ECO Timeseries: Chart container not found'); return; }\n    if (typeof echarts === 'undefined') { console.error('ECO Timeseries: ECharts not loaded'); return; }\n\n    chart = echarts.init(chartContainer);\n\n    fetchEntityAttributes(function() {\n        initTimewindowSelector();\n        updateChart();\n    });\n\n    [100, 250, 500, 1000].forEach(function(delay) {\n        setTimeout(function() {\n            if (chart && chartContainer) {\n                chart.resize({ width: chartContainer.offsetWidth, height: chartContainer.offsetHeight });\n            }\n        }, delay);\n    });\n\n    if (typeof ResizeObserver !== 'undefined') {\n        resizeObserver = new ResizeObserver(function() {\n            requestAnimationFrame(function() {\n                if (chart && chartContainer) {\n                    chart.resize({ width: chartContainer.offsetWidth, height: chartContainer.offsetHeight });\n                }\n            });\n        });\n        resizeObserver.observe(chartContainer);\n    }\n};\n\nself.onDataUpdated = function() {\n    updateChart();\n};\n\nself.onResize = function() {\n    if (chart && chartContainer) {\n        chart.resize({ width: chartContainer.offsetWidth, height: chartContainer.offsetHeight });\n    }\n};\n\nself.onDestroy = function() {\n    if (resizeObserver) { resizeObserver.disconnect(); resizeObserver = null; }\n    if (chart) { chart.dispose(); chart = null; }\n};\n\n// ========================================\n// Entity Attributes\n// ========================================\nfunction fetchEntityAttributes(callback) {\n    var settings = self.ctx.settings || {};\n    var attributesToFetch = [];\n    var settingsToCheck = [settings.twCustomStartTime, settings.twCustomEndTime];\n\n    settingsToCheck.forEach(function(val) {\n        if (val && typeof val === 'string') {\n            // Match ${attributeName} pattern\n            var match = val.match(/^\\$\\{(.+)\\}$/);\n            if (match && attributesToFetch.indexOf(match[1]) === -1) {\n                attributesToFetch.push(match[1]);\n            }\n        }\n    });\n\n    console.log('[TW Selector] Attributes to fetch:', attributesToFetch);\n\n    if (attributesToFetch.length === 0) { callback(); return; }\n    if (!self.ctx.datasources || self.ctx.datasources.length === 0) {\n        console.log('[TW Selector] No datasources available');\n        callback();\n        return;\n    }\n\n    var ds = self.ctx.datasources[0];\n    console.log('[TW Selector] Datasource entity:', ds.entity);\n\n    if (!ds.entity || !ds.entity.id) {\n        console.log('[TW Selector] No entity in datasource');\n        callback();\n        return;\n    }\n\n    var entityId = ds.entity.id.id;\n    var entityType = ds.entity.id.entityType;\n    var keysParam = attributesToFetch.join(',');\n\n    // Load both CLIENT_SCOPE and SERVER_SCOPE attributes\n    var loadedCount = 0;\n    var totalScopes = 2;\n\n    function checkComplete() {\n        loadedCount++;\n        if (loadedCount >= totalScopes) {\n            console.log('[TW Selector] All attributes loaded:', entityAttributes);\n            callback();\n        }\n    }\n\n    if (self.ctx.http) {\n        // Load SERVER_SCOPE attributes (where startTimeMs typically is)\n        var serverUrl = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/values/attributes/SERVER_SCOPE?keys=' + keysParam;\n        console.log('[TW Selector] Fetching SERVER_SCOPE:', serverUrl);\n        self.ctx.http.get(serverUrl).subscribe(\n            function(response) {\n                console.log('[TW Selector] SERVER_SCOPE response:', response);\n                if (response && Array.isArray(response)) {\n                    response.forEach(function(attr) { entityAttributes[attr.key] = attr.value; });\n                }\n                checkComplete();\n            },\n            function(error) {\n                console.warn('[TW Selector] Failed to fetch SERVER_SCOPE attributes', error);\n                checkComplete();\n            }\n        );\n\n        // Also load CLIENT_SCOPE attributes as fallback\n        var clientUrl = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/values/attributes/CLIENT_SCOPE?keys=' + keysParam;\n        self.ctx.http.get(clientUrl).subscribe(\n            function(response) {\n                if (response && Array.isArray(response)) {\n                    response.forEach(function(attr) {\n                        if (entityAttributes[attr.key] === undefined) {\n                            entityAttributes[attr.key] = attr.value;\n                        }\n                    });\n                }\n                checkComplete();\n            },\n            function(error) { checkComplete(); }\n        );\n    } else {\n        console.log('[TW Selector] No http service available');\n        callback();\n    }\n}\n\n// ========================================\n// Timewindow Selector\n// ========================================\nfunction initTimewindowSelector() {\n    var settings = self.ctx.settings || {};\n    twState.mode = settings.twSelectorDefaultMode || 'custom';\n    twState.currentDate = new Date();\n\n    console.log('[TW Selector] Init - mode:', twState.mode, 'twCustomStartTime:', settings.twCustomStartTime);\n    console.log('[TW Selector] Entity attributes loaded:', entityAttributes);\n\n    // Initialize custom mode\n    if (twState.mode === 'custom') {\n        if (settings.twCustomStartTime) {\n            // twCustomStartTime is configured (e.g., ${EPI_3_1}) - resolve it now\n            var startMs = resolveTimeValue(settings.twCustomStartTime);\n            var endMs = settings.twCustomEndTime ? resolveTimeValue(settings.twCustomEndTime) : Date.now();\n\n            console.log('[TW Selector] Resolved from settings - startMs:', startMs, 'endMs:', endMs);\n\n            if (startMs && startMs > 0) {\n                twState.customStart = startMs;\n                // Use endMs only if it's a valid positive timestamp, otherwise use now\n                twState.customEnd = (endMs && endMs > 0) ? endMs : Date.now();\n            } else {\n                // Fallback to today if attribute not found\n                var today = new Date();\n                today.setHours(0, 0, 0, 0);\n                twState.customStart = today.getTime();\n                twState.customEnd = Date.now();\n            }\n        } else {\n            // No configured start time - use current timewindow or default to today\n            var useDashboardTw = self.ctx.widget && self.ctx.widget.config ? self.ctx.widget.config.useDashboardTimewindow !== false : true;\n            var tw = useDashboardTw\n                ? (self.ctx.dashboard && self.ctx.dashboard.dashboardTimewindow)\n                : self.ctx.timeWindow;\n            var now = Date.now();\n\n            console.log('[TW Selector] Reading timewindow from:', useDashboardTw ? 'dashboard' : 'widget', tw);\n\n            if (tw && tw.fixedTimewindow && tw.fixedTimewindow.startTimeMs) {\n                twState.customStart = tw.fixedTimewindow.startTimeMs;\n                twState.customEnd = tw.fixedTimewindow.endTimeMs || now;\n            } else if (tw && tw.history && tw.history.fixedTimewindow && tw.history.fixedTimewindow.startTimeMs) {\n                twState.customStart = tw.history.fixedTimewindow.startTimeMs;\n                twState.customEnd = tw.history.fixedTimewindow.endTimeMs || now;\n            } else {\n                // Default to current day (start of day to now)\n                var today = new Date();\n                today.setHours(0, 0, 0, 0);\n                twState.customStart = today.getTime();\n                twState.customEnd = now;\n            }\n        }\n\n        console.log('[TW Selector] twState after init:', {\n            customStart: twState.customStart ? new Date(twState.customStart).toISOString() : null,\n            customEnd: twState.customEnd ? new Date(twState.customEnd).toISOString() : null\n        });\n\n        // Apply the timewindow\n        applyTimewindow();\n    }\n}\n\nfunction renderTimewindowSelector() {\n    if (!timewindowContainer) return;\n    var settings = self.ctx.settings || {};\n    var showSelector = settings.showTimewindowSelector === true;\n\n    if (!showSelector) { timewindowContainer.style.display = 'none'; return; }\n\n    while (timewindowContainer.firstChild) timewindowContainer.removeChild(timewindowContainer.firstChild);\n\n    var accentColor = settings.twSelectorColor || '#2196F3';\n    if (!settings.twSelectorColor && self.ctx.data && self.ctx.data[0] && self.ctx.data[0].dataKey) {\n        accentColor = self.ctx.data[0].dataKey.color || '#2196F3';\n    }\n\n    var positionMap = { left: 'flex-start', center: 'center', right: 'flex-end' };\n    var position = settings.twSelectorPosition || 'center';\n\n    timewindowContainer.style.display = 'flex';\n    timewindowContainer.style.alignItems = 'center';\n    timewindowContainer.style.justifyContent = positionMap[position] || 'center';\n    timewindowContainer.style.padding = '8px';\n\n    var wrapper = document.createElement('div');\n    wrapper.style.cssText = 'display: flex; align-items: center; gap: 6px; background: ' + accentColor + '; border-radius: 6px; padding: 6px 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.12);';\n\n    if (twState.mode !== 'custom') {\n        var navLeft = createButton('â—€', function() { navigate(-1); });\n        wrapper.appendChild(navLeft);\n    }\n\n    var btnContainer = document.createElement('div');\n    btnContainer.style.cssText = 'display: flex; gap: 4px;';\n\n    var modes = [\n        { id: 'day', label: 'D', title: t('day') },\n        { id: 'week', label: 'W', title: t('week') },\n        { id: 'month', label: 'M', title: t('month') },\n        { id: 'custom', label: 'C', title: t('custom') }\n    ];\n\n    modes.forEach(function(m) {\n        var isActive = twState.mode === m.id;\n        var btn = document.createElement('button');\n        btn.textContent = m.label;\n        btn.title = m.title;\n        btn.style.cssText = 'border: none; width: 28px; height: 24px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600; transition: all 0.2s;';\n        if (isActive) { btn.style.background = 'white'; btn.style.color = accentColor; }\n        else { btn.style.background = 'rgba(255,255,255,0.2)'; btn.style.color = 'white'; }\n        btn.onmouseover = function() { if (!isActive) btn.style.background = 'rgba(255,255,255,0.35)'; };\n        btn.onmouseout = function() { if (!isActive) btn.style.background = 'rgba(255,255,255,0.2)'; };\n        btn.onclick = function() { selectMode(m.id); };\n        btnContainer.appendChild(btn);\n    });\n\n    wrapper.appendChild(btnContainer);\n\n    if (twState.mode !== 'custom') {\n        var navRight = createButton('â–¶', function() { navigate(1); });\n        wrapper.appendChild(navRight);\n    }\n\n    var label = document.createElement('span');\n    label.style.cssText = 'color: white; font-size: 11px; margin-left: 8px; opacity: 0.9;';\n    label.textContent = formatLabel();\n    wrapper.appendChild(label);\n\n    if (twState.mode === 'custom') {\n        var calBtn = createButton('ðŸ“…', function(e) { e.stopPropagation(); showDatePicker(wrapper, accentColor); });\n        calBtn.title = t('selectPeriod');\n        calBtn.style.marginLeft = '4px';\n        wrapper.appendChild(calBtn);\n    }\n\n    timewindowContainer.appendChild(wrapper);\n}\n\nfunction createButton(text, onClick) {\n    var btn = document.createElement('button');\n    btn.textContent = text;\n    btn.style.cssText = 'background: rgba(255,255,255,0.2); border: none; color: white; width: 24px; height: 24px; border-radius: 4px; cursor: pointer; font-size: 10px; display: flex; align-items: center; justify-content: center; transition: background 0.2s;';\n    btn.onmouseover = function() { btn.style.background = 'rgba(255,255,255,0.35)'; };\n    btn.onmouseout = function() { btn.style.background = 'rgba(255,255,255,0.2)'; };\n    btn.onclick = onClick;\n    return btn;\n}\n\nfunction selectMode(mode) {\n    twState.mode = mode;\n    if (mode !== 'custom') { twState.currentDate = new Date(); twState.customStart = null; twState.customEnd = null; }\n    applyTimewindow();\n    renderTimewindowSelector();\n}\n\nfunction navigate(direction) {\n    var d = new Date(twState.currentDate);\n    switch (twState.mode) {\n        case 'day': d.setDate(d.getDate() + direction); break;\n        case 'week': d.setDate(d.getDate() + (direction * 7)); break;\n        case 'month': d.setMonth(d.getMonth() + direction); break;\n    }\n    twState.currentDate = d;\n    applyTimewindow();\n    renderTimewindowSelector();\n}\n\nfunction applyTimewindow() {\n    var settings = self.ctx.settings || {};\n\n    // Calculate the range\n    var range = calculateRange();\n    if (!range) {\n        console.log('[TW Selector] No range calculated');\n        return;\n    }\n\n    console.log('[TW Selector] Applying widget timewindow:', {\n        mode: twState.mode,\n        start: new Date(range.start).toISOString(),\n        end: new Date(range.end).toISOString()\n    });\n\n    // Update widget's timewindow - wrap in $$postDigest to avoid digest cycle conflict\n    if (self.ctx.timewindowFunctions && self.ctx.timewindowFunctions.onUpdateTimewindow) {\n        if (self.ctx.$scope && self.ctx.$scope.$$postDigest) {\n            self.ctx.$scope.$$postDigest(function() {\n                self.ctx.timewindowFunctions.onUpdateTimewindow(range.start, range.end);\n                console.log('[TW Selector] Widget timewindow updated via $$postDigest');\n            });\n        } else {\n            setTimeout(function() {\n                self.ctx.timewindowFunctions.onUpdateTimewindow(range.start, range.end);\n                console.log('[TW Selector] Widget timewindow updated via setTimeout');\n            }, 0);\n        }\n    }\n}\n\nfunction calculateRange() {\n    var settings = self.ctx.settings || {};\n    var d = new Date(twState.currentDate);\n    var start, end;\n    switch (twState.mode) {\n        case 'day':\n            start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);\n            end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999);\n            break;\n        case 'week':\n            var dayOfWeek = d.getDay();\n            var diffToMonday = (dayOfWeek === 0 ? -6 : 1) - dayOfWeek;\n            var monday = new Date(d);\n            monday.setDate(d.getDate() + diffToMonday);\n            start = new Date(monday.getFullYear(), monday.getMonth(), monday.getDate(), 0, 0, 0, 0);\n            var sunday = new Date(monday);\n            sunday.setDate(monday.getDate() + 6);\n            end = new Date(sunday.getFullYear(), sunday.getMonth(), sunday.getDate(), 23, 59, 59, 999);\n            break;\n        case 'month':\n            start = new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);\n            end = new Date(d.getFullYear(), d.getMonth() + 1, 0, 23, 59, 59, 999);\n            break;\n        case 'custom':\n            if (twState.customStart && twState.customEnd) {\n                return { start: twState.customStart, end: twState.customEnd };\n            }\n            // Fallback: try to resolve from settings if twState not set\n            if (settings.twCustomStartTime) {\n                var startMs = resolveTimeValue(settings.twCustomStartTime);\n                var endMs = settings.twCustomEndTime ? resolveTimeValue(settings.twCustomEndTime) : Date.now();\n                if (startMs) return { start: startMs, end: endMs || Date.now() };\n            }\n            // Last fallback: current day\n            var today = new Date();\n            today.setHours(0, 0, 0, 0);\n            return { start: today.getTime(), end: Date.now() };\n    }\n    return { start: start.getTime(), end: end.getTime() };\n}\n\nfunction resolveTimeValue(valueStr) {\n    if (!valueStr || valueStr === '') return null;\n\n    // Match ${attributeName} pattern\n    var varMatch = valueStr.match(/^\\$\\{(.+)\\}$/);\n    console.log('[TW Selector] resolveTimeValue:', valueStr, 'match:', varMatch);\n\n    if (varMatch) {\n        var attrName = varMatch[1];\n        console.log('[TW Selector] Looking for attribute:', attrName, 'in entityAttributes:', entityAttributes);\n\n        if (entityAttributes[attrName] !== undefined) {\n            var val = Number(entityAttributes[attrName]);\n            console.log('[TW Selector] Found in entityAttributes:', entityAttributes[attrName], '-> parsed:', val);\n            if (!isNaN(val) && val > 0) return val;\n        }\n        if (self.ctx.datasources && self.ctx.datasources[0]) {\n            var ds = self.ctx.datasources[0];\n            if (ds.entity && ds.entity.attributes && ds.entity.attributes[attrName] !== undefined) {\n                var val2 = Number(ds.entity.attributes[attrName]);\n                console.log('[TW Selector] Found in ds.entity.attributes:', ds.entity.attributes[attrName], '-> parsed:', val2);\n                if (!isNaN(val2) && val2 > 0) return val2;\n            }\n        }\n        if (self.ctx.latestData) {\n            for (var i = 0; i < self.ctx.latestData.length; i++) {\n                var ld = self.ctx.latestData[i];\n                if (ld.dataKey && ld.dataKey.name === attrName && ld.data && ld.data.length > 0) {\n                    var val3 = Number(ld.data[ld.data.length - 1][1]);\n                    console.log('[TW Selector] Found in latestData:', ld.data[ld.data.length - 1][1], '-> parsed:', val3);\n                    if (!isNaN(val3) && val3 > 0) return val3;\n                }\n            }\n        }\n        console.log('[TW Selector] Attribute not found:', attrName);\n        return null;\n    }\n    var numVal = Number(valueStr);\n    if (!isNaN(numVal) && numVal > 0) return numVal;\n    var dateVal = Date.parse(valueStr);\n    if (!isNaN(dateVal)) return dateVal;\n    return null;\n}\n\nfunction formatLabel() {\n    var settings = self.ctx.settings || {};\n    var d = twState.currentDate;\n    switch (twState.mode) {\n        case 'day': return formatUtils.date(d, settings.twSelectorDayFormat || 'DD.MM.YYYY');\n        case 'week':\n            var range = calculateRange();\n            if (range) {\n                var startD = new Date(range.start);\n                var endD = new Date(range.end);\n                var fmt = settings.twSelectorWeekFormat || 'DD.MM.YYYY - DD.MM.YYYY';\n                if (fmt.indexOf(' - ') !== -1) {\n                    var parts = fmt.split(' - ');\n                    return formatUtils.date(startD, parts[0]) + ' - ' + formatUtils.date(endD, parts[1] || parts[0]);\n                }\n                return formatUtils.date(startD, 'DD.MM.YYYY') + ' - ' + formatUtils.date(endD, 'DD.MM.YYYY');\n            }\n            return '';\n        case 'month': return formatUtils.date(d, settings.twSelectorMonthFormat || 'MMMM YYYY');\n        case 'custom':\n            if (twState.customStart && twState.customEnd) {\n                return formatUtils.date(new Date(twState.customStart), 'DD.MM.YY') + ' - ' + formatUtils.date(new Date(twState.customEnd), 'DD.MM.YY');\n            }\n            if (self.ctx.dashboard && self.ctx.dashboard.dashboardTimewindow) {\n                var tw = self.ctx.dashboard.dashboardTimewindow;\n                if (tw.history && tw.history.fixedTimewindow) {\n                    return formatUtils.date(new Date(tw.history.fixedTimewindow.startTimeMs), 'DD.MM.YY') + ' - ' + formatUtils.date(new Date(tw.history.fixedTimewindow.endTimeMs), 'DD.MM.YY');\n                }\n            }\n            return 'Dashboard';\n    }\n    return '';\n}\n\nfunction showDatePicker(anchor, accentColor) {\n    var existing = document.getElementById('eco-tw-datepicker');\n    if (existing) { existing.remove(); return; }\n\n    var startDate = new Date();\n    var endDate = new Date();\n    startDate.setDate(startDate.getDate() - 7);\n\n    if (twState.customStart && twState.customEnd) {\n        startDate = new Date(twState.customStart);\n        endDate = new Date(twState.customEnd);\n    } else if (self.ctx.dashboard && self.ctx.dashboard.dashboardTimewindow) {\n        var tw = self.ctx.dashboard.dashboardTimewindow;\n        if (tw.history && tw.history.fixedTimewindow) {\n            startDate = new Date(tw.history.fixedTimewindow.startTimeMs);\n            endDate = new Date(tw.history.fixedTimewindow.endTimeMs);\n        }\n    }\n\n    function toInputDate(d) {\n        return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');\n    }\n\n    var picker = document.createElement('div');\n    picker.id = 'eco-tw-datepicker';\n    picker.style.cssText = 'position: absolute; top: 100%; left: 50%; transform: translateX(-50%); margin-top: 4px; background: white; border-radius: 8px; padding: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.25); z-index: 10000; min-width: 280px;';\n\n    var title = document.createElement('div');\n    title.style.cssText = 'font-size: 12px; font-weight: 600; color: #333; margin-bottom: 10px;';\n    title.textContent = t('selectPeriod');\n    picker.appendChild(title);\n\n    var inputsRow = document.createElement('div');\n    inputsRow.style.cssText = 'display: flex; gap: 8px;';\n\n    var startDiv = document.createElement('div');\n    startDiv.style.cssText = 'flex: 1;';\n    var startLabel = document.createElement('label');\n    startLabel.style.cssText = 'font-size: 10px; color: #666; display: block; margin-bottom: 2px;';\n    startLabel.textContent = t('from');\n    var startInput = document.createElement('input');\n    startInput.type = 'date';\n    startInput.value = toInputDate(startDate);\n    startInput.style.cssText = 'width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; box-sizing: border-box;';\n    startDiv.appendChild(startLabel);\n    startDiv.appendChild(startInput);\n    inputsRow.appendChild(startDiv);\n\n    var endDiv = document.createElement('div');\n    endDiv.style.cssText = 'flex: 1;';\n    var endLabel = document.createElement('label');\n    endLabel.style.cssText = 'font-size: 10px; color: #666; display: block; margin-bottom: 2px;';\n    endLabel.textContent = t('to');\n    var endInput = document.createElement('input');\n    endInput.type = 'date';\n    endInput.value = toInputDate(endDate);\n    endInput.style.cssText = 'width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; box-sizing: border-box;';\n    endDiv.appendChild(endLabel);\n    endDiv.appendChild(endInput);\n    inputsRow.appendChild(endDiv);\n\n    picker.appendChild(inputsRow);\n\n    var btnRow = document.createElement('div');\n    btnRow.style.cssText = 'display: flex; gap: 6px; justify-content: flex-end; margin-top: 10px;';\n\n    var cancelBtn = document.createElement('button');\n    cancelBtn.textContent = t('cancel');\n    cancelBtn.style.cssText = 'padding: 6px 12px; border: 1px solid #ddd; background: white; border-radius: 4px; font-size: 11px; cursor: pointer;';\n    cancelBtn.onclick = function(e) { e.stopPropagation(); picker.remove(); };\n\n    var applyBtn = document.createElement('button');\n    applyBtn.textContent = t('apply');\n    applyBtn.style.cssText = 'padding: 6px 12px; border: none; background: ' + accentColor + '; color: white; border-radius: 4px; font-size: 11px; cursor: pointer; font-weight: 500;';\n    applyBtn.onclick = function(e) {\n        e.stopPropagation();\n        var newStart = new Date(startInput.value);\n        var newEnd = new Date(endInput.value);\n        newEnd.setHours(23, 59, 59, 999);\n        twState.customStart = newStart.getTime();\n        twState.customEnd = newEnd.getTime();\n        applyTimewindow();\n        picker.remove();\n        renderTimewindowSelector();\n    };\n\n    btnRow.appendChild(cancelBtn);\n    btnRow.appendChild(applyBtn);\n    picker.appendChild(btnRow);\n\n    anchor.style.position = 'relative';\n    anchor.appendChild(picker);\n\n    setTimeout(function() {\n        document.addEventListener('click', function closeHandler(e) {\n            if (!picker.contains(e.target)) { picker.remove(); document.removeEventListener('click', closeHandler); }\n        });\n    }, 100);\n}\n\n// ========================================\n// Chart Update - Main Function\n// ========================================\nfunction updateChart() {\n    if (!chart) return;\n\n    // ALWAYS clear stats cards at start - ensures clean state\n    ['top', 'bottom', 'left', 'right'].forEach(function(pos) {\n        var container = statsCardContainers[pos];\n        if (container) {\n            container.style.display = 'none';\n            while (container.firstChild) container.removeChild(container.firstChild);\n        }\n    });\n\n    var settings = migrateSettings(self.ctx.settings || {});\n    var data = self.ctx.data || [];\n\n    renderTimewindowSelector();\n\n    // Display settings\n    var displayMode = settings.displayMode || 'stacked'; // 'single' or 'stacked'\n    var chartType = settings.chartType || 'line';\n    var smoothLine = settings.smoothLine !== false;\n    var showDataZoomSlider = settings.showDataZoomSlider !== false;\n    var showToolbox = settings.showToolbox !== false;\n    var toolboxFeatures = settings.toolboxFeatures || ['saveAsImage', 'dataView', 'dataZoom', 'restore'];\n    var lineWidth = settings.lineWidth || 2;\n    var showArea = settings.showArea === true;\n    var areaOpacity = settings.areaOpacity || 0.3;\n\n    // Data processing\n    var removeOutliers = settings.removeOutliers === true;\n    var outlierMethod = settings.outlierMethod || 'iqr';\n    var smoothingEnabled = settings.smoothingEnabled === true;\n    var smoothingWindowMinutes = settings.smoothingWindowMinutes || 15;\n\n    if (!data.length) { showNoData('No data available'); return; }\n\n\n    // Process all series\n    var seriesConfigs = [];\n    var allStatsForCard = [];\n    var defaultColors = ['#2196F3', '#4CAF50', '#FF9800', '#E91E63', '#9C27B0', '#00BCD4', '#795548', '#607D8B'];\n\n    for (var i = 0; i < data.length; i++) {\n        var ds = data[i];\n        var dsLabel = (ds.dataKey && ds.dataKey.label) || 'ds' + i;\n        if (!ds.data || !ds.data.length) {\n            continue;\n        }\n\n        var dataKey = ds.dataKey || {};\n        var label = dataKey.label || dataKey.name || 'Series ' + (i + 1);\n        var color = dataKey.color || defaultColors[i % defaultColors.length];\n        var units = dataKey.units || '';\n        var decimals = dataKey.decimals !== undefined ? dataKey.decimals : 2;\n\n        var timestamps = [];\n        var values = [];\n        for (var j = 0; j < ds.data.length; j++) {\n            var ts = ds.data[j][0];\n            var val = ds.data[j][1];\n            // Convert to number (handles strings like \"54.0\")\n            var numVal = Number(val);\n            if (val !== null && val !== undefined && !isNaN(numVal) && isFinite(numVal)) {\n                timestamps.push(ts);\n                values.push(numVal);\n            }\n        }\n\n        if (values.length === 0) continue;\n\n        // Apply data processing\n        if (removeOutliers) {\n            var outlierResult = dataProcessingUtils.removeOutliers(values, timestamps, {\n                method: outlierMethod,\n                iqrMultiplier: settings.outlierIqrMultiplier || 1.5,\n                zscoreThreshold: settings.outlierZscoreThreshold || 3,\n                minValue: settings.outlierMinValue,\n                maxValue: settings.outlierMaxValue\n            });\n            values = outlierResult.values;\n            timestamps = outlierResult.timestamps;\n        }\n\n        if (smoothingEnabled && values.length > 1) {\n            var windowSize = dataProcessingUtils.getWindowSizeFromMinutes(timestamps, smoothingWindowMinutes);\n            values = dataProcessingUtils.movingAverage(values, windowSize);\n        }\n\n        var seriesData = [];\n        for (var k = 0; k < values.length; k++) {\n            seriesData.push([timestamps[k], values[k]]);\n        }\n\n        var stats = statsUtils.calculate(values);\n        stats.lastTimestamp = timestamps.length > 0 ? timestamps[timestamps.length - 1] : null;\n\n        // Get chart assignments and Y-axis settings from data key settings\n        var dkSettings = migrateDataKeySettings(dataKey.settings || {});\n        var chartIndex = dkSettings.chartIndex || 0;\n        var chartsAssignment = dkSettings.chartsAssignment || (chartIndex > 0 ? [chartIndex] : [1]);\n        var yAxisMin = dkSettings.yAxisMin;\n        var yAxisMax = dkSettings.yAxisMax;\n\n        seriesConfigs.push({\n            label: label,\n            color: color,\n            units: units,\n            decimals: decimals,\n            data: seriesData,\n            stats: stats,\n            chartIndex: chartIndex,\n            chartsAssignment: chartsAssignment,\n            yAxisMin: yAxisMin,\n            yAxisMax: yAxisMax\n        });\n\n        allStatsForCard.push({\n            label: label,\n            color: color,\n            units: units,\n            decimals: decimals,\n            stats: stats\n        });\n    }\n\n    if (seriesConfigs.length === 0) { showNoData('No valid data'); return; }\n\n\n    // Render stats card\n    renderStatsCard({\n        showLegend: settings.showLegend,\n        legendStyle: settings.legendStyle,\n        legendPosition: settings.legendPosition,\n        legendAlign: settings.legendAlign,\n        legendCardColorMode: settings.legendCardColorMode,\n        legendCardColor: settings.legendCardColor,\n        legendValues: settings.legendValues,\n        showTimestamp: settings.showTimestamp,\n        timestampFormat: settings.timestampFormat,\n        allStats: allStatsForCard\n    });\n\n    // Build ECharts option based on display mode\n    var option;\n    if (displayMode === 'stacked' && seriesConfigs.length > 1) {\n        option = buildStackedOption(seriesConfigs, settings, chartType, smoothLine, showDataZoomSlider, showToolbox, toolboxFeatures, lineWidth, showArea, areaOpacity);\n    } else {\n        option = buildSingleOption(seriesConfigs, settings, chartType, smoothLine, showDataZoomSlider, showToolbox, toolboxFeatures, lineWidth, showArea, areaOpacity);\n    }\n\n    // Ensure any leftover 'No valid data' title is cleared\n    if (!option.title) option.title = { show: false };\n\n    chart.setOption(option, true);\n\n    setTimeout(function() {\n        if (chart && chartContainer) {\n            chart.resize({ width: chartContainer.offsetWidth, height: chartContainer.offsetHeight });\n        }\n    }, 100);\n}\n\n// ========================================\n// Single Chart Mode\n// ========================================\nfunction buildSingleOption(seriesConfigs, settings, chartType, smoothLine, showDataZoomSlider, showToolbox, toolboxFeatures, lineWidth, showArea, areaOpacity) {\n    var series = seriesConfigs.map(function(sc) {\n        var s = {\n            name: sc.label,\n            type: chartType === 'bar' ? 'bar' : 'line',\n            data: sc.data,\n            smooth: smoothLine && chartType !== 'bar',\n            symbol: 'none',\n            lineStyle: { color: sc.color, width: lineWidth },\n            itemStyle: { color: sc.color }\n        };\n        if (showArea || chartType === 'area') {\n            s.areaStyle = { color: sc.color, opacity: areaOpacity };\n        }\n        return s;\n    });\n\n    var legendData = seriesConfigs.map(function(s) { return s.label; });\n    var showClassicLegend = settings.showLegend && settings.legendStyle !== 'card';\n\n    return {\n        tooltip: {\n            trigger: 'axis',\n            formatter: function(params) {\n                if (!params || !params.length) return '';\n                var d = new Date(params[0].value[0]);\n                var result = d.toLocaleString() + '<br/>';\n                params.forEach(function(p) {\n                    if (p.value && p.value[1] !== null) {\n                        var sc = seriesConfigs.find(function(s) { return s.label === p.seriesName; });\n                        var dec = sc ? sc.decimals : 2;\n                        var unit = sc ? sc.units : '';\n                        result += '<span style=\"display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + p.color + ';\"></span>';\n                        result += p.seriesName + ': ' + formatUtils.value(p.value[1], dec) + (unit ? ' ' + unit : '') + '<br/>';\n                    }\n                });\n                return result;\n            }\n        },\n        legend: showClassicLegend ? { data: legendData, bottom: showDataZoomSlider ? 30 : 5 } : { show: false },\n        grid: { left: 60, right: 20, top: 40, bottom: showDataZoomSlider ? 60 : 40 },\n        xAxis: { type: 'time', axisLabel: { fontSize: 10 } },\n        yAxis: { type: 'value', axisLabel: { fontSize: 10 } },\n        dataZoom: showDataZoomSlider ? [{ type: 'inside' }, { type: 'slider', bottom: 8, height: 20 }] : [{ type: 'inside' }],\n        toolbox: showToolbox ? {\n            show: true, right: 10, top: 5,\n            feature: {\n                saveAsImage: toolboxFeatures.indexOf('saveAsImage') !== -1 ? { show: true } : undefined,\n                dataZoom: toolboxFeatures.indexOf('dataZoom') !== -1 ? { show: true } : undefined,\n                restore: toolboxFeatures.indexOf('restore') !== -1 ? { show: true } : undefined\n            }\n        } : null,\n        series: series\n    };\n}\n\n// ========================================\n// Stacked Charts Mode (Multi-Grid) - New Chart-Centric Configuration\n// ========================================\nfunction buildStackedOption(seriesConfigs, settings, chartType, smoothLine, showDataZoomSlider, showToolbox, toolboxFeatures, lineWidth, showArea, areaOpacity) {\n    var charts = [];\n    if (settings.chart1Enabled) charts.push({ chartNum: 1, title: settings.chart1Title || '', chartType: settings.chart1Type || 'line', heightPercent: settings.chart1Height || 0 });\n    if (settings.chart2Enabled) charts.push({ chartNum: 2, title: settings.chart2Title || '', chartType: settings.chart2Type || 'line', heightPercent: settings.chart2Height || 0 });\n    if (settings.chart3Enabled) charts.push({ chartNum: 3, title: settings.chart3Title || '', chartType: settings.chart3Type || 'line', heightPercent: settings.chart3Height || 0 });\n    if (settings.chart4Enabled) charts.push({ chartNum: 4, title: settings.chart4Title || '', chartType: settings.chart4Type || 'line', heightPercent: settings.chart4Height || 0 });\n    var chartSpacing = settings.chartSpacing !== undefined ? settings.chartSpacing : 2;\n    var topMargin = settings.chartTopMargin !== undefined ? settings.chartTopMargin : 5;\n    var sliderAreaPercent = showDataZoomSlider ? 10 : 0;  // 10% for slider area (slider + x-axis labels)\n    var chartGap = settings.chartBottomMargin !== undefined ? settings.chartBottomMargin : 3;\n    var bottomMargin = chartGap + sliderAreaPercent;\n\n    // If no charts defined, fall back to auto-mode (one chart per series)\n    if (charts.length === 0) {\n        return buildAutoStackedOption(seriesConfigs, settings, chartType, smoothLine, showDataZoomSlider, showToolbox, toolboxFeatures, lineWidth, showArea, areaOpacity);\n    }\n\n    // Build chart data structure\n    var chartDataList = [];\n\n    charts.forEach(function(chartConfig, chartIndex) {\n        var chartNum = chartConfig.chartNum; // Use stored chartNum from fixed slot\n\n        // Find series assigned to this chart (support both old chartIndex and new chartsAssignment)\n        var assignedSeries = seriesConfigs.filter(function(sc) {\n            // Check chartsAssignment array first\n            if (sc.chartsAssignment && Array.isArray(sc.chartsAssignment) && sc.chartsAssignment.length > 0) {\n                return sc.chartsAssignment.indexOf(chartNum) !== -1;\n            }\n            // Fall back to old chartIndex for backward compatibility\n            if (sc.chartIndex !== undefined && sc.chartIndex > 0) {\n                return sc.chartIndex === chartNum;\n            }\n            // Default: assign to Chart 1\n            return chartNum === 1;\n        });\n\n        if (assignedSeries.length === 0) return; // Skip empty charts\n\n        // Auto-create Y-axes based on units\n        var unitGroups = {};\n        assignedSeries.forEach(function(sc) {\n            var unit = (sc.units || '').trim();\n            if (!unitGroups[unit]) unitGroups[unit] = [];\n            unitGroups[unit].push(sc);\n        });\n\n        var unitKeys = Object.keys(unitGroups);\n        var yAxesConfig = [];\n\n        unitKeys.forEach(function(unit, unitIndex) {\n            var axisSeries = unitGroups[unit];\n            var position = unitIndex === 0 ? 'left' : 'right';\n\n            // Combine labels (comma-separated to avoid ECharts truncation)\n            var labels = axisSeries.map(function(sc) { return sc.label; });\n            var combinedLabel = labels.join(', ');\n\n            // Calculate auto min/max from series data with padding\n            var allValues = [];\n            var hasMinOverride = false, hasMaxOverride = false;\n            var minOverride, maxOverride;\n            axisSeries.forEach(function(sc) {\n                sc.data.forEach(function(d) { if (d[1] !== null) allValues.push(d[1]); });\n                if (sc.yAxisMin !== undefined && sc.yAxisMin !== null && sc.yAxisMin !== '') {\n                    hasMinOverride = true;\n                    minOverride = minOverride !== undefined ? Math.min(minOverride, sc.yAxisMin) : sc.yAxisMin;\n                }\n                if (sc.yAxisMax !== undefined && sc.yAxisMax !== null && sc.yAxisMax !== '') {\n                    hasMaxOverride = true;\n                    maxOverride = maxOverride !== undefined ? Math.max(maxOverride, sc.yAxisMax) : sc.yAxisMax;\n                }\n            });\n\n            // Auto-scale: calculate nice axis bounds (rounded to clean numbers)\n            var autoMin, autoMax;\n            if (allValues.length > 0) {\n                // Use loop instead of Math.min/max.apply to avoid stack overflow with large arrays\n                var dataMin = allValues[0];\n                var dataMax = allValues[0];\n                for (var vi = 1; vi < allValues.length; vi++) {\n                    if (allValues[vi] < dataMin) dataMin = allValues[vi];\n                    if (allValues[vi] > dataMax) dataMax = allValues[vi];\n                }\n                // Calculate nice rounded axis bounds\n                var niceBounds = axisUtils.niceAxisBounds(dataMin, dataMax);\n                autoMin = niceBounds.min;\n                autoMax = niceBounds.max;\n            }\n\n            yAxesConfig.push({\n                position: position,\n                // Note: label is built dynamically from series in Y-axis rendering\n                labelFontSize: settings.axisLabelFontSize || 11,\n                labelOpacity: 1,\n                tickFontSize: settings.axisTickFontSize || 10,\n                tickOpacity: 1,\n                tickColor: settings.axisLabelColor || '#666',\n                labelColor: settings.axisLabelColor || '#666',\n                unit: unit,\n                min: hasMinOverride ? minOverride : autoMin,\n                max: hasMaxOverride ? maxOverride : autoMax,\n                series: axisSeries\n            });\n        });\n\n        chartDataList.push({\n            config: chartConfig,\n            yAxes: yAxesConfig,\n            heightPercent: chartConfig.heightPercent || null\n        });\n    });\n\n    if (chartDataList.length === 0) {\n        return buildAutoStackedOption(seriesConfigs, settings, chartType, smoothLine, showDataZoomSlider, showToolbox, toolboxFeatures, lineWidth, showArea, areaOpacity);\n    }\n\n    var numCharts = chartDataList.length;\n\n    // Calculate uniform grid margins across all charts\n    // This ensures all charts have the same data area width regardless of Y-axis count\n    var maxLeftAxes = 0;\n    var maxRightAxes = 0;\n    var maxLeftLabelLines = 1;  // Max number of label lines on left Y-axis\n    var maxRightLabelLines = 1; // Max number of label lines on right Y-axis\n    var anyChartHasRightAxis = false;\n\n    chartDataList.forEach(function(cd) {\n        var chartNum = cd.config.chartNum;\n        var yAxesWithData = cd.yAxes.filter(function(ya) { return ya.series.length > 0; });\n        var leftAxes = yAxesWithData.filter(function(ya) { return ya.position === 'left'; });\n        var rightAxes = yAxesWithData.filter(function(ya) { return ya.position === 'right'; });\n\n        if (leftAxes.length > maxLeftAxes) maxLeftAxes = leftAxes.length;\n        if (rightAxes.length > maxRightAxes) maxRightAxes = rightAxes.length;\n        if (rightAxes.length > 0) anyChartHasRightAxis = true;\n\n        // Count label lines - check if manual title is set (single line) or auto (multi-line)\n        leftAxes.forEach(function(ya) {\n            var manualTitle = settings['chart' + chartNum + 'YAxisLeftTitle'];\n            var lineCount = (manualTitle && manualTitle.trim() !== '') ? 1 : ya.series.length;\n            if (lineCount > maxLeftLabelLines) maxLeftLabelLines = lineCount;\n        });\n        rightAxes.forEach(function(ya) {\n            var manualTitle = settings['chart' + chartNum + 'YAxisRightTitle'];\n            var lineCount = (manualTitle && manualTitle.trim() !== '') ? 1 : ya.series.length;\n            if (lineCount > maxRightLabelLines) maxRightLabelLines = lineCount;\n        });\n    });\n\n    // Fixed nameGap of 35px - labels handle their own positioning\n    var baseNameGap = 35;\n\n    // Extra space for multi-line labels (rotated text: each line adds ~14px horizontal space)\n    var leftLabelExtra = (maxLeftLabelLines - 1) * 14;\n    var rightLabelExtra = (maxRightLabelLines - 1) * 14;\n\n    // Total margin: tick labels (25px) + nameGap (35px) + extra for label lines + extra for multiple axes\n    var uniformGridLeft = 25 + baseNameGap + leftLabelExtra + (maxLeftAxes > 1 ? (maxLeftAxes - 1) * 50 : 0);\n    var uniformGridRight = 20 + (anyChartHasRightAxis ? baseNameGap + rightLabelExtra : 0) + (maxRightAxes > 1 ? (maxRightAxes - 1) * 50 : 0);\n\n    // Calculate chart heights\n    var totalHeightPercent = 100 - topMargin - bottomMargin - (chartSpacing * (numCharts - 1));\n    var totalCustomHeight = 0;\n    var chartsWithCustomHeight = 0;\n\n    chartDataList.forEach(function(cd) {\n        if (cd.heightPercent && cd.heightPercent > 0) {\n            totalCustomHeight += cd.heightPercent;\n            chartsWithCustomHeight++;\n        }\n    });\n\n    var remainingHeight = totalHeightPercent - totalCustomHeight;\n    var defaultHeight = (numCharts - chartsWithCustomHeight) > 0\n        ? remainingHeight / (numCharts - chartsWithCustomHeight)\n        : totalHeightPercent / numCharts;\n\n    // Build ECharts option\n    var grids = [];\n    var xAxes = [];\n    var yAxes = [];\n    var series = [];\n    var titles = [];\n    var currentTop = topMargin;\n    var yAxisCounter = 0;\n\n    chartDataList.forEach(function(chartData, gridIndex) {\n        var config = chartData.config;\n        var chartHeight = chartData.heightPercent || defaultHeight;\n        var thisChartType = config.chartType || chartType;\n        var chartTitle = config.title || '';\n\n        // Count Y-axes with data for this chart\n        var yAxesWithData = chartData.yAxes.filter(function(ya) { return ya.series.length > 0; });\n        var hasRightAxis = yAxesWithData.some(function(ya) { return ya.position === 'right'; });\n\n        // Calculate max lines in left Y-axis for title positioning\n        var maxLeftAxisLines = 1;\n        yAxesWithData.filter(function(ya) { return ya.position === 'left'; }).forEach(function(ya) {\n            if (ya.series.length > maxLeftAxisLines) maxLeftAxisLines = ya.series.length;\n        });\n\n        // Dynamic title left position: base + extra space for multi-line labels\n        var titleLeftPos = uniformGridLeft + 5;\n\n        // Add title with custom styling\n        if (chartTitle) {\n            titles.push({\n                text: chartTitle,\n                left: titleLeftPos,\n                top: currentTop + '%',\n                textStyle: { fontSize: settings.chartTitleFontSize || 12, color: settings.chartTitleColor || '#666666', opacity: settings.chartTitleOpacity !== undefined ? settings.chartTitleOpacity : 1 }\n            });\n        }\n\n        // Grid - use uniform margins for consistent data area width across all charts\n        grids.push({\n            left: uniformGridLeft,\n            right: uniformGridRight,\n            top: (currentTop + (chartTitle ? 2.5 : 0)) + '%',\n            height: (chartHeight - (chartTitle ? 2.5 : 0)) + '%'\n        });\n\n        // X-Axis\n        xAxes.push({\n            type: 'time',\n            gridIndex: gridIndex,\n            axisLabel: { show: gridIndex === numCharts - 1, fontSize: 10 },\n            axisTick: { show: gridIndex === numCharts - 1 },\n            axisLine: { show: true },\n            splitLine: { show: false }\n        });\n\n        // Y-Axes for this chart\n        var chartYAxisStartIndex = yAxisCounter;\n\n        yAxesWithData.forEach(function(yAxisConfig, localYAxisIndex) {\n            // Check for manual Y-axis title and gap override\n            var chartNum = config.chartNum;\n            var positionSuffix = yAxisConfig.position === 'left' ? 'Left' : 'Right';\n            var manualTitleKey = 'chart' + chartNum + 'YAxis' + positionSuffix + 'Title';\n            var manualGapKey = 'chart' + chartNum + 'YAxis' + positionSuffix + 'Gap';\n            var manualTitle = settings[manualTitleKey];\n            var manualGap = settings[manualGapKey];\n\n            var axisName;\n            var lineCount = 1;\n\n            if (manualTitle && manualTitle.trim() !== '') {\n                // Use manual title (single line)\n                axisName = manualTitle.trim();\n            } else {\n                // Auto-generate from series labels: each series with its own unit, line break only for 2+ series\n                var seriesLabelsWithUnits = yAxisConfig.series.map(function(s) {\n                    if (!s.label) return '';\n                    return s.label + (s.units ? ' (' + s.units + ')' : '');\n                }).filter(function(label) {\n                    return label && label.trim() !== '';\n                });\n                lineCount = seriesLabelsWithUnits.length || 1;\n\n                // Join series labels - line break for multiple series, single line for one\n                if (seriesLabelsWithUnits.length > 1) {\n                    axisName = seriesLabelsWithUnits.join('\\n');\n                } else {\n                    axisName = seriesLabelsWithUnits[0] || '';\n                }\n\n                // Remove any double newlines that might have been created\n                axisName = axisName.replace(/\\n\\n+/g, '\\n');\n            }\n\n            // Use manual gap if set, otherwise fixed base of 35px\n            var dynamicNameGap = (manualGap && manualGap > 0) ? manualGap : 35;\n\n            var yAxis = {\n                type: 'value',\n                gridIndex: gridIndex,\n                position: yAxisConfig.position,\n                name: axisName,\n                nameLocation: 'middle',\n                nameGap: dynamicNameGap,\n                nameTextStyle: { fontSize: yAxisConfig.labelFontSize || 11, color: yAxisConfig.labelColor || '#666', opacity: yAxisConfig.labelOpacity !== undefined ? yAxisConfig.labelOpacity : 1 },\n                axisLabel: { fontSize: yAxisConfig.tickFontSize || 11, color: yAxisConfig.tickColor || '#666', opacity: yAxisConfig.tickOpacity !== undefined ? yAxisConfig.tickOpacity : 1 },\n                splitLine: { show: localYAxisIndex === 0, lineStyle: { type: 'dashed', opacity: 0.3 } }\n            };\n\n            if (yAxisConfig.offset) yAxis.offset = yAxisConfig.offset;\n            if (yAxisConfig.min !== undefined && yAxisConfig.min !== null && yAxisConfig.min !== '') yAxis.min = yAxisConfig.min;\n            if (yAxisConfig.max !== undefined && yAxisConfig.max !== null && yAxisConfig.max !== '') yAxis.max = yAxisConfig.max;\n\n            yAxes.push(yAxis);\n\n            // Add series for this Y-axis\n            yAxisConfig.series.forEach(function(sc) {\n                var seriesItem = {\n                    name: sc.label,\n                    type: thisChartType === 'bar' ? 'bar' : 'line',\n                    xAxisIndex: gridIndex,\n                    yAxisIndex: yAxisCounter,\n                    data: sc.data,\n                    smooth: smoothLine && thisChartType !== 'bar',\n                    symbol: 'none',\n                    lineStyle: { color: sc.color, width: lineWidth },\n                    itemStyle: { color: sc.color }\n                };\n\n                if (showArea || thisChartType === 'area') {\n                    seriesItem.areaStyle = { color: sc.color, opacity: areaOpacity };\n                }\n\n                series.push(seriesItem);\n            });\n\n            yAxisCounter++;\n        });\n\n        currentTop += chartHeight + chartSpacing;\n    });\n\n    // DataZoom\n    var xAxisIndices = [];\n    for (var j = 0; j < numCharts; j++) xAxisIndices.push(j);\n\n    var dataZoom = [{ type: 'inside', xAxisIndex: xAxisIndices }];\n    if (showDataZoomSlider) {\n        dataZoom.push({ type: 'slider', xAxisIndex: xAxisIndices, bottom: 8, height: 20 });\n    }\n\n    var option = {\n        tooltip: {\n            trigger: 'axis',\n            axisPointer: { type: 'line', link: { xAxisIndex: 'all' } },\n            formatter: function(params) {\n                if (!params || !params.length) return '';\n                var d = new Date(params[0].value[0]);\n                var result = d.toLocaleString() + '<br/>';\n                params.forEach(function(p) {\n                    if (p.value && p.value[1] !== null) {\n                        var sc = seriesConfigs.find(function(s) { return s.label === p.seriesName; });\n                        var dec = sc ? sc.decimals : 2;\n                        var unit = sc ? sc.units : '';\n                        result += '<span style=\"display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + p.color + ';\"></span>';\n                        result += p.seriesName + ': ' + formatUtils.value(p.value[1], dec) + (unit ? ' ' + unit : '') + '<br/>';\n                    }\n                });\n                return result;\n            }\n        },\n        axisPointer: { link: { xAxisIndex: 'all' } },\n        grid: grids,\n        xAxis: xAxes,\n        yAxis: yAxes,\n        dataZoom: dataZoom,\n        toolbox: showToolbox ? {\n            show: true, right: 10, top: 5,\n            feature: {\n                saveAsImage: toolboxFeatures.indexOf('saveAsImage') !== -1 ? { show: true } : undefined,\n                dataZoom: toolboxFeatures.indexOf('dataZoom') !== -1 ? { show: true } : undefined,\n                restore: toolboxFeatures.indexOf('restore') !== -1 ? { show: true } : undefined\n            }\n        } : null,\n        series: series\n    };\n\n    if (titles.length > 0) option.title = titles;\n\n    return option;\n}\n\n// Auto-assign Y-axis based on unit matching\nfunction autoAssignYAxis(seriesConfig, yAxesConfig) {\n    var seriesUnit = (seriesConfig.units || '').toLowerCase().trim();\n\n    // Try to find matching unit\n    for (var i = 0; i < yAxesConfig.length; i++) {\n        var axisUnit = (yAxesConfig[i].unit || '').toLowerCase().trim();\n        if (axisUnit && seriesUnit && axisUnit === seriesUnit) {\n            return i;\n        }\n    }\n\n    // No match - find first axis with matching unit from already assigned series\n    for (var j = 0; j < yAxesConfig.length; j++) {\n        var existingSeries = yAxesConfig[j].series;\n        for (var k = 0; k < existingSeries.length; k++) {\n            var existingUnit = (existingSeries[k].units || '').toLowerCase().trim();\n            if (existingUnit && seriesUnit && existingUnit === seriesUnit) {\n                return j;\n            }\n        }\n    }\n\n    // Still no match - find first empty axis or first axis\n    for (var m = 0; m < yAxesConfig.length; m++) {\n        if (yAxesConfig[m].series.length === 0) {\n            return m;\n        }\n    }\n\n    return 0; // Default to first axis\n}\n\n// Fallback: Auto-stacked mode (one chart per series, like old behavior)\nfunction buildAutoStackedOption(seriesConfigs, settings, chartType, smoothLine, showDataZoomSlider, showToolbox, toolboxFeatures, lineWidth, showArea, areaOpacity) {\n    var chartSpacing = settings.chartSpacing !== undefined ? settings.chartSpacing : 2;\n    var topMargin = settings.chartTopMargin !== undefined ? settings.chartTopMargin : 5;\n    var sliderAreaPercent = showDataZoomSlider ? 10 : 0;  // 10% for slider area (slider + x-axis labels)\n    var chartGap = settings.chartBottomMargin !== undefined ? settings.chartBottomMargin : 3;\n    var bottomMargin = chartGap + sliderAreaPercent;\n\n    var numCharts = seriesConfigs.length;\n    if (numCharts === 0) return buildSingleOption(seriesConfigs, settings, chartType, smoothLine, showDataZoomSlider, showToolbox, toolboxFeatures, lineWidth, showArea, areaOpacity);\n\n    var totalHeightPercent = 100 - topMargin - bottomMargin - (chartSpacing * (numCharts - 1));\n    var chartHeight = totalHeightPercent / numCharts;\n\n    var grids = [];\n    var xAxes = [];\n    var yAxes = [];\n    var series = [];\n    var currentTop = topMargin;\n\n    seriesConfigs.forEach(function(sc, i) {\n        grids.push({\n            left: 60, right: 20,\n            top: currentTop + '%',\n            height: chartHeight + '%'\n        });\n\n        xAxes.push({\n            type: 'time', gridIndex: i,\n            axisLabel: { show: i === numCharts - 1, fontSize: 10 },\n            axisTick: { show: i === numCharts - 1 },\n            axisLine: { show: true },\n            splitLine: { show: false }\n        });\n\n        yAxes.push({\n            type: 'value', gridIndex: i,\n            name: sc.label + (sc.units ? ' (' + sc.units + ')' : ''),\n            nameLocation: 'middle', nameGap: 45,\n            nameTextStyle: { fontSize: 9, color: sc.color },\n            axisLabel: { fontSize: 9 },\n            splitLine: { lineStyle: { type: 'dashed', opacity: 0.3 } }\n        });\n\n        var seriesItem = {\n            name: sc.label,\n            type: chartType === 'bar' ? 'bar' : 'line',\n            xAxisIndex: i, yAxisIndex: i,\n            data: sc.data,\n            smooth: smoothLine && chartType !== 'bar',\n            symbol: 'none',\n            lineStyle: { color: sc.color, width: lineWidth },\n            itemStyle: { color: sc.color }\n        };\n\n        if (showArea || chartType === 'area') {\n            seriesItem.areaStyle = { color: sc.color, opacity: areaOpacity };\n        }\n\n        series.push(seriesItem);\n        currentTop += chartHeight + chartSpacing;\n    });\n\n    var xAxisIndices = [];\n    for (var j = 0; j < numCharts; j++) xAxisIndices.push(j);\n\n    var dataZoom = [{ type: 'inside', xAxisIndex: xAxisIndices }];\n    if (showDataZoomSlider) {\n        dataZoom.push({ type: 'slider', xAxisIndex: xAxisIndices, bottom: 8, height: 20 });\n    }\n\n    return {\n        tooltip: {\n            trigger: 'axis',\n            axisPointer: { type: 'line', link: { xAxisIndex: 'all' } },\n            formatter: function(params) {\n                if (!params || !params.length) return '';\n                var d = new Date(params[0].value[0]);\n                var result = d.toLocaleString() + '<br/>';\n                params.forEach(function(p) {\n                    if (p.value && p.value[1] !== null) {\n                        var sc = seriesConfigs.find(function(s) { return s.label === p.seriesName; });\n                        var dec = sc ? sc.decimals : 2;\n                        var unit = sc ? sc.units : '';\n                        result += '<span style=\"display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + p.color + ';\"></span>';\n                        result += p.seriesName + ': ' + formatUtils.value(p.value[1], dec) + (unit ? ' ' + unit : '') + '<br/>';\n                    }\n                });\n                return result;\n            }\n        },\n        axisPointer: { link: { xAxisIndex: 'all' } },\n        grid: grids,\n        xAxis: xAxes,\n        yAxis: yAxes,\n        dataZoom: dataZoom,\n        toolbox: showToolbox ? {\n            show: true, right: 10, top: 5,\n            feature: {\n                saveAsImage: toolboxFeatures.indexOf('saveAsImage') !== -1 ? { show: true } : undefined,\n                dataZoom: toolboxFeatures.indexOf('dataZoom') !== -1 ? { show: true } : undefined,\n                restore: toolboxFeatures.indexOf('restore') !== -1 ? { show: true } : undefined\n            }\n        } : null,\n        series: series\n    };\n}\n\nfunction showNoData(msg) {\n    if (!chart) return;\n    // Clear stats cards when showing no data\n    ['top', 'bottom', 'left', 'right'].forEach(function(pos) {\n        var container = statsCardContainers[pos];\n        if (container) {\n            container.style.display = 'none';\n            while (container.firstChild) container.removeChild(container.firstChild);\n        }\n    });\n    chart.setOption({\n        title: { text: msg, left: 'center', top: 'middle', textStyle: { color: '#999', fontSize: 14 } }\n    }, true);\n}\n\nself.typeParameters = function() {\n    return {\n        previewWidth: '100%',\n        previewHeight: '100%',\n        embedTitlePanel: false,\n        hasDataExportAction: true,\n        maxDatasources: -1,\n        maxDataKeys: -1,\n        dataKeysOptional: true,\n        datasourcesOptional: false,\n        hasAdditionalLatestDataKeys: true,\n        singleEntity: false,\n        defaultDataKeysFunction: function() { return []; },\n        defaultLatestDataKeysFunction: function() { return []; }\n    };\n};\n\n",
    "settingsSchema": {
      "schema": {
        "type": "object",
        "title": "ECO Timeseries Zoom Sync Settings",
        "properties": {
          "chartType": {
            "title": "Chart Type",
            "type": "string",
            "default": "line",
            "enum": [
              "line",
              "bar",
              "area",
              "scatter"
            ]
          },
          "smoothLine": {
            "title": "Smooth Lines",
            "type": "boolean",
            "default": true
          },
          "displayMode": {
            "title": "Display Mode",
            "type": "string",
            "default": "stacked",
            "enum": [
              "stacked",
              "single"
            ]
          },
          "lineWidth": {
            "title": "Line Width",
            "type": "number",
            "default": 2
          },
          "showArea": {
            "title": "Show Area Fill",
            "type": "boolean",
            "default": false
          },
          "areaOpacity": {
            "title": "Area Opacity",
            "type": "number",
            "default": 0.3
          },
          "showLegend": {
            "title": "Show Legend",
            "type": "boolean",
            "default": true
          },
          "legendStyle": {
            "title": "Legend Style",
            "type": "string",
            "default": "classic",
            "enum": [
              "classic",
              "card"
            ]
          },
          "legendPosition": {
            "title": "Legend Position",
            "type": "string",
            "default": "bottom",
            "enum": [
              "top",
              "bottom",
              "left",
              "right"
            ]
          },
          "legendAlign": {
            "title": "Legend Alignment",
            "type": "string",
            "default": "center",
            "enum": [
              "left",
              "center",
              "right"
            ]
          },
          "legendCardColorMode": {
            "title": "Card Color Mode",
            "type": "string",
            "default": "auto",
            "enum": [
              "auto",
              "manual",
              "gradient"
            ]
          },
          "legendCardColor": {
            "title": "Card Color",
            "type": "string",
            "default": "#2196F3"
          },
          "legendValues": {
            "title": "Statistics to Display",
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": [
              "current"
            ]
          },
          "showTimestamp": {
            "title": "Show Timestamp",
            "type": "boolean",
            "default": true
          },
          "timestampFormat": {
            "title": "Timestamp Format",
            "type": "string",
            "default": "YYYY-MM-DD HH:mm:ss"
          },
          "showDataZoomSlider": {
            "title": "Show Zoom Slider",
            "type": "boolean",
            "default": true
          },
          "yAxisMin": {
            "title": "Y-Axis Minimum",
            "type": "number"
          },
          "yAxisMax": {
            "title": "Y-Axis Maximum",
            "type": "number"
          },
          "yAxis2Min": {
            "title": "Second Y-Axis Minimum",
            "type": "number"
          },
          "yAxis2Max": {
            "title": "Second Y-Axis Maximum",
            "type": "number"
          },
          "removeOutliers": {
            "title": "Remove Outliers",
            "type": "boolean",
            "default": false
          },
          "outlierMethod": {
            "title": "Outlier Method",
            "type": "string",
            "default": "iqr",
            "enum": [
              "iqr",
              "zscore",
              "manual"
            ]
          },
          "outlierIqrMultiplier": {
            "title": "IQR Multiplier",
            "type": "number",
            "default": 1.5
          },
          "outlierZscoreThreshold": {
            "title": "Z-Score Threshold",
            "type": "number",
            "default": 3
          },
          "outlierMinValue": {
            "title": "Minimum Value",
            "type": "number"
          },
          "outlierMaxValue": {
            "title": "Maximum Value",
            "type": "number"
          },
          "smoothingEnabled": {
            "title": "Enable Smoothing",
            "type": "boolean",
            "default": false
          },
          "smoothingWindowMinutes": {
            "title": "Smoothing Window (minutes)",
            "type": "number",
            "default": 15
          },
          "showToolbox": {
            "title": "Show Toolbox",
            "type": "boolean",
            "default": true
          },
          "toolboxFeatures": {
            "title": "Toolbox Features",
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": [
              "saveAsImage",
              "dataView",
              "dataZoom",
              "restore"
            ]
          },
          "showTimewindowSelector": {
            "title": "Show Timewindow Selector",
            "type": "boolean",
            "default": false
          },
          "twSelectorColor": {
            "title": "Selector Color",
            "type": "string",
            "default": ""
          },
          "twSelectorPosition": {
            "title": "Selector Position",
            "type": "string",
            "default": "center",
            "enum": [
              "left",
              "center",
              "right"
            ]
          },
          "twSelectorDayFormat": {
            "title": "Day Format",
            "type": "string",
            "default": "DD.MM.YYYY"
          },
          "twSelectorWeekFormat": {
            "title": "Week Format",
            "type": "string",
            "default": "DD.MM.YYYY - DD.MM.YYYY"
          },
          "twSelectorMonthFormat": {
            "title": "Month Format",
            "type": "string",
            "default": "MMMM YYYY"
          },
          "twSelectorDefaultMode": {
            "title": "Default Mode",
            "type": "string",
            "default": "custom",
            "enum": [
              "custom",
              "day",
              "week",
              "month"
            ]
          },
          "twCustomStartTime": {
            "title": "Custom Start Time",
            "type": "string",
            "default": ""
          },
          "twCustomEndTime": {
            "title": "Custom End Time",
            "type": "string",
            "default": ""
          },
          "twAggregationType": {
            "title": "Aggregation",
            "type": "string",
            "default": "NONE",
            "enum": [
              "NONE",
              "AVG",
              "MIN",
              "MAX",
              "SUM",
              "COUNT"
            ]
          },
          "twMaxDataPoints": {
            "title": "Max Data Points",
            "type": "number",
            "default": 100000
          },
          "chartSpacing": {
            "title": "Chart Spacing (%)",
            "type": "number",
            "default": 2
          },
          "chartTopMargin": {
            "title": "Top Margin (%)",
            "type": "number",
            "default": 5
          },
          "chartBottomMargin": {
            "title": "Gap to Zoom Slider (%)",
            "type": "number",
            "default": 3
          },
          "chartTitleFontSize": {
            "title": "Chart Title - Size",
            "type": "number",
            "default": 12
          },
          "chartTitleOpacity": {
            "title": "Chart Title - Opacity",
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1
          },
          "chartTitleColor": {
            "title": "Chart Title - Color",
            "type": "string",
            "default": "#666666"
          },
          "yAxisLeftTitleFontSize": {
            "title": "Y-Axis Left Title - Size",
            "type": "number",
            "default": 11
          },
          "yAxisLeftTitleOpacity": {
            "title": "Y-Axis Left Title - Opacity",
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1
          },
          "yAxisLeftTitleColor": {
            "title": "Y-Axis Left Title - Color",
            "type": "string",
            "default": "#666666"
          },
          "yAxisRightTitleFontSize": {
            "title": "Y-Axis Right Title - Size",
            "type": "number",
            "default": 11
          },
          "yAxisRightTitleOpacity": {
            "title": "Y-Axis Right Title - Opacity",
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1
          },
          "yAxisRightTitleColor": {
            "title": "Y-Axis Right Title - Color",
            "type": "string",
            "default": "#666666"
          },
          "yAxisLeftTicksFontSize": {
            "title": "Y-Axis Left Ticks - Size",
            "type": "number",
            "default": 11
          },
          "yAxisLeftTicksOpacity": {
            "title": "Y-Axis Left Ticks - Opacity",
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1
          },
          "yAxisLeftTicksColor": {
            "title": "Y-Axis Left Ticks - Color",
            "type": "string",
            "default": "#666666"
          },
          "yAxisRightTicksFontSize": {
            "title": "Y-Axis Right Ticks - Size",
            "type": "number",
            "default": 11
          },
          "yAxisRightTicksOpacity": {
            "title": "Y-Axis Right Ticks - Opacity",
            "type": "number",
            "default": 1,
            "minimum": 0,
            "maximum": 1
          },
          "yAxisRightTicksColor": {
            "title": "Y-Axis Right Ticks - Color",
            "type": "string",
            "default": "#666666"
          },
          "chart1Enabled": {
            "title": "Enable Chart 1",
            "type": "boolean",
            "default": false
          },
          "chart1Title": {
            "title": "Chart 1 Title",
            "type": "string",
            "default": ""
          },
          "chart1Type": {
            "title": "Chart 1 Type",
            "type": "string",
            "default": "line"
          },
          "chart1Height": {
            "title": "Chart 1 Height (%)",
            "type": "number",
            "default": 0
          },
          "chart1YAxisLeftTitle": {
            "title": "Chart 1 Y-Axis Left Title",
            "type": "string",
            "default": ""
          },
          "chart1YAxisLeftGap": {
            "title": "Chart 1 Y-Axis Left Gap",
            "type": "number",
            "default": 0
          },
          "chart1YAxisRightTitle": {
            "title": "Chart 1 Y-Axis Right Title",
            "type": "string",
            "default": ""
          },
          "chart1YAxisRightGap": {
            "title": "Chart 1 Y-Axis Right Gap",
            "type": "number",
            "default": 0
          },
          "chart2Enabled": {
            "title": "Enable Chart 2",
            "type": "boolean",
            "default": false
          },
          "chart2Title": {
            "title": "Chart 2 Title",
            "type": "string",
            "default": ""
          },
          "chart2Type": {
            "title": "Chart 2 Type",
            "type": "string",
            "default": "line"
          },
          "chart2Height": {
            "title": "Chart 2 Height (%)",
            "type": "number",
            "default": 0
          },
          "chart2YAxisLeftTitle": {
            "title": "Chart 2 Y-Axis Left Title",
            "type": "string",
            "default": ""
          },
          "chart2YAxisLeftGap": {
            "title": "Chart 2 Y-Axis Left Gap",
            "type": "number",
            "default": 0
          },
          "chart2YAxisRightTitle": {
            "title": "Chart 2 Y-Axis Right Title",
            "type": "string",
            "default": ""
          },
          "chart2YAxisRightGap": {
            "title": "Chart 2 Y-Axis Right Gap",
            "type": "number",
            "default": 0
          },
          "chart3Enabled": {
            "title": "Enable Chart 3",
            "type": "boolean",
            "default": false
          },
          "chart3Title": {
            "title": "Chart 3 Title",
            "type": "string",
            "default": ""
          },
          "chart3Type": {
            "title": "Chart 3 Type",
            "type": "string",
            "default": "line"
          },
          "chart3Height": {
            "title": "Chart 3 Height (%)",
            "type": "number",
            "default": 0
          },
          "chart3YAxisLeftTitle": {
            "title": "Chart 3 Y-Axis Left Title",
            "type": "string",
            "default": ""
          },
          "chart3YAxisLeftGap": {
            "title": "Chart 3 Y-Axis Left Gap",
            "type": "number",
            "default": 0
          },
          "chart3YAxisRightTitle": {
            "title": "Chart 3 Y-Axis Right Title",
            "type": "string",
            "default": ""
          },
          "chart3YAxisRightGap": {
            "title": "Chart 3 Y-Axis Right Gap",
            "type": "number",
            "default": 0
          },
          "chart4Enabled": {
            "title": "Enable Chart 4",
            "type": "boolean",
            "default": false
          },
          "chart4Title": {
            "title": "Chart 4 Title",
            "type": "string",
            "default": ""
          },
          "chart4Type": {
            "title": "Chart 4 Type",
            "type": "string",
            "default": "line"
          },
          "chart4Height": {
            "title": "Chart 4 Height (%)",
            "type": "number",
            "default": 0
          },
          "chart4YAxisLeftTitle": {
            "title": "Chart 4 Y-Axis Left Title",
            "type": "string",
            "default": ""
          },
          "chart4YAxisLeftGap": {
            "title": "Chart 4 Y-Axis Left Gap",
            "type": "number",
            "default": 0
          },
          "chart4YAxisRightTitle": {
            "title": "Chart 4 Y-Axis Right Title",
            "type": "string",
            "default": ""
          },
          "chart4YAxisRightGap": {
            "title": "Chart 4 Y-Axis Right Gap",
            "type": "number",
            "default": 0
          },
          "axisLabelFontSize": {
            "title": "Axis Label Font Size",
            "type": "number",
            "default": 11
          },
          "axisLabelColor": {
            "title": "Axis Label Color",
            "type": "string",
            "default": "#666666"
          },
          "axisTickFontSize": {
            "title": "Axis Tick Font Size",
            "type": "number",
            "default": 10
          }
        },
        "required": []
      },
      "form": [
        [
          {
            "key": "chartType",
            "type": "rc-select",
            "multiple": false,
            "items": [
              {
                "value": "line",
                "label": "Line Chart"
              },
              {
                "value": "bar",
                "label": "Bar Chart"
              },
              {
                "value": "area",
                "label": "Area Chart"
              },
              {
                "value": "scatter",
                "label": "Scatter Plot"
              }
            ]
          },
          {
            "key": "smoothLine",
            "condition": "model.chartType === 'line' || model.chartType === 'area'"
          },
          {
            "key": "displayMode",
            "type": "rc-select",
            "multiple": false,
            "items": [
              {
                "value": "stacked",
                "label": "Stacked Charts (Synced Zoom)"
              },
              {
                "value": "single",
                "label": "Single Chart (Overlaid)"
              }
            ]
          },
          {
            "key": "lineWidth",
            "condition": "model.chartType === 'line' || model.chartType === 'area'"
          },
          {
            "key": "showArea",
            "condition": "model.chartType === 'line'"
          },
          {
            "key": "areaOpacity",
            "condition": "model.showArea === true || model.chartType === 'area'"
          },
          "showDataZoomSlider"
        ],
        [
          "showLegend",
          {
            "key": "legendStyle",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true",
            "items": [
              {
                "value": "classic",
                "label": "Classic (Text)"
              },
              {
                "value": "card",
                "label": "Statistics Card"
              }
            ]
          },
          {
            "key": "legendPosition",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true",
            "items": [
              {
                "value": "top",
                "label": "Top"
              },
              {
                "value": "bottom",
                "label": "Bottom"
              },
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "legendAlign",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "center",
                "label": "Center"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "legendCardColorMode",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "auto",
                "label": "Auto (Series Color)"
              },
              {
                "value": "manual",
                "label": "Manual Color"
              },
              {
                "value": "gradient",
                "label": "Gradient"
              }
            ]
          },
          {
            "key": "legendCardColor",
            "type": "color",
            "condition": "model.showLegend === true && model.legendStyle === 'card' && model.legendCardColorMode === 'manual'"
          },
          {
            "key": "legendValues",
            "type": "rc-select",
            "multiple": true,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "current",
                "label": "Current Value"
              },
              {
                "value": "min",
                "label": "Minimum"
              },
              {
                "value": "max",
                "label": "Maximum"
              },
              {
                "value": "mean",
                "label": "Mean"
              },
              {
                "value": "median",
                "label": "Median"
              },
              {
                "value": "sum",
                "label": "Sum"
              },
              {
                "value": "count",
                "label": "Count"
              }
            ]
          },
          {
            "key": "showTimestamp",
            "condition": "model.showLegend === true && model.legendStyle === 'card'"
          },
          {
            "key": "timestampFormat",
            "condition": "model.showLegend === true && model.legendStyle === 'card' && model.showTimestamp === true"
          }
        ],
        [
          "yAxisMin",
          "yAxisMax",
          "yAxis2Min",
          "yAxis2Max"
        ],
        [
          "removeOutliers",
          {
            "key": "outlierMethod",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.removeOutliers === true",
            "items": [
              {
                "value": "iqr",
                "label": "IQR (Interquartile Range)"
              },
              {
                "value": "zscore",
                "label": "Z-Score"
              },
              {
                "value": "manual",
                "label": "Manual Thresholds"
              }
            ]
          },
          {
            "key": "outlierIqrMultiplier",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'iqr'"
          },
          {
            "key": "outlierZscoreThreshold",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'zscore'"
          },
          {
            "key": "outlierMinValue",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'manual'"
          },
          {
            "key": "outlierMaxValue",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'manual'"
          },
          "smoothingEnabled",
          {
            "key": "smoothingWindowMinutes",
            "condition": "model.smoothingEnabled === true"
          }
        ],
        [
          "showToolbox",
          {
            "key": "toolboxFeatures",
            "type": "rc-select",
            "multiple": true,
            "condition": "model.showToolbox === true",
            "items": [
              {
                "value": "saveAsImage",
                "label": "Save as Image"
              },
              {
                "value": "dataView",
                "label": "Data View"
              },
              {
                "value": "dataZoom",
                "label": "Data Zoom"
              },
              {
                "value": "restore",
                "label": "Restore"
              }
            ]
          }
        ],
        [
          "showTimewindowSelector",
          {
            "key": "twSelectorColor",
            "type": "color",
            "condition": "model.showTimewindowSelector === true",
            "description": "Leave empty for auto (uses series color)"
          },
          {
            "key": "twSelectorPosition",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "center",
                "label": "Center"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "twSelectorDefaultMode",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "custom",
                "label": "Custom (C) - Dashboard Timewindow"
              },
              {
                "value": "day",
                "label": "Day (D)"
              },
              {
                "value": "week",
                "label": "Week (W)"
              },
              {
                "value": "month",
                "label": "Month (M)"
              }
            ]
          },
          {
            "key": "twSelectorDayFormat",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "DD.MM.YYYY",
                "label": "DD.MM.YYYY (25.01.2026)"
              },
              {
                "value": "D.M.YYYY",
                "label": "D.M.YYYY (25.1.2026)"
              },
              {
                "value": "DD.MM.YY",
                "label": "DD.MM.YY (25.01.26)"
              },
              {
                "value": "D MMM YYYY",
                "label": "D MMM YYYY (25 Jan 2026)"
              },
              {
                "value": "D MMMM YYYY",
                "label": "D MMMM YYYY (25 Januar 2026)"
              }
            ]
          },
          {
            "key": "twSelectorWeekFormat",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "DD.MM.YYYY - DD.MM.YYYY",
                "label": "DD.MM.YYYY - DD.MM.YYYY (19.01.2026 - 25.01.2026)"
              },
              {
                "value": "DD.MM. - DD.MM.YYYY",
                "label": "DD.MM. - DD.MM.YYYY (19.01. - 25.01.2026)"
              },
              {
                "value": "DD.MM.YY - DD.MM.YY",
                "label": "DD.MM.YY - DD.MM.YY (19.01.26 - 25.01.26)"
              },
              {
                "value": "D-D MMM YYYY",
                "label": "D-D MMM YYYY (19-25 Jan 2026)"
              },
              {
                "value": "D MMM - D MMM",
                "label": "D MMM - D MMM (19 Jan - 25 Jan)"
              }
            ]
          },
          {
            "key": "twSelectorMonthFormat",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "MMMM YYYY",
                "label": "MMMM YYYY (Januar 2026)"
              },
              {
                "value": "MMM YYYY",
                "label": "MMM YYYY (Jan 2026)"
              },
              {
                "value": "MM/YYYY",
                "label": "MM/YYYY (01/2026)"
              },
              {
                "value": "MM.YYYY",
                "label": "MM.YYYY (01.2026)"
              }
            ]
          },
          {
            "key": "twCustomStartTime",
            "condition": "model.showTimewindowSelector === true",
            "description": "Use ${attributeName} for entity attributes, e.g. ${startTimeMs}"
          },
          {
            "key": "twCustomEndTime",
            "condition": "model.showTimewindowSelector === true",
            "description": "Use ${attributeName} for entity attributes, e.g. ${endTimeMs}"
          },
          {
            "key": "twAggregationType",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "NONE",
                "label": "None (Raw Data)"
              },
              {
                "value": "AVG",
                "label": "Average"
              },
              {
                "value": "MIN",
                "label": "Minimum"
              },
              {
                "value": "MAX",
                "label": "Maximum"
              },
              {
                "value": "SUM",
                "label": "Sum"
              },
              {
                "value": "COUNT",
                "label": "Count"
              }
            ]
          },
          {
            "key": "twMaxDataPoints",
            "condition": "model.showTimewindowSelector === true",
            "description": "Maximum number of data points to fetch (default: 100000)"
          }
        ],
        [
          {
            "key": "chartSpacing",
            "condition": "model.displayMode === 'stacked'"
          },
          {
            "key": "chartTopMargin",
            "condition": "model.displayMode === 'stacked'"
          },
          {
            "key": "chartBottomMargin",
            "condition": "model.displayMode === 'stacked'"
          },
          {
            "type": "help",
            "helpvalue": "<div style='margin:8px 0;padding:8px;background:#e3f2fd;border-radius:4px;border-left:4px solid #2196F3'><b>Chart 1</b></div>",
            "condition": "model.displayMode === 'stacked'"
          },
          {
            "key": "chart1Enabled",
            "condition": "model.displayMode === 'stacked'"
          },
          {
            "key": "chart1Title",
            "condition": "model.displayMode === 'stacked' && model.chart1Enabled"
          },
          {
            "key": "chart1Type",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.displayMode === 'stacked' && model.chart1Enabled",
            "items": [
              {
                "value": "line",
                "label": "Line"
              },
              {
                "value": "bar",
                "label": "Bar"
              },
              {
                "value": "area",
                "label": "Area"
              },
              {
                "value": "scatter",
                "label": "Scatter"
              }
            ]
          },
          {
            "key": "chart1Height",
            "condition": "model.displayMode === 'stacked' && model.chart1Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "key": "chart1YAxisLeftTitle",
            "condition": "model.displayMode === 'stacked' && model.chart1Enabled",
            "placeholder": "Auto from data keys"
          },
          {
            "key": "chart1YAxisLeftGap",
            "condition": "model.displayMode === 'stacked' && model.chart1Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "key": "chart1YAxisRightTitle",
            "condition": "model.displayMode === 'stacked' && model.chart1Enabled",
            "placeholder": "Auto from data keys"
          },
          {
            "key": "chart1YAxisRightGap",
            "condition": "model.displayMode === 'stacked' && model.chart1Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "type": "help",
            "helpvalue": "<div style='margin:8px 0;padding:8px;background:#e8f5e9;border-radius:4px;border-left:4px solid #4CAF50'><b>Chart 2</b></div>",
            "condition": "model.displayMode === 'stacked'"
          },
          {
            "key": "chart2Enabled",
            "condition": "model.displayMode === 'stacked'"
          },
          {
            "key": "chart2Title",
            "condition": "model.displayMode === 'stacked' && model.chart2Enabled"
          },
          {
            "key": "chart2Type",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.displayMode === 'stacked' && model.chart2Enabled",
            "items": [
              {
                "value": "line",
                "label": "Line"
              },
              {
                "value": "bar",
                "label": "Bar"
              },
              {
                "value": "area",
                "label": "Area"
              },
              {
                "value": "scatter",
                "label": "Scatter"
              }
            ]
          },
          {
            "key": "chart2Height",
            "condition": "model.displayMode === 'stacked' && model.chart2Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "key": "chart2YAxisLeftTitle",
            "condition": "model.displayMode === 'stacked' && model.chart2Enabled",
            "placeholder": "Auto from data keys"
          },
          {
            "key": "chart2YAxisLeftGap",
            "condition": "model.displayMode === 'stacked' && model.chart2Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "key": "chart2YAxisRightTitle",
            "condition": "model.displayMode === 'stacked' && model.chart2Enabled",
            "placeholder": "Auto from data keys"
          },
          {
            "key": "chart2YAxisRightGap",
            "condition": "model.displayMode === 'stacked' && model.chart2Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "type": "help",
            "helpvalue": "<div style='margin:8px 0;padding:8px;background:#fff3e0;border-radius:4px;border-left:4px solid #FF9800'><b>Chart 3</b></div>",
            "condition": "model.displayMode === 'stacked'"
          },
          {
            "key": "chart3Enabled",
            "condition": "model.displayMode === 'stacked'"
          },
          {
            "key": "chart3Title",
            "condition": "model.displayMode === 'stacked' && model.chart3Enabled"
          },
          {
            "key": "chart3Type",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.displayMode === 'stacked' && model.chart3Enabled",
            "items": [
              {
                "value": "line",
                "label": "Line"
              },
              {
                "value": "bar",
                "label": "Bar"
              },
              {
                "value": "area",
                "label": "Area"
              },
              {
                "value": "scatter",
                "label": "Scatter"
              }
            ]
          },
          {
            "key": "chart3Height",
            "condition": "model.displayMode === 'stacked' && model.chart3Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "key": "chart3YAxisLeftTitle",
            "condition": "model.displayMode === 'stacked' && model.chart3Enabled",
            "placeholder": "Auto from data keys"
          },
          {
            "key": "chart3YAxisLeftGap",
            "condition": "model.displayMode === 'stacked' && model.chart3Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "key": "chart3YAxisRightTitle",
            "condition": "model.displayMode === 'stacked' && model.chart3Enabled",
            "placeholder": "Auto from data keys"
          },
          {
            "key": "chart3YAxisRightGap",
            "condition": "model.displayMode === 'stacked' && model.chart3Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "type": "help",
            "helpvalue": "<div style='margin:8px 0;padding:8px;background:#fce4ec;border-radius:4px;border-left:4px solid #E91E63'><b>Chart 4</b></div>",
            "condition": "model.displayMode === 'stacked'"
          },
          {
            "key": "chart4Enabled",
            "condition": "model.displayMode === 'stacked'"
          },
          {
            "key": "chart4Title",
            "condition": "model.displayMode === 'stacked' && model.chart4Enabled"
          },
          {
            "key": "chart4Type",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.displayMode === 'stacked' && model.chart4Enabled",
            "items": [
              {
                "value": "line",
                "label": "Line"
              },
              {
                "value": "bar",
                "label": "Bar"
              },
              {
                "value": "area",
                "label": "Area"
              },
              {
                "value": "scatter",
                "label": "Scatter"
              }
            ]
          },
          {
            "key": "chart4Height",
            "condition": "model.displayMode === 'stacked' && model.chart4Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "key": "chart4YAxisLeftTitle",
            "condition": "model.displayMode === 'stacked' && model.chart4Enabled",
            "placeholder": "Auto from data keys"
          },
          {
            "key": "chart4YAxisLeftGap",
            "condition": "model.displayMode === 'stacked' && model.chart4Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "key": "chart4YAxisRightTitle",
            "condition": "model.displayMode === 'stacked' && model.chart4Enabled",
            "placeholder": "Auto from data keys"
          },
          {
            "key": "chart4YAxisRightGap",
            "condition": "model.displayMode === 'stacked' && model.chart4Enabled",
            "placeholder": "0 = Auto"
          },
          {
            "type": "help",
            "helpvalue": "<div style='margin:12px 0 0;font-size:11px;color:#666'><i>Y-Axes are created automatically per unit. Configure Min/Max per Data Key in Advanced settings. Set Y-Axis titles manually above to override auto-generated labels.</i></div>",
            "condition": "model.displayMode === 'stacked'"
          }
        ],
        [
          {
            "type": "help",
            "helpvalue": "<div style='font-weight:500;margin-bottom:8px'>Chart Title</div>"
          },
          "chartTitleFontSize",
          "chartTitleOpacity",
          {
            "key": "chartTitleColor",
            "type": "color"
          },
          {
            "type": "help",
            "helpvalue": "<div style='font-weight:500;margin:16px 0 8px'>Axis Labels & Ticks</div>"
          },
          "axisLabelFontSize",
          {
            "key": "axisLabelColor",
            "type": "color"
          },
          "axisTickFontSize"
        ]
      ],
      "groupInfoes": [
        {
          "formIndex": 0,
          "GroupTitle": "Chart Settings"
        },
        {
          "formIndex": 1,
          "GroupTitle": "Legend Settings"
        },
        {
          "formIndex": 2,
          "GroupTitle": "Y-Axis Settings"
        },
        {
          "formIndex": 3,
          "GroupTitle": "Data Processing"
        },
        {
          "formIndex": 4,
          "GroupTitle": "Toolbox Settings"
        },
        {
          "formIndex": 5,
          "GroupTitle": "Timewindow Selector"
        },
        {
          "formIndex": 6,
          "GroupTitle": "Charts Configuration"
        },
        {
          "formIndex": 7,
          "GroupTitle": "Appearance"
        }
      ]
    },
    "dataKeySettingsSchema": {
      "schema": {
        "type": "object",
        "title": "Data Key Settings",
        "properties": {
          "chartsAssignment": {
            "title": "Assign to Charts",
            "type": "array",
            "items": {
              "type": "number"
            },
            "default": [
              1
            ]
          },
          "chartIndex": {
            "title": "Assign to Chart (Legacy)",
            "type": "number",
            "default": 0
          },
          "yAxisMin": {
            "title": "Y-Axis Min (Override)",
            "type": "number"
          },
          "yAxisMax": {
            "title": "Y-Axis Max (Override)",
            "type": "number"
          }
        }
      },
      "form": [
        {
          "key": "chartsAssignment",
          "type": "rc-select",
          "multiple": true,
          "items": [
            {
              "value": 1,
              "label": "Chart 1"
            },
            {
              "value": 2,
              "label": "Chart 2"
            },
            {
              "value": 3,
              "label": "Chart 3"
            },
            {
              "value": 4,
              "label": "Chart 4"
            }
          ]
        },
        {
          "key": "yAxisMin",
          "placeholder": "Auto"
        },
        {
          "key": "yAxisMax",
          "placeholder": "Auto"
        }
      ]
    },
    "latestDataKeySettingsSchema": {},
    "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Temperature\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.456,\"funcBody\":\"var value = prevValue + Math.random() * 10 - 5;\\nif (value < 0) value = 0;\\nif (value > 100) value = 100;\\nreturn value;\",\"units\":\"C\",\"decimals\":1},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Humidity\",\"color\":\"#4CAF50\",\"settings\":{},\"_hash\":0.789,\"funcBody\":\"var value = prevValue + Math.random() * 8 - 4;\\nif (value < 20) value = 20;\\nif (value > 90) value = 90;\\nreturn value;\",\"units\":\"%\",\"decimals\":1}]}],\"timewindow\":{\"hideInterval\":false,\"hideLastInterval\":false,\"hideQuickInterval\":false,\"hideAggregation\":false,\"hideAggInterval\":false,\"hideTimezone\":false,\"selectedTab\":0,\"realtime\":{\"realtimeType\":0,\"timewindowMs\":3600000,\"quickInterval\":\"CURRENT_HOUR\",\"interval\":5000},\"aggregation\":{\"type\":\"AVG\",\"limit\":25000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"chartType\":\"line\",\"smoothLine\":true,\"showLegend\":true,\"legendStyle\":\"classic\",\"legendPosition\":\"bottom\",\"legendAlign\":\"center\",\"legendCardColorMode\":\"auto\",\"legendCardColor\":\"#2196F3\",\"legendValues\":[\"current\"],\"showTimestamp\":true,\"timestampFormat\":\"YYYY-MM-DD HH:mm:ss\",\"showDataZoomSlider\":true,\"showToolbox\":true,\"toolboxFeatures\":[\"saveAsImage\",\"dataView\",\"dataZoom\",\"restore\"]},\"title\":\"ECO Timeseries Zoom Sync\",\"dropShadow\":true,\"enableFullscreen\":true,\"useDashboardTimewindow\":true,\"displayTimewindow\":true,\"hasAdditionalLatestDataKeys\":true}"
  },
  "externalId": {
    "entityType": "WIDGET_TYPE",
    "id": "fc301e90-f866-11f0-adb4-33b9bcf3ddd0"
  },
  "resources": null,
  "id": {
    "entityType": "WIDGET_TYPE",
    "id": "fc301e90-f866-11f0-adb4-33b9bcf3ddd0"
  },
  "createdTime": 1769178164985,
  "tenantId": {
    "entityType": "TENANT",
    "id": "efb63c10-b576-11ee-a6c2-a149ed03c64d"
  },
  "scada": false,
  "version": 151,
  "tags": [
    "chart",
    "timeseries",
    "time-series",
    "zoom",
    "line",
    "line chart",
    "bar",
    "bar chart",
    "area",
    "scatter",
    "echarts",
    "statistics",
    "dual-axis"
  ]
}