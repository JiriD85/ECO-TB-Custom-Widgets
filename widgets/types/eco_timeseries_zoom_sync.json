{
  "fqn": "eco_custom_widgets.eco_timeseries_zoom_sync",
  "name": "ECO Timeseries Zoom Sync",
  "deprecated": false,
  "image": "tb-image;/api/images/system/chart.svg",
  "description": "Time series visualization with configurable chart types (line, bar, area, scatter), multi-series support, dual Y-axes, statistics cards, and internal zoom. Reference implementation for ECO Custom Widgets.",
  "descriptor": {
    "type": "timeseries",
    "sizeX": 8,
    "sizeY": 5,
    "resources": [
      {
        "url": "https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"
      },
      {
        "url": "https://cdn.jsdelivr.net/gh/JiriD85/ECO-TB-Custom-Widgets@main/widgets/resources/eco-widget-utils.js"
      }
    ],
    "templateHtml": "<div id=\"widget-wrapper\" style=\"width: 100%; height: 100%; display: flex; flex-direction: column;\">\n  <div id=\"timewindow-selector\" style=\"display: none;\"></div>\n  <div id=\"stats-card-top\" style=\"padding: 4px 8px; display: none;\"></div>\n  <div style=\"flex: 1; min-height: 0; display: flex;\">\n    <div id=\"stats-card-left\" style=\"padding: 4px; display: none;\"></div>\n    <div id=\"chart-container\" style=\"flex: 1; min-height: 0;\"></div>\n    <div id=\"stats-card-right\" style=\"padding: 4px; display: none;\"></div>\n  </div>\n  <div id=\"stats-card-bottom\" style=\"padding: 4px 8px; display: none;\"></div>\n</div>",
    "templateCss": "#widget-wrapper { position: relative; }\n#chart-container { position: relative; }",
    "controllerScript": "/**\n * ECO Timeseries Zoom Sync Widget\n *\n * Time series visualization with configurable chart types, multi-series support,\n * dual Y-axes, statistics cards, and internal zoom (no dashboard sync).\n * Reference implementation for ECO Custom Widgets.\n */\n\nvar chart = null;\nvar chartContainer = null;\nvar statsCardContainers = {};\nvar timewindowSelectorContainer = null;\nvar resizeObserver = null;\n\n// Timewindow selector state\nvar twState = {\n    mode: 'day',  // 'day', 'week', 'month', 'custom'\n    currentDate: new Date()  // Reference date for navigation\n};\n\n// Cached settings for timewindow selector\nvar twSettings = {};\n\nself.onInit = function() {\n    chartContainer = self.ctx.$container.find('#chart-container')[0];\n    timewindowSelectorContainer = self.ctx.$container.find('#timewindow-selector')[0];\n    statsCardContainers = {\n        top: self.ctx.$container.find('#stats-card-top')[0],\n        bottom: self.ctx.$container.find('#stats-card-bottom')[0],\n        left: self.ctx.$container.find('#stats-card-left')[0],\n        right: self.ctx.$container.find('#stats-card-right')[0]\n    };\n\n    if (!chartContainer) {\n        console.error('ECO Timeseries Zoom Sync: Chart container not found');\n        return;\n    }\n\n    if (typeof echarts === 'undefined') {\n        console.error('ECO Timeseries Zoom Sync: ECharts library not loaded');\n        return;\n    }\n\n    chart = echarts.init(chartContainer);\n    updateChart();\n\n    // Multiple delayed resizes to handle ThingsBoard's async layout\n    // Container size may not be final until layout completes\n    // Use inline code to avoid any closure/scoping issues\n    [100, 250, 500, 1000].forEach(function(delay) {\n        setTimeout(function() {\n            if (chart && chartContainer) {\n                var w = chartContainer.offsetWidth;\n                var h = chartContainer.offsetHeight;\n                chart.resize({ width: w, height: h });\n            }\n        }, delay);\n    });\n\n    // ResizeObserver for dynamic container size changes\n    if (typeof ResizeObserver !== 'undefined') {\n        resizeObserver = new ResizeObserver(function() {\n            requestAnimationFrame(function() {\n                if (chart && chartContainer) {\n                    chart.resize({\n                        width: chartContainer.offsetWidth,\n                        height: chartContainer.offsetHeight\n                    });\n                }\n            });\n        });\n        resizeObserver.observe(chartContainer);\n    }\n};\n\nself.onDataUpdated = function() {\n    updateChart();\n};\n\nfunction updateChart() {\n    if (!chart) return;\n\n    var settings = self.ctx.settings || {};\n    var data = self.ctx.data || [];\n\n    // Chart type settings\n    var chartType = settings.chartType || 'line';\n    var smoothLine = settings.smoothLine !== false;\n    var chartLayout = settings.chartLayout || 'combined'; // 'combined' or 'separate'\n\n    // Legend settings\n    var showLegend = settings.showLegend !== false;\n    var legendStyle = settings.legendStyle || 'classic';\n    var legendPosition = settings.legendPosition || 'bottom';\n    var legendAlign = settings.legendAlign || 'center';\n    var legendCardColorMode = settings.legendCardColorMode || 'auto';\n    var legendCardColor = settings.legendCardColor || '#2196F3';\n    var legendValues = settings.legendValues || ['current'];\n\n    // Timestamp settings\n    var showTimestamp = settings.showTimestamp !== false;\n    var timestampFormat = settings.timestampFormat || 'YYYY-MM-DD HH:mm:ss';\n\n    // DataZoom settings\n    var showDataZoomSlider = settings.showDataZoomSlider !== false;\n\n    // Y-Axis settings\n    var yAxisMin = settings.yAxisMin;\n    var yAxisMax = settings.yAxisMax;\n    var yAxis2Min = settings.yAxis2Min;\n    var yAxis2Max = settings.yAxis2Max;\n\n    // Outlier removal settings\n    var removeOutliers = settings.removeOutliers === true;\n    var outlierMethod = settings.outlierMethod || 'iqr';\n    var outlierIqrMultiplier = settings.outlierIqrMultiplier || 1.5;\n    var outlierZscoreThreshold = settings.outlierZscoreThreshold || 3;\n    var outlierMinValue = settings.outlierMinValue;\n    var outlierMaxValue = settings.outlierMaxValue;\n\n    // Smoothing settings\n    var smoothingEnabled = settings.smoothingEnabled === true;\n    var smoothingWindowMinutes = settings.smoothingWindowMinutes || 15;\n\n    // Toolbox settings\n    var showToolbox = settings.showToolbox !== false;\n    var toolboxFeatures = settings.toolboxFeatures || ['saveAsImage', 'dataView', 'dataZoom', 'restore'];\n    var showSaveAsImage = toolboxFeatures.indexOf('saveAsImage') !== -1;\n    var showDataView = toolboxFeatures.indexOf('dataView') !== -1;\n    var showDataZoom = toolboxFeatures.indexOf('dataZoom') !== -1;\n    var showRestore = toolboxFeatures.indexOf('restore') !== -1;\n\n    // Timewindow selector settings\n    var showTimewindowSelector = settings.showTimewindowSelector === true;\n\n    // Cache timewindow selector settings for use in render function\n    twSettings = {\n        color: settings.twSelectorColor || '',  // Empty = auto (use series color)\n        position: settings.twSelectorPosition || 'center',\n        dayFormat: settings.twSelectorDayFormat || 'D MMM YYYY',\n        weekFormat: settings.twSelectorWeekFormat || 'D-D MMM',\n        monthFormat: settings.twSelectorMonthFormat || 'MMM YYYY',\n        customStartTime: settings.twCustomStartTime || '',\n        customEndTime: settings.twCustomEndTime || '',\n        aggregationType: settings.twAggregationType || 'NONE',\n        maxDataPoints: settings.twMaxDataPoints || 100000\n    };\n\n    // Render timewindow selector if enabled and widget uses timewindow\n    if (showTimewindowSelector && self.ctx.dashboard) {\n        renderTimewindowSelector();\n    } else if (timewindowSelectorContainer) {\n        timewindowSelectorContainer.style.display = 'none';\n    }\n\n    // Check for valid data\n    if (!data.length) {\n        showNoData('No data available');\n        return;\n    }\n\n    // Process all datasources and group by datasource config index\n    var seriesConfigs = [];\n    var allStats = [];\n    var hasSecondAxis = false;\n    var datasourceGroups = {}; // Group series by datasource config for separate layout\n    var datasourceOrder = []; // Track order of datasources\n\n    // Get datasource configurations from widget context\n    var datasourceConfigs = self.ctx.datasources || [];\n\n    // Build a lookup: for each datasource config, track which dataKey names belong to it\n    // This allows us to match data entries to their datasource config\n    var dataKeyToDsIndex = {};\n    var dsIndexCounter = 0;\n    for (var di = 0; di < datasourceConfigs.length; di++) {\n        var cfg = datasourceConfigs[di];\n        var cfgDataKeys = cfg.dataKeys || [];\n        for (var dki = 0; dki < cfgDataKeys.length; dki++) {\n            // Create a unique key combining datasource index and dataKey name\n            // This handles the case where same dataKey name exists in multiple datasources\n            var keyId = di + '_' + (cfgDataKeys[dki].name || dki);\n            dataKeyToDsIndex[keyId] = di;\n        }\n    }\n\n    // Track which data entry index belongs to which datasource\n    var dataIndexToDsIndex = {};\n    var currentDsIndex = 0;\n    var currentKeyIndex = 0;\n    for (var i = 0; i < data.length; i++) {\n        // In ThingsBoard, data entries are ordered by datasource, then by dataKey\n        // So we can track which datasource we're in by counting dataKeys\n        if (currentDsIndex < datasourceConfigs.length) {\n            var currentDsConfig = datasourceConfigs[currentDsIndex];\n            var numKeysInCurrentDs = (currentDsConfig.dataKeys || []).length;\n\n            if (currentKeyIndex >= numKeysInCurrentDs) {\n                currentDsIndex++;\n                currentKeyIndex = 0;\n            }\n        }\n        dataIndexToDsIndex[i] = currentDsIndex < datasourceConfigs.length ? currentDsIndex : i;\n        currentKeyIndex++;\n    }\n\n    for (var i = 0; i < data.length; i++) {\n        var ds = data[i];\n        if (!ds.data || !ds.data.length) continue;\n\n        var dataKey = ds.dataKey || {};\n        var datasource = ds.datasource || {};\n\n        // Get datasource index from our pre-built mapping\n        var dsIndex = dataIndexToDsIndex[i] !== undefined ? dataIndexToDsIndex[i] : i;\n\n        var dsId = 'ds_' + dsIndex;\n        var dsName = datasource.entityName || datasource.name || datasource.entityLabel || ('Datasource ' + (dsIndex + 1));\n\n        // Series identification\n        var label = dataKey.label || dataKey.name || 'Series ' + (i + 1);\n        var units = dataKey.units || '';\n        var decimals = dataKey.decimals !== undefined ? dataKey.decimals : 2;\n        var color = dataKey.color || getDefaultColor(i);\n\n        // Determine Y-axis assignment (auto-detect based on units)\n        var yAxisIndex = 0;\n        if (i > 0 && seriesConfigs.length > 0) {\n            var firstUnits = seriesConfigs[0].units;\n            if (units && firstUnits && units !== firstUnits) {\n                yAxisIndex = 1;\n                hasSecondAxis = true;\n            }\n        }\n\n        // Extract values and timestamps\n        var rawValues = [];\n        var timestamps = [];\n\n        for (var j = 0; j < ds.data.length; j++) {\n            var ts = ds.data[j][0];\n            var val = ds.data[j][1];\n            if (val !== null && !isNaN(val)) {\n                timestamps.push(ts);\n                rawValues.push(val);\n            }\n        }\n\n        if (rawValues.length === 0) continue;\n\n        var values = rawValues.slice();\n\n        // Remove outliers if enabled\n        if (removeOutliers) {\n            var outlierResult = removeOutliersFromData(values, timestamps, {\n                method: outlierMethod,\n                iqrMultiplier: outlierIqrMultiplier,\n                zscoreThreshold: outlierZscoreThreshold,\n                minValue: outlierMinValue,\n                maxValue: outlierMaxValue\n            });\n            values = outlierResult.values;\n            timestamps = outlierResult.timestamps;\n\n            if (values.length === 0) continue;\n        }\n\n        // Apply smoothing if enabled\n        if (smoothingEnabled && smoothingWindowMinutes > 0 && timestamps.length > 1) {\n            // Calculate average time interval between data points\n            var totalTimeMs = timestamps[timestamps.length - 1] - timestamps[0];\n            var avgIntervalMs = totalTimeMs / (timestamps.length - 1);\n            // Convert window from minutes to data points\n            var windowMs = smoothingWindowMinutes * 60 * 1000;\n            var windowSize = Math.max(1, Math.round(windowMs / avgIntervalMs));\n            values = movingAverage(values, windowSize);\n        }\n\n        // Build series data from processed values\n        var seriesData = [];\n        var lastTimestamp = null;\n        var lastValue = null;\n        for (var k = 0; k < values.length; k++) {\n            seriesData.push([timestamps[k], values[k]]);\n            lastTimestamp = timestamps[k];\n            lastValue = values[k];\n        }\n\n        // Calculate statistics for this series\n        var stats = calculateStatistics(values);\n        stats.current = lastValue;\n        stats.lastTimestamp = lastTimestamp;\n\n        var seriesConfig = {\n            label: label,\n            units: units,\n            decimals: decimals,\n            color: color,\n            data: seriesData,\n            stats: stats,\n            yAxisIndex: yAxisIndex,\n            datasourceId: dsId,\n            datasourceName: dsName\n        };\n\n        seriesConfigs.push(seriesConfig);\n\n        // Group by datasource for separate layout\n        if (!datasourceGroups[dsId]) {\n            datasourceGroups[dsId] = {\n                name: dsName,\n                series: []\n            };\n            datasourceOrder.push(dsId);\n        }\n        datasourceGroups[dsId].series.push(seriesConfig);\n\n        allStats.push({\n            label: label,\n            units: units,\n            decimals: decimals,\n            color: color,\n            stats: stats\n        });\n    }\n\n    if (seriesConfigs.length === 0) {\n        showNoData('No valid data points');\n        return;\n    }\n\n    // Build ECharts option\n    var option = buildChartOption({\n        chartType: chartType,\n        smoothLine: smoothLine,\n        chartLayout: chartLayout,\n        seriesConfigs: seriesConfigs,\n        datasourceGroups: datasourceGroups,\n        datasourceOrder: datasourceOrder,\n        hasSecondAxis: hasSecondAxis,\n        showLegend: showLegend,\n        legendStyle: legendStyle,\n        legendPosition: legendPosition,\n        showDataZoomSlider: showDataZoomSlider,\n        yAxisMin: yAxisMin,\n        yAxisMax: yAxisMax,\n        yAxis2Min: yAxis2Min,\n        yAxis2Max: yAxis2Max,\n        showToolbox: showToolbox,\n        showSaveAsImage: showSaveAsImage,\n        showDataView: showDataView,\n        showDataZoom: showDataZoom,\n        showRestore: showRestore\n    });\n\n    chart.setOption(option, true);\n\n    // Render statistics cards (DOM-based)\n    renderStatsCard({\n        showLegend: showLegend,\n        legendStyle: legendStyle,\n        legendAlign: legendAlign,\n        legendCardColorMode: legendCardColorMode,\n        legendCardColor: legendCardColor,\n        legendValues: legendValues,\n        legendPosition: legendPosition,\n        showTimestamp: showTimestamp,\n        timestampFormat: timestampFormat,\n        allStats: allStats\n    });\n\n    // Resize chart after stats cards are rendered to fix container height\n    // Use multiple strategies to ensure resize happens after layout is complete\n    function doResize() {\n        if (chart && chartContainer) {\n            chart.resize({\n                width: chartContainer.offsetWidth,\n                height: chartContainer.offsetHeight\n            });\n        }\n    }\n\n    // Strategy 1: requestAnimationFrame for next paint\n    requestAnimationFrame(function() {\n        requestAnimationFrame(doResize);\n    });\n\n    // Strategy 2: setTimeout fallbacks at different intervals\n    setTimeout(doResize, 100);\n    setTimeout(doResize, 250);\n}\n\nfunction renderStatsCard(config) {\n    // Clear all containers first\n    ['top', 'bottom', 'left', 'right'].forEach(function(pos) {\n        var container = statsCardContainers[pos];\n        if (container) {\n            container.style.display = 'none';\n            while (container.firstChild) {\n                container.removeChild(container.firstChild);\n            }\n        }\n    });\n\n    var legendValues = config.legendValues || [];\n    var legendStyle = config.legendStyle || 'classic';\n    var showCard = config.showLegend && legendStyle === 'card' && config.allStats && config.allStats.length > 0;\n\n    if (!showCard) return;\n\n    var position = config.legendPosition || 'bottom';\n    var align = config.legendAlign || 'center';\n    var container = statsCardContainers[position];\n    if (!container) return;\n\n    // Set container to flex for alignment\n    var isVertical = (position === 'left' || position === 'right');\n    var justifyMap = { left: 'flex-start', center: 'center', right: 'flex-end' };\n    var alignMap = { left: 'flex-start', center: 'center', right: 'flex-end' };\n\n    container.style.display = 'flex';\n    container.style.flexWrap = 'wrap';\n    container.style.gap = '8px';\n\n    if (isVertical) {\n        container.style.flexDirection = 'column';\n        container.style.alignItems = alignMap[align];\n        container.style.justifyContent = 'flex-start';\n    } else {\n        container.style.flexDirection = 'row';\n        container.style.justifyContent = justifyMap[align];\n        container.style.alignItems = 'flex-start';\n    }\n\n    // Create a card for each series\n    config.allStats.forEach(function(seriesInfo) {\n        var stats = seriesInfo.stats;\n        var unit = seriesInfo.units || '';\n        var dec = seriesInfo.decimals !== undefined ? seriesInfo.decimals : 2;\n        var seriesColor = seriesInfo.color || '#2196F3';\n        var colorMode = config.legendCardColorMode || 'auto';\n        var manualColor = config.legendCardColor || '#2196F3';\n\n        // Determine background color/style based on mode\n        var bgColor = colorMode === 'manual' ? manualColor : seriesColor;\n        var bgStyle;\n        if (colorMode === 'gradient') {\n            var gradientDir = isVertical ? '180deg' : '135deg';\n            bgStyle = 'linear-gradient(' + gradientDir + ', ' + bgColor + ' 0%, ' + adjustColor(bgColor, -40) + ' 100%)';\n        } else {\n            bgStyle = bgColor;\n        }\n\n        // Build the statistics card using DOM methods\n        var card = document.createElement('div');\n        card.style.cssText = 'background: ' + bgStyle + '; border-radius: 6px; padding: ' + (isVertical ? '10px 8px' : '8px 12px') + '; color: white; box-shadow: 0 2px 6px rgba(0,0,0,0.12); width: fit-content;';\n\n        // Title with series name\n        var titleEl = document.createElement('div');\n        titleEl.style.cssText = 'font-size: ' + (isVertical ? '11px' : '12px') + '; font-weight: 600; margin-bottom: 8px; opacity: 0.95;' + (isVertical ? ' text-align: center;' : '');\n        titleEl.textContent = seriesInfo.label + (unit ? ' (' + unit + ')' : '');\n        card.appendChild(titleEl);\n\n        // Statistics row\n        var statsRow = document.createElement('div');\n        statsRow.style.cssText = 'display: flex; flex-wrap: wrap; gap: 6px;' + (isVertical ? ' flex-direction: column;' : '');\n\n        legendValues.forEach(function(val) {\n            var statValue, label, icon;\n            switch(val) {\n                case 'current': statValue = stats.current; label = 'Current'; icon = '\\u25CF'; break;\n                case 'min': statValue = stats.min; label = 'Min'; icon = '\\u2193'; break;\n                case 'max': statValue = stats.max; label = 'Max'; icon = '\\u2191'; break;\n                case 'mean': statValue = stats.mean; label = 'Mean'; icon = '\\u03BC'; break;\n                case 'median': statValue = stats.median; label = 'Median'; icon = '~'; break;\n                case 'sum': statValue = stats.sum; label = 'Sum'; icon = '\\u03A3'; break;\n                case 'count': statValue = stats.count; label = 'Count'; icon = 'n'; break;\n                default: return;\n            }\n            if (statValue !== undefined && statValue !== null) {\n                var formattedVal = val === 'count' ? String(statValue) : formatValue(statValue, dec);\n\n                var statBox = document.createElement('div');\n                statBox.style.cssText = 'background: rgba(255,255,255,0.18); border-radius: 4px; padding: ' + (isVertical ? '4px 6px' : '4px 8px') + ';' + (isVertical ? ' text-align: center;' : ' min-width: 60px;');\n\n                var labelEl = document.createElement('div');\n                labelEl.style.cssText = 'font-size: 9px; opacity: 0.85;';\n                labelEl.textContent = icon + ' ' + label;\n                statBox.appendChild(labelEl);\n\n                var valueEl = document.createElement('div');\n                valueEl.style.cssText = 'font-size: ' + (isVertical ? '12px' : '13px') + '; font-weight: 600;';\n                valueEl.textContent = formattedVal;\n                statBox.appendChild(valueEl);\n\n                statsRow.appendChild(statBox);\n            }\n        });\n\n        card.appendChild(statsRow);\n\n        // Timestamp display\n        if (config.showTimestamp && stats.lastTimestamp) {\n            var timestampEl = document.createElement('div');\n            timestampEl.style.cssText = 'font-size: 9px; opacity: 0.7; margin-top: 6px;' + (isVertical ? ' text-align: center;' : '');\n            timestampEl.textContent = formatTimestamp(stats.lastTimestamp, config.timestampFormat);\n            card.appendChild(timestampEl);\n        }\n\n        container.appendChild(card);\n    });\n}\n\n// Helper function to darken/lighten a hex color\nfunction adjustColor(color, amount) {\n    var usePound = false;\n    if (color[0] === '#') {\n        color = color.slice(1);\n        usePound = true;\n    }\n\n    var num = parseInt(color, 16);\n    var r = Math.min(255, Math.max(0, (num >> 16) + amount));\n    var g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));\n    var b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));\n\n    return (usePound ? '#' : '') + (g | (b << 8) | (r << 16)).toString(16).padStart(6, '0');\n}\n\nfunction calculateStatistics(values) {\n    if (values.length === 0) {\n        return { mean: 0, median: 0, min: 0, max: 0, sum: 0, count: 0 };\n    }\n\n    var sorted = values.slice().sort(function(a, b) { return a - b; });\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n\n    return {\n        mean: sum / values.length,\n        median: percentile(sorted, 50),\n        min: sorted[0],\n        max: sorted[sorted.length - 1],\n        sum: sum,\n        count: values.length\n    };\n}\n\nfunction percentile(sortedValues, p) {\n    if (sortedValues.length === 0) return 0;\n    if (sortedValues.length === 1) return sortedValues[0];\n\n    var index = (p / 100) * (sortedValues.length - 1);\n    var lower = Math.floor(index);\n    var upper = Math.ceil(index);\n    var weight = index - lower;\n\n    if (upper >= sortedValues.length) return sortedValues[sortedValues.length - 1];\n    return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;\n}\n\nfunction removeOutliersFromData(values, timestamps, options) {\n    var method = options.method || 'iqr';\n    var cleanValues = [];\n    var cleanTimestamps = [];\n    var removed = 0;\n\n    if (method === 'manual') {\n        var minVal = options.minValue !== undefined && options.minValue !== null ? options.minValue : -Infinity;\n        var maxVal = options.maxValue !== undefined && options.maxValue !== null ? options.maxValue : Infinity;\n\n        for (var i = 0; i < values.length; i++) {\n            if (values[i] >= minVal && values[i] <= maxVal) {\n                cleanValues.push(values[i]);\n                cleanTimestamps.push(timestamps[i]);\n            } else {\n                removed++;\n            }\n        }\n    } else if (method === 'zscore') {\n        var threshold = options.zscoreThreshold || 3;\n        var stats = calculateStatistics(values);\n        var stdDev = calculateStdDev(values, stats.mean);\n\n        if (stdDev === 0) {\n            return { values: values, timestamps: timestamps, removed: 0 };\n        }\n\n        for (var j = 0; j < values.length; j++) {\n            var zscore = Math.abs((values[j] - stats.mean) / stdDev);\n            if (zscore <= threshold) {\n                cleanValues.push(values[j]);\n                cleanTimestamps.push(timestamps[j]);\n            } else {\n                removed++;\n            }\n        }\n    } else {\n        // IQR method (default)\n        var multiplier = options.iqrMultiplier || 1.5;\n        var sorted = values.slice().sort(function(a, b) { return a - b; });\n        var q1 = percentile(sorted, 25);\n        var q3 = percentile(sorted, 75);\n        var iqr = q3 - q1;\n\n        if (iqr === 0) {\n            var median = percentile(sorted, 50);\n            var range = Math.abs(median) * 0.5;\n            if (range === 0) range = 1;\n            var lowerBound = median - range;\n            var upperBound = median + range;\n\n            for (var m = 0; m < values.length; m++) {\n                if (values[m] >= lowerBound && values[m] <= upperBound) {\n                    cleanValues.push(values[m]);\n                    cleanTimestamps.push(timestamps[m]);\n                } else {\n                    removed++;\n                }\n            }\n        } else {\n            var lowerFence = q1 - (multiplier * iqr);\n            var upperFence = q3 + (multiplier * iqr);\n\n            for (var n = 0; n < values.length; n++) {\n                if (values[n] >= lowerFence && values[n] <= upperFence) {\n                    cleanValues.push(values[n]);\n                    cleanTimestamps.push(timestamps[n]);\n                } else {\n                    removed++;\n                }\n            }\n        }\n    }\n\n    return {\n        values: cleanValues,\n        timestamps: cleanTimestamps,\n        removed: removed\n    };\n}\n\nfunction calculateStdDev(values, mean) {\n    if (values.length === 0) return 0;\n    var sumSquares = 0;\n    for (var i = 0; i < values.length; i++) {\n        sumSquares += Math.pow(values[i] - mean, 2);\n    }\n    return Math.sqrt(sumSquares / values.length);\n}\n\nfunction movingAverage(values, windowSize) {\n    var result = [];\n    var halfWindow = Math.floor(windowSize / 2);\n\n    for (var i = 0; i < values.length; i++) {\n        var start = Math.max(0, i - halfWindow);\n        var end = Math.min(values.length, i + halfWindow + 1);\n        var sum = 0;\n        for (var j = start; j < end; j++) {\n            sum += values[j];\n        }\n        result.push(sum / (end - start));\n    }\n    return result;\n}\n\nfunction formatValue(value, decimals) {\n    if (value === null || value === undefined) return '-';\n    if (decimals === undefined || decimals === null) {\n        if (Math.abs(value) >= 1000) {\n            return value.toFixed(0);\n        } else if (Math.abs(value) >= 100) {\n            return value.toFixed(1);\n        } else {\n            return value.toFixed(2);\n        }\n    }\n    return value.toFixed(decimals);\n}\n\nfunction formatTimestamp(ts, format) {\n    var d = new Date(ts);\n    var year = d.getFullYear();\n    var month = String(d.getMonth() + 1).padStart(2, '0');\n    var day = String(d.getDate()).padStart(2, '0');\n    var hours = String(d.getHours()).padStart(2, '0');\n    var minutes = String(d.getMinutes()).padStart(2, '0');\n    var seconds = String(d.getSeconds()).padStart(2, '0');\n\n    // Simple format replacement\n    var result = format\n        .replace('YYYY', year)\n        .replace('MM', month)\n        .replace('DD', day)\n        .replace('HH', hours)\n        .replace('mm', minutes)\n        .replace('ss', seconds);\n\n    return result;\n}\n\n// ========================================\n// Timewindow Selector Functions\n// ========================================\n\nfunction renderTimewindowSelector() {\n    if (!timewindowSelectorContainer) return;\n\n    // Clear container\n    while (timewindowSelectorContainer.firstChild) {\n        timewindowSelectorContainer.removeChild(timewindowSelectorContainer.firstChild);\n    }\n\n    // Position mapping\n    var positionMap = { left: 'flex-start', center: 'center', right: 'flex-end' };\n    var position = twSettings.position || 'center';\n\n    timewindowSelectorContainer.style.display = 'flex';\n    timewindowSelectorContainer.style.alignItems = 'center';\n    timewindowSelectorContainer.style.justifyContent = positionMap[position] || 'center';\n    timewindowSelectorContainer.style.gap = '8px';\n    timewindowSelectorContainer.style.padding = '8px';\n\n    // Determine accent color: use custom color if set, otherwise series color\n    var accentColor = '#2196F3';\n    if (twSettings.color && twSettings.color !== '') {\n        accentColor = twSettings.color;\n    } else if (self.ctx.data && self.ctx.data[0] && self.ctx.data[0].dataKey && self.ctx.data[0].dataKey.color) {\n        accentColor = self.ctx.data[0].dataKey.color;\n    }\n\n    // Create wrapper with card-like styling\n    var wrapper = document.createElement('div');\n    wrapper.style.cssText = 'display: flex; align-items: center; gap: 6px; background: ' + accentColor + '; border-radius: 6px; padding: 6px 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.12);';\n\n    // Check if custom mode is available (has start/end configured)\n    var hasCustomRange = twSettings.customStartTime || twSettings.customEndTime;\n\n    // Previous button (hide in custom mode)\n    if (twState.mode !== 'custom') {\n        var prevBtn = createNavButton('\\u25C0', accentColor, function() {\n            navigateTimewindow(-1);\n        });\n        wrapper.appendChild(prevBtn);\n    }\n\n    // Period buttons container\n    var periodBtns = document.createElement('div');\n    periodBtns.style.cssText = 'display: flex; gap: 4px;';\n\n    // Standard period buttons\n    ['day', 'week', 'month'].forEach(function(mode) {\n        var btn = createPeriodButton(mode, accentColor);\n        periodBtns.appendChild(btn);\n    });\n\n    // Custom button (only if custom range is configured)\n    if (hasCustomRange) {\n        var customBtn = createPeriodButton('custom', accentColor);\n        periodBtns.appendChild(customBtn);\n    }\n\n    wrapper.appendChild(periodBtns);\n\n    // Next button (hide in custom mode)\n    if (twState.mode !== 'custom') {\n        var nextBtn = createNavButton('\\u25B6', accentColor, function() {\n            navigateTimewindow(1);\n        });\n        wrapper.appendChild(nextBtn);\n    }\n\n    // Current period label\n    var periodLabel = document.createElement('span');\n    periodLabel.id = 'tw-period-label';\n    periodLabel.style.cssText = 'color: white; font-size: 11px; margin-left: 8px; opacity: 0.9;';\n    periodLabel.textContent = formatPeriodLabel(twState.mode, twState.currentDate);\n    wrapper.appendChild(periodLabel);\n\n    timewindowSelectorContainer.appendChild(wrapper);\n}\n\nfunction createNavButton(symbol, accentColor, onClick) {\n    var btn = document.createElement('button');\n    btn.textContent = symbol;\n    btn.style.cssText = 'background: rgba(255,255,255,0.2); border: none; color: white; width: 24px; height: 24px; border-radius: 4px; cursor: pointer; font-size: 10px; display: flex; align-items: center; justify-content: center; transition: background 0.2s;';\n    btn.onmouseover = function() { btn.style.background = 'rgba(255,255,255,0.35)'; };\n    btn.onmouseout = function() { btn.style.background = 'rgba(255,255,255,0.2)'; };\n    btn.onclick = onClick;\n    return btn;\n}\n\nfunction createPeriodButton(mode, accentColor) {\n    var labels = { day: 'D', week: 'W', month: 'M', custom: 'C' };\n    var titles = { day: 'Day', week: 'Week', month: 'Month', custom: 'Custom Range' };\n\n    var btn = document.createElement('button');\n    btn.textContent = labels[mode];\n    btn.title = titles[mode];\n    btn.setAttribute('data-mode', mode);\n\n    var isActive = twState.mode === mode;\n    var baseStyle = 'border: none; width: 28px; height: 24px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600; transition: all 0.2s;';\n    var activeStyle = 'background: white; color: ' + accentColor + ';';\n    var inactiveStyle = 'background: rgba(255,255,255,0.2); color: white;';\n\n    btn.style.cssText = baseStyle + (isActive ? activeStyle : inactiveStyle);\n\n    btn.onmouseover = function() {\n        if (twState.mode !== mode) {\n            btn.style.background = 'rgba(255,255,255,0.35)';\n        }\n    };\n    btn.onmouseout = function() {\n        if (twState.mode !== mode) {\n            btn.style.background = 'rgba(255,255,255,0.2)';\n        }\n    };\n\n    btn.onclick = function() {\n        selectPeriodMode(mode);\n    };\n\n    return btn;\n}\n\nfunction selectPeriodMode(mode) {\n    twState.mode = mode;\n    if (mode !== 'custom') {\n        twState.currentDate = new Date(); // Reset to current date when switching mode\n    }\n    applyTimewindow();\n    renderTimewindowSelector(); // Re-render to update button styles\n}\n\nfunction navigateTimewindow(direction) {\n    var d = new Date(twState.currentDate);\n\n    switch (twState.mode) {\n        case 'day':\n            d.setDate(d.getDate() + direction);\n            break;\n        case 'week':\n            d.setDate(d.getDate() + (direction * 7));\n            break;\n        case 'month':\n            d.setMonth(d.getMonth() + direction);\n            break;\n    }\n\n    twState.currentDate = d;\n    applyTimewindow();\n    updatePeriodLabel();\n}\n\nfunction applyTimewindow() {\n    var range;\n\n    if (twState.mode === 'custom') {\n        range = calculateCustomTimeRange();\n    } else {\n        range = calculateTimeRange(twState.mode, twState.currentDate);\n    }\n\n    if (!range) return;\n\n    // Build timewindow object with aggregation settings\n    var timewindow = {\n        history: {\n            fixedTimewindow: {\n                startTimeMs: range.start,\n                endTimeMs: range.end\n            },\n            historyType: 0  // Fixed timewindow\n        },\n        aggregation: {\n            type: twSettings.aggregationType || 'NONE',\n            limit: twSettings.maxDataPoints || 100000\n        }\n    };\n\n    // Check if widget uses dashboard timewindow or its own\n    // Respects the Data tab setting: Use dashboard time window vs Use widget time window\n    var useDashboardTimewindow = self.ctx.widget.config.useDashboardTimewindow;\n\n    if (useDashboardTimewindow !== false) {\n        // Use dashboard timewindow (default behavior)\n        if (self.ctx.dashboard && self.ctx.dashboard.updateDashboardTimewindow) {\n            self.ctx.dashboard.updateDashboardTimewindow(timewindow);\n        } else if (self.ctx.dashboard && self.ctx.dashboard.onUpdateTimewindow) {\n            self.ctx.dashboard.onUpdateTimewindow(range.start, range.end);\n        }\n    } else {\n        // Use widget's own timewindow (when 'Use widget time window' is selected)\n        if (self.ctx.timewindowFunctions && self.ctx.timewindowFunctions.onUpdateTimewindow) {\n            self.ctx.timewindowFunctions.onUpdateTimewindow(range.start, range.end);\n        }\n    }\n}\n\nfunction calculateCustomTimeRange() {\n    var startStr = twSettings.customStartTime || '';\n    var endStr = twSettings.customEndTime || '';\n\n    // Resolve variables in start/end strings\n    var startMs = resolveTimeValue(startStr);\n    var endMs = resolveTimeValue(endStr);\n\n    // Fallback to current day if values couldn't be resolved\n    if (startMs === null) {\n        var now = new Date();\n        startMs = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0).getTime();\n    }\n    if (endMs === null) {\n        var now2 = new Date();\n        endMs = new Date(now2.getFullYear(), now2.getMonth(), now2.getDate(), 23, 59, 59, 999).getTime();\n    }\n\n    return { start: startMs, end: endMs };\n}\n\nfunction resolveTimeValue(valueStr) {\n    if (!valueStr || valueStr === '') return null;\n\n    // Check if it's a variable placeholder like ${attributeName}\n    var varMatch = valueStr.match(/^\\$\\{(.+)\\}$/);\n    if (varMatch) {\n        var attrName = varMatch[1];\n        return resolveEntityAttribute(attrName);\n    }\n\n    // Try to parse as number (milliseconds timestamp)\n    var numVal = Number(valueStr);\n    if (!isNaN(numVal) && numVal > 0) {\n        return numVal;\n    }\n\n    // Try to parse as ISO date string\n    var dateVal = Date.parse(valueStr);\n    if (!isNaN(dateVal)) {\n        return dateVal;\n    }\n\n    return null;\n}\n\nfunction resolveEntityAttribute(attrName) {\n    // Try to get attribute from the first datasource entity\n    if (self.ctx.datasources && self.ctx.datasources.length > 0) {\n        var ds = self.ctx.datasources[0];\n\n        // Check entity attributes if available\n        if (ds.entity) {\n            // Try server attributes\n            if (ds.entity.attributes && ds.entity.attributes[attrName] !== undefined) {\n                return Number(ds.entity.attributes[attrName]);\n            }\n            // Try shared attributes\n            if (ds.entity.sharedAttributes && ds.entity.sharedAttributes[attrName] !== undefined) {\n                return Number(ds.entity.sharedAttributes[attrName]);\n            }\n        }\n\n        // Check latestData in context (for latest values)\n        if (self.ctx.latestData) {\n            for (var i = 0; i < self.ctx.latestData.length; i++) {\n                var ld = self.ctx.latestData[i];\n                if (ld.dataKey && ld.dataKey.name === attrName && ld.data && ld.data.length > 0) {\n                    return Number(ld.data[ld.data.length - 1][1]);\n                }\n            }\n        }\n    }\n\n    // Try dashboard state aliases or variables\n    if (self.ctx.dashboard && self.ctx.dashboard.aliasController) {\n        var aliasController = self.ctx.dashboard.aliasController;\n        // This depends on ThingsBoard API - may need adjustment\n    }\n\n    return null;\n}\n\nfunction calculateTimeRange(mode, referenceDate) {\n    var start, end;\n    var d = new Date(referenceDate);\n\n    switch (mode) {\n        case 'day':\n            // Start of day (00:00:00)\n            start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);\n            // End of day (23:59:59.999)\n            end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999);\n            break;\n\n        case 'week':\n            // Find Monday of current week (week starts on Monday)\n            var dayOfWeek = d.getDay();\n            var diffToMonday = (dayOfWeek === 0 ? -6 : 1) - dayOfWeek;\n            var monday = new Date(d);\n            monday.setDate(d.getDate() + diffToMonday);\n            start = new Date(monday.getFullYear(), monday.getMonth(), monday.getDate(), 0, 0, 0, 0);\n            // Sunday end of week\n            var sunday = new Date(monday);\n            sunday.setDate(monday.getDate() + 6);\n            end = new Date(sunday.getFullYear(), sunday.getMonth(), sunday.getDate(), 23, 59, 59, 999);\n            break;\n\n        case 'month':\n            // Start of month\n            start = new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);\n            // End of month\n            end = new Date(d.getFullYear(), d.getMonth() + 1, 0, 23, 59, 59, 999);\n            break;\n    }\n\n    return { start: start.getTime(), end: end.getTime() };\n}\n\nfunction formatPeriodLabel(mode, date) {\n    var d = new Date(date);\n\n    switch (mode) {\n        case 'day':\n            return formatDateString(d, twSettings.dayFormat || 'D MMM YYYY');\n\n        case 'week':\n            var range = calculateTimeRange('week', d);\n            var startD = new Date(range.start);\n            var endD = new Date(range.end);\n            // For week, format depends on whether months are same\n            var weekFormat = twSettings.weekFormat || 'D-D MMM';\n            if (startD.getMonth() === endD.getMonth()) {\n                return startD.getDate() + '-' + endD.getDate() + ' ' + getMonthShort(startD.getMonth());\n            } else {\n                return startD.getDate() + ' ' + getMonthShort(startD.getMonth()) + ' - ' + endD.getDate() + ' ' + getMonthShort(endD.getMonth());\n            }\n\n        case 'month':\n            return formatDateString(d, twSettings.monthFormat || 'MMM YYYY');\n\n        case 'custom':\n            var customRange = calculateCustomTimeRange();\n            if (customRange) {\n                var startDate = new Date(customRange.start);\n                var endDate = new Date(customRange.end);\n                return formatDateString(startDate, 'DD.MM.YY') + ' - ' + formatDateString(endDate, 'DD.MM.YY');\n            }\n            return 'Custom';\n    }\n\n    return '';\n}\n\nfunction formatDateString(date, format) {\n    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n    var d = new Date(date);\n\n    return format\n        .replace('YYYY', d.getFullYear())\n        .replace('YY', String(d.getFullYear()).slice(-2))\n        .replace('MMM', months[d.getMonth()])\n        .replace('MM', String(d.getMonth() + 1).padStart(2, '0'))\n        .replace('DD', String(d.getDate()).padStart(2, '0'))\n        .replace('D', d.getDate());\n}\n\nfunction getMonthShort(monthIndex) {\n    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n    return months[monthIndex];\n}\n\nfunction updatePeriodLabel() {\n    var labelEl = document.getElementById('tw-period-label');\n    if (labelEl) {\n        labelEl.textContent = formatPeriodLabel(twState.mode, twState.currentDate);\n    }\n}\n\n// ========================================\n// End Timewindow Selector Functions\n// ========================================\n\nfunction showNoData(message) {\n    if (!chart) return;\n    chart.setOption({\n        title: {\n            text: message,\n            left: 'center',\n            top: 'middle',\n            textStyle: { color: '#999', fontSize: 14 }\n        }\n    }, true);\n}\n\nfunction getDefaultColor(index) {\n    var colors = ['#2196F3', '#4CAF50', '#FF9800', '#E91E63', '#9C27B0', '#00BCD4', '#795548', '#607D8B'];\n    return colors[index % colors.length];\n}\n\nfunction buildChartOption(config) {\n    var seriesConfigs = config.seriesConfigs;\n    var chartType = config.chartType || 'line';\n    var smoothLine = config.smoothLine !== false;\n    var chartLayout = config.chartLayout || 'combined';\n\n    // Build legend data\n    var legendData = [];\n    for (var i = 0; i < seriesConfigs.length; i++) {\n        legendData.push(seriesConfigs[i].label);\n    }\n\n    // Calculate margins\n    var legendStyle = config.legendStyle || 'classic';\n    var legendPosition = config.legendPosition || 'bottom';\n    var useStatsCard = legendStyle === 'card';\n    var legendMargin = (config.showLegend && !useStatsCard) ? 35 : 0;\n\n    var topMargin = 40;\n    var bottomMargin = config.showDataZoomSlider ? 60 : 40;\n    var leftMargin = 60;\n    var rightMargin = 20;\n\n    if (!useStatsCard) {\n        if (legendPosition === 'top') topMargin += legendMargin;\n        if (legendPosition === 'bottom') bottomMargin += legendMargin;\n        if (legendPosition === 'left') leftMargin += legendMargin;\n        if (legendPosition === 'right') rightMargin += legendMargin;\n    }\n\n    // Handle separate chart layout (per datasource)\n    var datasourceOrder = config.datasourceOrder || [];\n    var datasourceGroups = config.datasourceGroups || {};\n    if (chartLayout === 'separate' && datasourceOrder.length > 1) {\n        return buildSeparateChartsOption(config, {\n            legendData: legendData,\n            topMargin: topMargin,\n            bottomMargin: bottomMargin,\n            leftMargin: leftMargin,\n            rightMargin: rightMargin,\n            useStatsCard: useStatsCard,\n            legendPosition: legendPosition\n        });\n    }\n\n    // Combined chart layout (default)\n    var series = [];\n    for (var j = 0; j < seriesConfigs.length; j++) {\n        var sc = seriesConfigs[j];\n        var seriesConfig = {\n            name: sc.label,\n            type: chartType === 'scatter' ? 'scatter' : (chartType === 'bar' ? 'bar' : 'line'),\n            data: sc.data,\n            yAxisIndex: sc.yAxisIndex,\n            smooth: smoothLine && chartType === 'line',\n            symbol: chartType === 'line' ? 'none' : (chartType === 'scatter' ? 'circle' : undefined),\n            symbolSize: chartType === 'scatter' ? 8 : undefined,\n            lineStyle: { color: sc.color, width: 2 },\n            itemStyle: { color: sc.color }\n        };\n\n        if (chartType === 'area') {\n            seriesConfig.type = 'line';\n            seriesConfig.areaStyle = { color: sc.color, opacity: 0.3 };\n            seriesConfig.smooth = smoothLine;\n            seriesConfig.symbol = 'none';\n        }\n\n        series.push(seriesConfig);\n    }\n\n    // Build Y-axes for combined mode - use label (units) format\n    var firstAxisLabel = '';\n    if (seriesConfigs[0]) {\n        firstAxisLabel = seriesConfigs[0].label || '';\n        if (seriesConfigs[0].units) {\n            firstAxisLabel += ' (' + seriesConfigs[0].units + ')';\n        }\n    }\n    var yAxes = [{\n        type: 'value',\n        name: firstAxisLabel,\n        nameLocation: 'middle',\n        nameGap: 45,\n        min: config.yAxisMin,\n        max: config.yAxisMax,\n        axisLabel: { fontSize: 10 },\n        splitLine: { lineStyle: { type: 'dashed', opacity: 0.3 } }\n    }];\n\n    if (config.hasSecondAxis) {\n        var secondAxisLabel = '';\n        for (var k = 0; k < seriesConfigs.length; k++) {\n            if (seriesConfigs[k].yAxisIndex === 1) {\n                secondAxisLabel = seriesConfigs[k].label || '';\n                if (seriesConfigs[k].units) {\n                    secondAxisLabel += ' (' + seriesConfigs[k].units + ')';\n                }\n                break;\n            }\n        }\n        yAxes.push({\n            type: 'value',\n            name: secondAxisLabel,\n            nameLocation: 'middle',\n            nameGap: 45,\n            min: config.yAxis2Min,\n            max: config.yAxis2Max,\n            axisLabel: { fontSize: 10 },\n            splitLine: { show: false }\n        });\n        rightMargin = 60;\n    }\n\n    // Build legend config (only for classic style)\n    var legendConfig = buildLegendConfig(config, legendData, useStatsCard, legendPosition);\n\n    // Build toolbox\n    var toolboxConfig = buildToolboxConfig(config);\n\n    // Build dataZoom\n    var dataZoomConfig = [\n        { type: 'inside', xAxisIndex: 0 }\n    ];\n\n    if (config.showDataZoomSlider) {\n        dataZoomConfig.push({\n            type: 'slider',\n            xAxisIndex: 0,\n            bottom: 5,\n            height: 20\n        });\n    }\n\n    // Build tooltip\n    var tooltipConfig = buildTooltipConfig(chartType);\n\n    return {\n        tooltip: tooltipConfig,\n        legend: legendConfig,\n        toolbox: toolboxConfig,\n        grid: {\n            left: leftMargin,\n            right: rightMargin,\n            top: topMargin,\n            bottom: bottomMargin\n        },\n        xAxis: {\n            type: 'time',\n            axisLabel: { fontSize: 10 },\n            splitLine: { show: false }\n        },\n        yAxis: yAxes,\n        dataZoom: dataZoomConfig,\n        series: series\n    };\n}\n\nfunction buildSeparateChartsOption(config, margins) {\n    var datasourceGroups = config.datasourceGroups || {};\n    var datasourceOrder = config.datasourceOrder || [];\n    var chartType = config.chartType || 'line';\n    var smoothLine = config.smoothLine !== false;\n    var numCharts = datasourceOrder.length;\n\n    // Layout parameters (all in %)\n    var topReserved = 4;     // Space at top\n    var bottomReserved = config.showDataZoomSlider ? 18 : 10;  // Space for slider + X-axis labels\n    var gapBetween = 4;      // Gap between charts\n\n    // Calculate chart height\n    // Available = 100 - top - bottom - gaps\n    // Gaps = (numCharts - 1) * gapBetween\n    var totalGaps = (numCharts - 1) * gapBetween;\n    var availableHeight = 100 - topReserved - bottomReserved - totalGaps;\n    var chartHeight = availableHeight / numCharts;\n\n    var grids = [];\n    var xAxes = [];\n    var yAxes = [];\n    var series = [];\n\n    for (var i = 0; i < numCharts; i++) {\n        var dsId = datasourceOrder[i];\n        var dsGroup = datasourceGroups[dsId];\n        var isLastChart = (i === numCharts - 1);\n\n        // Calculate position for this chart\n        // Each chart starts after: top + (previous charts * height) + (previous gaps)\n        var chartTop = topReserved + (i * chartHeight) + (i * gapBetween);\n        var chartBottom = 100 - chartTop - chartHeight;\n\n        // Grid for this datasource (extra left margin for vertical y-axis label)\n        grids.push({\n            left: margins.leftMargin + 15,\n            right: margins.rightMargin + 10,\n            top: chartTop + '%',\n            bottom: chartBottom + '%'\n        });\n\n        // X-axis for this chart\n        xAxes.push({\n            type: 'time',\n            gridIndex: i,\n            axisLabel: {\n                show: isLastChart, // Only show labels on last chart\n                fontSize: 10\n            },\n            axisTick: { show: isLastChart },\n            axisLine: { show: true },\n            splitLine: { show: false }\n        });\n\n        // Y-axis for this chart - build label from series labels and units\n        var yAxisLabels = [];\n        for (var si = 0; si < dsGroup.series.length; si++) {\n            var s = dsGroup.series[si];\n            var labelText = s.label || '';\n            if (s.units) {\n                labelText += ' (' + s.units + ')';\n            }\n            if (labelText && yAxisLabels.indexOf(labelText) === -1) {\n                yAxisLabels.push(labelText);\n            }\n        }\n        // Use line break for multiple series\n        var yAxisName = yAxisLabels.length > 1 ? yAxisLabels.join('\\n') : yAxisLabels[0] || '';\n\n        yAxes.push({\n            type: 'value',\n            gridIndex: i,\n            name: yAxisName,\n            nameLocation: 'middle',\n            nameGap: 45,\n            nameTextStyle: { fontSize: 11 },\n            axisLabel: { fontSize: 10 },\n            splitLine: { lineStyle: { type: 'dashed', opacity: 0.3 } }\n        });\n\n        // Add all series from this datasource to this chart\n        for (var j = 0; j < dsGroup.series.length; j++) {\n            var sc = dsGroup.series[j];\n            var seriesConfig = {\n                name: sc.label,\n                type: chartType === 'scatter' ? 'scatter' : (chartType === 'bar' ? 'bar' : 'line'),\n                data: sc.data,\n                xAxisIndex: i,\n                yAxisIndex: i,\n                smooth: smoothLine && chartType === 'line',\n                symbol: chartType === 'line' ? 'none' : (chartType === 'scatter' ? 'circle' : undefined),\n                symbolSize: chartType === 'scatter' ? 8 : undefined,\n                lineStyle: { color: sc.color, width: 2 },\n                itemStyle: { color: sc.color }\n            };\n\n            if (chartType === 'area') {\n                seriesConfig.type = 'line';\n                seriesConfig.areaStyle = { color: sc.color, opacity: 0.3 };\n                seriesConfig.smooth = smoothLine;\n                seriesConfig.symbol = 'none';\n            }\n\n            series.push(seriesConfig);\n        }\n    }\n\n    // Build xAxisIndex array for dataZoom (connect all x-axes)\n    var xAxisIndices = [];\n    for (var k = 0; k < numCharts; k++) {\n        xAxisIndices.push(k);\n    }\n\n    // Build dataZoom that syncs all charts - more space at bottom\n    var dataZoomConfig = [\n        {\n            type: 'inside',\n            xAxisIndex: xAxisIndices\n        }\n    ];\n\n    if (config.showDataZoomSlider) {\n        dataZoomConfig.push({\n            type: 'slider',\n            xAxisIndex: xAxisIndices,\n            bottom: 10,\n            height: 25,\n            borderColor: '#ddd',\n            backgroundColor: '#fafafa',\n            fillerColor: 'rgba(33, 150, 243, 0.2)',\n            handleStyle: { color: '#2196F3' }\n        });\n    }\n\n    // Build legend config\n    var legendConfig = buildLegendConfig(config, margins.legendData, margins.useStatsCard, margins.legendPosition);\n\n    // Build toolbox\n    var toolboxConfig = buildToolboxConfig(config);\n\n    // Build tooltip for separate charts\n    var tooltipConfig = {\n        trigger: 'axis',\n        axisPointer: {\n            type: 'line',\n            link: [{ xAxisIndex: 'all' }]\n        },\n        formatter: function(params) {\n            if (!params || !params.length) return '';\n            var d = new Date(params[0].value[0]);\n            var result = '<b>' + d.toLocaleString() + '</b><br/>';\n\n            for (var i = 0; i < params.length; i++) {\n                var p = params[i];\n                if (p.value && p.value[1] !== null && p.value[1] !== undefined) {\n                    result += '<span style=\"display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + p.color + ';\"></span>';\n                    result += p.seriesName + ': ' + p.value[1].toFixed(2) + '<br/>';\n                }\n            }\n            return result;\n        }\n    };\n\n    // Add axisPointer link for synchronized crosshair\n    var axisPointerConfig = {\n        link: [{ xAxisIndex: 'all' }]\n    };\n\n    return {\n        tooltip: tooltipConfig,\n        axisPointer: axisPointerConfig,\n        legend: legendConfig,\n        toolbox: toolboxConfig,\n        grid: grids,\n        xAxis: xAxes,\n        yAxis: yAxes,\n        dataZoom: dataZoomConfig,\n        series: series\n    };\n}\n\nfunction buildLegendConfig(config, legendData, useStatsCard, legendPosition) {\n    if (!config.showLegend || useStatsCard) return null;\n\n    var legendConfig = {\n        data: legendData,\n        textStyle: { fontSize: 11 }\n    };\n\n    switch (legendPosition) {\n        case 'top':\n            legendConfig.top = 5;\n            legendConfig.left = 'center';\n            legendConfig.orient = 'horizontal';\n            break;\n        case 'bottom':\n            legendConfig.bottom = config.showDataZoomSlider ? 30 : 5;\n            legendConfig.left = 'center';\n            legendConfig.orient = 'horizontal';\n            break;\n        case 'left':\n            legendConfig.left = 5;\n            legendConfig.top = 'middle';\n            legendConfig.orient = 'vertical';\n            break;\n        case 'right':\n            legendConfig.right = 5;\n            legendConfig.top = 'middle';\n            legendConfig.orient = 'vertical';\n            break;\n        default:\n            legendConfig.bottom = config.showDataZoomSlider ? 30 : 5;\n            legendConfig.left = 'center';\n            legendConfig.orient = 'horizontal';\n    }\n\n    return legendConfig;\n}\n\nfunction buildToolboxConfig(config) {\n    if (!config.showToolbox) return null;\n\n    var toolboxConfig = {\n        show: true,\n        right: 10,\n        top: 5,\n        feature: {}\n    };\n\n    if (config.showSaveAsImage) {\n        toolboxConfig.feature.saveAsImage = {\n            show: true,\n            title: 'Save as PNG',\n            pixelRatio: 2\n        };\n    }\n\n    if (config.showDataView) {\n        toolboxConfig.feature.dataView = {\n            show: true,\n            title: 'Data View',\n            readOnly: true,\n            lang: ['Data View', 'Close', 'Refresh'],\n            optionToContent: function(opt) {\n                var seriesList = opt.series || [];\n                var html = '<div style=\"padding: 12px; font-family: -apple-system, BlinkMacSystemFont, sans-serif;\">';\n\n                for (var i = 0; i < seriesList.length; i++) {\n                    var s = seriesList[i];\n                    var data = s.data || [];\n                    if (data.length === 0) continue;\n\n                    html += '<div style=\"font-size: 14px; font-weight: 600; margin: 12px 0 8px 0;\">' + s.name + ' (' + data.length + ' points)</div>';\n                    html += '<div style=\"max-height: 300px; overflow: auto; border: 1px solid #e5e7eb; border-radius: 6px;\">';\n                    html += '<table style=\"width: 100%; border-collapse: collapse; font-size: 12px;\">';\n                    html += '<thead style=\"position: sticky; top: 0; background: #f9fafb;\">';\n                    html += '<tr><th style=\"padding: 8px; text-align: left; border-bottom: 2px solid #e5e7eb;\">Timestamp</th>';\n                    html += '<th style=\"padding: 8px; text-align: right; border-bottom: 2px solid #e5e7eb;\">Value</th></tr></thead>';\n                    html += '<tbody>';\n\n                    for (var j = 0; j < data.length; j++) {\n                        var row = data[j];\n                        var d = new Date(row[0]);\n                        var ts = d.getFullYear() + '-' +\n                            String(d.getMonth() + 1).padStart(2, '0') + '-' +\n                            String(d.getDate()).padStart(2, '0') + ' ' +\n                            String(d.getHours()).padStart(2, '0') + ':' +\n                            String(d.getMinutes()).padStart(2, '0') + ':' +\n                            String(d.getSeconds()).padStart(2, '0');\n                        var rowBg = j % 2 === 0 ? '#ffffff' : '#f9fafb';\n                        html += '<tr style=\"background: ' + rowBg + ';\">';\n                        html += '<td style=\"padding: 6px 8px; font-family: monospace; font-size: 11px;\">' + ts + '</td>';\n                        html += '<td style=\"padding: 6px 8px; text-align: right; font-weight: 500;\">' + (row[1] !== null ? row[1].toFixed(2) : '-') + '</td>';\n                        html += '</tr>';\n                    }\n\n                    html += '</tbody></table></div>';\n                }\n\n                html += '</div>';\n                return html;\n            }\n        };\n    }\n\n    if (config.showDataZoom) {\n        toolboxConfig.feature.dataZoom = {\n            show: true,\n            title: { zoom: 'Zoom', back: 'Reset Zoom' }\n        };\n    }\n\n    if (config.showRestore) {\n        toolboxConfig.feature.restore = {\n            show: true,\n            title: 'Restore'\n        };\n    }\n\n    return toolboxConfig;\n}\n\nfunction buildTooltipConfig(chartType) {\n    return {\n        trigger: 'axis',\n        axisPointer: { type: chartType === 'bar' ? 'shadow' : 'cross' },\n        formatter: function(params) {\n            if (!params || !params.length) return '';\n            var d = new Date(params[0].value[0]);\n            var result = d.toLocaleString() + '<br/>';\n\n            for (var i = 0; i < params.length; i++) {\n                var p = params[i];\n                if (p.value && p.value[1] !== null && p.value[1] !== undefined) {\n                    result += '<span style=\"display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + p.color + ';\"></span>';\n                    result += p.seriesName + ': ' + p.value[1].toFixed(2) + '<br/>';\n                }\n            }\n            return result;\n        }\n    };\n}\n\nself.onResize = function() {\n    if (chart && chartContainer) {\n        // Use explicit dimensions for reliable resize\n        chart.resize({\n            width: chartContainer.offsetWidth,\n            height: chartContainer.offsetHeight\n        });\n    }\n};\n\nself.onDestroy = function() {\n    if (resizeObserver) {\n        resizeObserver.disconnect();\n        resizeObserver = null;\n    }\n    if (chart) {\n        chart.dispose();\n        chart = null;\n    }\n};\n\nself.typeParameters = function() {\n    return {\n        previewWidth: '100%',\n        previewHeight: '100%',\n        embedTitlePanel: false,\n        hasDataExportAction: true,\n        dataKeySettingsFunction: function() { return {}; },\n        defaultDataKeysFunction: function() {\n            return [{\n                name: 'temperature',\n                label: 'Temperature',\n                type: 'timeseries',\n                units: '',\n                decimals: 1\n            }];\n        }\n    };\n};\n",
    "settingsSchema": {
      "schema": {
        "type": "object",
        "title": "ECO Timeseries Zoom Sync Settings",
        "properties": {
          "chartType": {
            "title": "Chart Type",
            "type": "string",
            "default": "line",
            "enum": [
              "line",
              "bar",
              "area",
              "scatter"
            ]
          },
          "smoothLine": {
            "title": "Smooth Lines",
            "type": "boolean",
            "default": true
          },
          "chartLayout": {
            "title": "Chart Layout",
            "type": "string",
            "default": "combined",
            "enum": [
              "combined",
              "separate"
            ]
          },
          "showLegend": {
            "title": "Show Legend",
            "type": "boolean",
            "default": true
          },
          "legendStyle": {
            "title": "Legend Style",
            "type": "string",
            "default": "classic",
            "enum": [
              "classic",
              "card"
            ]
          },
          "legendPosition": {
            "title": "Legend Position",
            "type": "string",
            "default": "bottom",
            "enum": [
              "top",
              "bottom",
              "left",
              "right"
            ]
          },
          "legendAlign": {
            "title": "Legend Alignment",
            "type": "string",
            "default": "center",
            "enum": [
              "left",
              "center",
              "right"
            ]
          },
          "legendCardColorMode": {
            "title": "Card Color Mode",
            "type": "string",
            "default": "auto",
            "enum": [
              "auto",
              "manual",
              "gradient"
            ]
          },
          "legendCardColor": {
            "title": "Card Color",
            "type": "string",
            "default": "#2196F3"
          },
          "legendValues": {
            "title": "Statistics to Display",
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": [
              "current"
            ]
          },
          "showTimestamp": {
            "title": "Show Timestamp",
            "type": "boolean",
            "default": true
          },
          "timestampFormat": {
            "title": "Timestamp Format",
            "type": "string",
            "default": "YYYY-MM-DD HH:mm:ss"
          },
          "showDataZoomSlider": {
            "title": "Show Zoom Slider",
            "type": "boolean",
            "default": true
          },
          "yAxisMin": {
            "title": "Y-Axis Minimum",
            "type": "number"
          },
          "yAxisMax": {
            "title": "Y-Axis Maximum",
            "type": "number"
          },
          "yAxis2Min": {
            "title": "Second Y-Axis Minimum",
            "type": "number"
          },
          "yAxis2Max": {
            "title": "Second Y-Axis Maximum",
            "type": "number"
          },
          "removeOutliers": {
            "title": "Remove Outliers",
            "type": "boolean",
            "default": false
          },
          "outlierMethod": {
            "title": "Outlier Method",
            "type": "string",
            "default": "iqr",
            "enum": [
              "iqr",
              "zscore",
              "manual"
            ]
          },
          "outlierIqrMultiplier": {
            "title": "IQR Multiplier",
            "type": "number",
            "default": 1.5
          },
          "outlierZscoreThreshold": {
            "title": "Z-Score Threshold",
            "type": "number",
            "default": 3
          },
          "outlierMinValue": {
            "title": "Minimum Value",
            "type": "number"
          },
          "outlierMaxValue": {
            "title": "Maximum Value",
            "type": "number"
          },
          "smoothingEnabled": {
            "title": "Enable Smoothing",
            "type": "boolean",
            "default": false
          },
          "smoothingWindowMinutes": {
            "title": "Smoothing Window (minutes)",
            "type": "number",
            "default": 15
          },
          "showToolbox": {
            "title": "Show Toolbox",
            "type": "boolean",
            "default": true
          },
          "toolboxFeatures": {
            "title": "Toolbox Features",
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": [
              "saveAsImage",
              "dataView",
              "dataZoom",
              "restore"
            ]
          },
          "showTimewindowSelector": {
            "title": "Show Timewindow Selector",
            "type": "boolean",
            "default": false
          },
          "twSelectorColor": {
            "title": "Selector Color",
            "type": "string",
            "default": ""
          },
          "twSelectorPosition": {
            "title": "Selector Position",
            "type": "string",
            "default": "center",
            "enum": [
              "left",
              "center",
              "right"
            ]
          },
          "twSelectorDayFormat": {
            "title": "Day Format",
            "type": "string",
            "default": "D MMM YYYY"
          },
          "twSelectorWeekFormat": {
            "title": "Week Format",
            "type": "string",
            "default": "D-D MMM"
          },
          "twSelectorMonthFormat": {
            "title": "Month Format",
            "type": "string",
            "default": "MMM YYYY"
          },
          "twCustomStartTime": {
            "title": "Custom Start Time",
            "type": "string",
            "default": ""
          },
          "twCustomEndTime": {
            "title": "Custom End Time",
            "type": "string",
            "default": ""
          },
          "twAggregationType": {
            "title": "Aggregation",
            "type": "string",
            "default": "NONE",
            "enum": [
              "NONE",
              "AVG",
              "MIN",
              "MAX",
              "SUM",
              "COUNT"
            ]
          },
          "twMaxDataPoints": {
            "title": "Max Data Points",
            "type": "number",
            "default": 100000
          }
        },
        "required": []
      },
      "form": [
        [
          {
            "key": "chartType",
            "type": "rc-select",
            "multiple": false,
            "items": [
              {
                "value": "line",
                "label": "Line Chart"
              },
              {
                "value": "bar",
                "label": "Bar Chart"
              },
              {
                "value": "area",
                "label": "Area Chart"
              },
              {
                "value": "scatter",
                "label": "Scatter Plot"
              }
            ]
          },
          {
            "key": "smoothLine",
            "condition": "model.chartType === 'line' || model.chartType === 'area'"
          },
          {
            "key": "chartLayout",
            "type": "rc-select",
            "multiple": false,
            "items": [
              {
                "value": "combined",
                "label": "Combined (Single Chart)"
              },
              {
                "value": "separate",
                "label": "Separate Charts (Synced Zoom)"
              }
            ]
          },
          "showDataZoomSlider"
        ],
        [
          "showLegend",
          {
            "key": "legendStyle",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true",
            "items": [
              {
                "value": "classic",
                "label": "Classic (Text)"
              },
              {
                "value": "card",
                "label": "Statistics Card"
              }
            ]
          },
          {
            "key": "legendPosition",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true",
            "items": [
              {
                "value": "top",
                "label": "Top"
              },
              {
                "value": "bottom",
                "label": "Bottom"
              },
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "legendAlign",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "center",
                "label": "Center"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "legendCardColorMode",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "auto",
                "label": "Auto (Series Color)"
              },
              {
                "value": "manual",
                "label": "Manual Color"
              },
              {
                "value": "gradient",
                "label": "Gradient"
              }
            ]
          },
          {
            "key": "legendCardColor",
            "type": "color",
            "condition": "model.showLegend === true && model.legendStyle === 'card' && model.legendCardColorMode === 'manual'"
          },
          {
            "key": "legendValues",
            "type": "rc-select",
            "multiple": true,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "current",
                "label": "Current Value"
              },
              {
                "value": "min",
                "label": "Minimum"
              },
              {
                "value": "max",
                "label": "Maximum"
              },
              {
                "value": "mean",
                "label": "Mean"
              },
              {
                "value": "median",
                "label": "Median"
              },
              {
                "value": "sum",
                "label": "Sum"
              },
              {
                "value": "count",
                "label": "Count"
              }
            ]
          },
          {
            "key": "showTimestamp",
            "condition": "model.showLegend === true && model.legendStyle === 'card'"
          },
          {
            "key": "timestampFormat",
            "condition": "model.showLegend === true && model.legendStyle === 'card' && model.showTimestamp === true"
          }
        ],
        [
          "yAxisMin",
          "yAxisMax",
          "yAxis2Min",
          "yAxis2Max"
        ],
        [
          "removeOutliers",
          {
            "key": "outlierMethod",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.removeOutliers === true",
            "items": [
              {
                "value": "iqr",
                "label": "IQR (Interquartile Range)"
              },
              {
                "value": "zscore",
                "label": "Z-Score"
              },
              {
                "value": "manual",
                "label": "Manual Thresholds"
              }
            ]
          },
          {
            "key": "outlierIqrMultiplier",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'iqr'"
          },
          {
            "key": "outlierZscoreThreshold",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'zscore'"
          },
          {
            "key": "outlierMinValue",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'manual'"
          },
          {
            "key": "outlierMaxValue",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'manual'"
          },
          "smoothingEnabled",
          {
            "key": "smoothingWindowMinutes",
            "condition": "model.smoothingEnabled === true"
          }
        ],
        [
          "showToolbox",
          {
            "key": "toolboxFeatures",
            "type": "rc-select",
            "multiple": true,
            "condition": "model.showToolbox === true",
            "items": [
              {
                "value": "saveAsImage",
                "label": "Save as Image"
              },
              {
                "value": "dataView",
                "label": "Data View"
              },
              {
                "value": "dataZoom",
                "label": "Data Zoom"
              },
              {
                "value": "restore",
                "label": "Restore"
              }
            ]
          }
        ],
        [
          "showTimewindowSelector",
          {
            "key": "twSelectorColor",
            "type": "color",
            "condition": "model.showTimewindowSelector === true",
            "description": "Leave empty for auto (uses series color)"
          },
          {
            "key": "twSelectorPosition",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "center",
                "label": "Center"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "twSelectorDayFormat",
            "condition": "model.showTimewindowSelector === true",
            "description": "Format: D=day, DD=day(2), MMM=month, MM=month(2), YYYY=year, YY=year(2)"
          },
          {
            "key": "twSelectorWeekFormat",
            "condition": "model.showTimewindowSelector === true"
          },
          {
            "key": "twSelectorMonthFormat",
            "condition": "model.showTimewindowSelector === true"
          },
          {
            "key": "twCustomStartTime",
            "condition": "model.showTimewindowSelector === true",
            "description": "Use ${attributeName} for entity attributes, e.g. ${startTimeMs}"
          },
          {
            "key": "twCustomEndTime",
            "condition": "model.showTimewindowSelector === true",
            "description": "Use ${attributeName} for entity attributes, e.g. ${endTimeMs}"
          },
          {
            "key": "twAggregationType",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "NONE",
                "label": "None (Raw Data)"
              },
              {
                "value": "AVG",
                "label": "Average"
              },
              {
                "value": "MIN",
                "label": "Minimum"
              },
              {
                "value": "MAX",
                "label": "Maximum"
              },
              {
                "value": "SUM",
                "label": "Sum"
              },
              {
                "value": "COUNT",
                "label": "Count"
              }
            ]
          },
          {
            "key": "twMaxDataPoints",
            "condition": "model.showTimewindowSelector === true",
            "description": "Maximum number of data points to fetch (default: 100000)"
          }
        ]
      ],
      "groupInfoes": [
        {
          "formIndex": 0,
          "GroupTitle": "Chart Settings"
        },
        {
          "formIndex": 1,
          "GroupTitle": "Legend Settings"
        },
        {
          "formIndex": 2,
          "GroupTitle": "Y-Axis Settings"
        },
        {
          "formIndex": 3,
          "GroupTitle": "Data Processing"
        },
        {
          "formIndex": 4,
          "GroupTitle": "Toolbox Settings"
        },
        {
          "formIndex": 5,
          "GroupTitle": "Timewindow Selector"
        }
      ]
    },
    "dataKeySettingsSchema": {},
    "latestDataKeySettingsSchema": {},
    "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Temperature\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.456,\"funcBody\":\"var value = prevValue + Math.random() * 10 - 5;\\nif (value < 0) value = 0;\\nif (value > 100) value = 100;\\nreturn value;\",\"units\":\"C\",\"decimals\":1},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Humidity\",\"color\":\"#4CAF50\",\"settings\":{},\"_hash\":0.789,\"funcBody\":\"var value = prevValue + Math.random() * 8 - 4;\\nif (value < 20) value = 20;\\nif (value > 90) value = 90;\\nreturn value;\",\"units\":\"%\",\"decimals\":1}]}],\"timewindow\":{\"hideInterval\":false,\"hideLastInterval\":false,\"hideQuickInterval\":false,\"hideAggregation\":false,\"hideAggInterval\":false,\"hideTimezone\":false,\"selectedTab\":0,\"realtime\":{\"realtimeType\":0,\"timewindowMs\":3600000,\"quickInterval\":\"CURRENT_HOUR\",\"interval\":5000},\"aggregation\":{\"type\":\"AVG\",\"limit\":25000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"chartType\":\"line\",\"smoothLine\":true,\"showLegend\":true,\"legendStyle\":\"classic\",\"legendPosition\":\"bottom\",\"legendAlign\":\"center\",\"legendCardColorMode\":\"auto\",\"legendCardColor\":\"#2196F3\",\"legendValues\":[\"current\"],\"showTimestamp\":true,\"timestampFormat\":\"YYYY-MM-DD HH:mm:ss\",\"showDataZoomSlider\":true,\"showToolbox\":true,\"toolboxFeatures\":[\"saveAsImage\",\"dataView\",\"dataZoom\",\"restore\"]},\"title\":\"ECO Timeseries Zoom Sync\",\"dropShadow\":true,\"enableFullscreen\":true,\"useDashboardTimewindow\":true,\"displayTimewindow\":true}"
  },
  "tags": [
    "chart",
    "timeseries",
    "time-series",
    "zoom",
    "line",
    "line chart",
    "bar",
    "bar chart",
    "area",
    "scatter",
    "echarts",
    "statistics",
    "dual-axis"
  ]
}