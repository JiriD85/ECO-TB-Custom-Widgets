{
  "fqn": "eco_custom_widgets.eco_scatter_xy",
  "name": "ECO Scatter X/Y",
  "deprecated": false,
  "image": "tb-image;/api/images/system/chart.svg",
  "description": "Scatter plot for heating curve analysis (Heizkurven-Analyse). Dual mode: X/t (time on X-axis) or X/Y (value on X-axis). Supports timestamp-matching between different datasources for correlation analysis.",
  "tags": [
    "chart",
    "scatter",
    "scatter plot",
    "xy",
    "correlation",
    "heating curve",
    "regression",
    "echarts",
    "statistics"
  ],
  "descriptor": {
    "type": "timeseries",
    "sizeX": 8,
    "sizeY": 5,
    "resources": [
      {
        "url": "https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"
      }
    ],
    "templateHtml": "<div id=\"widget-wrapper\" style=\"width: 100%; height: 100%; display: flex; flex-direction: column;\">\n  <div id=\"timewindow-selector\" style=\"display: none;\"></div>\n  <div id=\"stats-card-top\" style=\"padding: 4px 8px; display: none;\"></div>\n  <div style=\"flex: 1; min-height: 0; display: flex;\">\n    <div id=\"stats-card-left\" style=\"padding: 4px; display: none;\"></div>\n    <div id=\"chart-container\" style=\"flex: 1; min-height: 0;\"></div>\n    <div id=\"stats-card-right\" style=\"padding: 4px; display: none;\"></div>\n  </div>\n  <div id=\"stats-card-bottom\" style=\"padding: 4px 8px; display: none;\"></div>\n</div>",
    "templateCss": "#widget-wrapper { position: relative; }\n#chart-container { position: relative; }",
    "controllerScript": "/**\n * ECO Scatter X/Y Widget\n *\n * Scatter plot for heating curve analysis (Heizkurven-Analyse).\n * Dual mode: X/t (time on X-axis) or X/Y (value on X-axis, e.g. outside temperature).\n * Supports timestamp-matching between different datasources for X/Y correlation.\n */\n\nvar chart = null;\nvar chartContainer = null;\nvar statsCardContainers = {};\nvar timewindowContainer = null;\nvar resizeObserver = null;\n\n// Timewindow Selector State\nvar twState = {\n    mode: 'custom',\n    currentDate: new Date(),\n    customStart: null,\n    customEnd: null\n};\n\n// Cached entity attributes\nvar entityAttributes = {};\n\n// User language\nvar userLanguage = 'en';\n\n// ========================================\n// Utility Functions - Statistics\n// ========================================\nvar statsUtils = {\n    calculate: function(values) {\n        if (!values || values.length === 0) {\n            return { mean: 0, median: 0, min: 0, max: 0, sum: 0, count: 0, current: null };\n        }\n        var sorted = values.slice().sort(function(a, b) { return a - b; });\n        var sum = 0;\n        for (var i = 0; i < values.length; i++) sum += values[i];\n        return {\n            mean: sum / values.length,\n            median: this.percentile(sorted, 50),\n            min: sorted[0],\n            max: sorted[sorted.length - 1],\n            sum: sum,\n            count: values.length,\n            current: values[values.length - 1]\n        };\n    },\n    percentile: function(sortedValues, p) {\n        if (sortedValues.length === 0) return 0;\n        if (sortedValues.length === 1) return sortedValues[0];\n        var index = (p / 100) * (sortedValues.length - 1);\n        var lower = Math.floor(index);\n        var upper = Math.ceil(index);\n        var weight = index - lower;\n        if (upper >= sortedValues.length) return sortedValues[sortedValues.length - 1];\n        return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;\n    },\n    stdDev: function(values, mean) {\n        if (values.length === 0) return 0;\n        var sumSquares = 0;\n        for (var i = 0; i < values.length; i++) sumSquares += Math.pow(values[i] - mean, 2);\n        return Math.sqrt(sumSquares / values.length);\n    }\n};\n\n// ========================================\n// Utility Functions - Data Processing\n// ========================================\nvar dataProcessingUtils = {\n    removeOutliers: function(values, timestamps, options) {\n        var method = (options && options.method) || 'iqr';\n        var cleanValues = [];\n        var cleanTimestamps = [];\n        var removed = 0;\n\n        if (method === 'manual') {\n            var minVal = (options.minValue !== undefined && options.minValue !== null) ? options.minValue : -Infinity;\n            var maxVal = (options.maxValue !== undefined && options.maxValue !== null) ? options.maxValue : Infinity;\n            for (var i = 0; i < values.length; i++) {\n                if (values[i] >= minVal && values[i] <= maxVal) {\n                    cleanValues.push(values[i]);\n                    cleanTimestamps.push(timestamps[i]);\n                } else removed++;\n            }\n        } else if (method === 'zscore') {\n            var threshold = (options && options.zscoreThreshold) || 3;\n            var stats = statsUtils.calculate(values);\n            var stdDev = statsUtils.stdDev(values, stats.mean);\n            if (stdDev === 0) return { values: values, timestamps: timestamps, removed: 0 };\n            for (var j = 0; j < values.length; j++) {\n                var zscore = Math.abs((values[j] - stats.mean) / stdDev);\n                if (zscore <= threshold) {\n                    cleanValues.push(values[j]);\n                    cleanTimestamps.push(timestamps[j]);\n                } else removed++;\n            }\n        } else {\n            var multiplier = (options && options.iqrMultiplier) || 1.5;\n            var sorted = values.slice().sort(function(a, b) { return a - b; });\n            var q1 = statsUtils.percentile(sorted, 25);\n            var q3 = statsUtils.percentile(sorted, 75);\n            var iqr = q3 - q1;\n            var lowerFence, upperFence;\n            if (iqr === 0) {\n                var median = statsUtils.percentile(sorted, 50);\n                var range = Math.abs(median) * 0.5;\n                if (range === 0) range = 1;\n                lowerFence = median - range;\n                upperFence = median + range;\n            } else {\n                lowerFence = q1 - (multiplier * iqr);\n                upperFence = q3 + (multiplier * iqr);\n            }\n            for (var k = 0; k < values.length; k++) {\n                if (values[k] >= lowerFence && values[k] <= upperFence) {\n                    cleanValues.push(values[k]);\n                    cleanTimestamps.push(timestamps[k]);\n                } else removed++;\n            }\n        }\n        return { values: cleanValues, timestamps: cleanTimestamps, removed: removed };\n    },\n    movingAverage: function(values, windowSize) {\n        var result = [];\n        var halfWindow = Math.floor(windowSize / 2);\n        for (var i = 0; i < values.length; i++) {\n            var start = Math.max(0, i - halfWindow);\n            var end = Math.min(values.length, i + halfWindow + 1);\n            var sum = 0;\n            for (var j = start; j < end; j++) sum += values[j];\n            result.push(sum / (end - start));\n        }\n        return result;\n    },\n    getWindowSizeFromMinutes: function(timestamps, minutes) {\n        if (timestamps.length < 2) return 1;\n        var totalTimeMs = timestamps[timestamps.length - 1] - timestamps[0];\n        var avgIntervalMs = totalTimeMs / (timestamps.length - 1);\n        var windowMs = minutes * 60 * 1000;\n        return Math.max(1, Math.round(windowMs / avgIntervalMs));\n    }\n};\n\n// ========================================\n// Utility Functions - Color\n// ========================================\nvar colorUtils = {\n    adjust: function(color, amount) {\n        var usePound = false;\n        if (color[0] === '#') { color = color.slice(1); usePound = true; }\n        var num = parseInt(color, 16);\n        var r = Math.min(255, Math.max(0, (num >> 16) + amount));\n        var g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));\n        var b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));\n        return (usePound ? '#' : '') + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);\n    },\n    getDefault: function(index) {\n        var colors = ['#2196F3', '#4CAF50', '#FF9800', '#E91E63', '#9C27B0', '#00BCD4', '#795548', '#607D8B'];\n        return colors[index % colors.length];\n    }\n};\n\n// ========================================\n// Utility Functions - Axis\n// ========================================\nvar axisUtils = {\n    niceAxisBounds: function(dataMin, dataMax) {\n        var range = dataMax - dataMin;\n        if (range === 0) {\n            if (dataMax === 0) return { min: 0, max: 1 };\n            var singleValue = Math.abs(dataMax);\n            var magnitude = Math.pow(10, Math.floor(Math.log10(singleValue)));\n            return {\n                min: Math.floor(dataMin / magnitude) * magnitude,\n                max: Math.ceil(dataMax / magnitude + 0.5) * magnitude\n            };\n        }\n        var exponent = Math.floor(Math.log10(range));\n        var magnitude2 = Math.pow(10, exponent);\n        var normalized = range / magnitude2;\n        var tickInterval;\n        if (normalized <= 1.5) tickInterval = 0.2 * magnitude2;\n        else if (normalized <= 3) tickInterval = 0.5 * magnitude2;\n        else if (normalized <= 6) tickInterval = 1 * magnitude2;\n        else tickInterval = 2 * magnitude2;\n        var niceMin = Math.floor(dataMin / tickInterval) * tickInterval;\n        var niceMax = Math.ceil(dataMax / tickInterval) * tickInterval;\n        if (niceMin === dataMin) niceMin -= tickInterval;\n        if (niceMax === dataMax) niceMax += tickInterval;\n        var decimals = Math.max(0, -exponent + 1);\n        niceMin = Number(niceMin.toFixed(decimals));\n        niceMax = Number(niceMax.toFixed(decimals));\n        return { min: niceMin, max: niceMax };\n    }\n};\n\n// ========================================\n// Utility Functions - Formatting\n// ========================================\nvar formatUtils = {\n    value: function(value, decimals) {\n        if (value === null || value === undefined) return '-';\n        if (decimals === undefined || decimals === null) {\n            if (Math.abs(value) >= 1000) return value.toFixed(0);\n            if (Math.abs(value) >= 100) return value.toFixed(1);\n            return value.toFixed(2);\n        }\n        return value.toFixed(decimals);\n    },\n    timestamp: function(ts, format) {\n        var d = new Date(ts);\n        format = format || 'YYYY-MM-DD HH:mm:ss';\n        return format\n            .replace('YYYY', d.getFullYear())\n            .replace('MM', String(d.getMonth() + 1).padStart(2, '0'))\n            .replace('DD', String(d.getDate()).padStart(2, '0'))\n            .replace('HH', String(d.getHours()).padStart(2, '0'))\n            .replace('mm', String(d.getMinutes()).padStart(2, '0'))\n            .replace('ss', String(d.getSeconds()).padStart(2, '0'));\n    },\n    date: function(date, format, lang) {\n        lang = lang || userLanguage || 'en';\n        var monthsShort = {\n            en: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            de: ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']\n        };\n        var monthsFull = {\n            en: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n            de: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember']\n        };\n        var d = new Date(date);\n        var shortMonths = monthsShort[lang] || monthsShort.en;\n        var fullMonths = monthsFull[lang] || monthsFull.en;\n        format = format || 'D MMM YYYY';\n        var tokens = {\n            'YYYY': d.getFullYear(),\n            'YY': String(d.getFullYear()).slice(-2),\n            'MMMM': fullMonths[d.getMonth()],\n            'MMM': shortMonths[d.getMonth()],\n            'MM': String(d.getMonth() + 1).padStart(2, '0'),\n            'DD': String(d.getDate()).padStart(2, '0'),\n            'D': String(d.getDate()),\n            'M': String(d.getMonth() + 1)\n        };\n        return format.replace(/(YYYY|MMMM|MMM|MM|DD|YY|D|M)/g, function(match) {\n            return tokens[match] !== undefined ? tokens[match] : match;\n        });\n    }\n};\n\n// ========================================\n// Translations\n// ========================================\nvar translations = {\n    en: { selectPeriod: 'Select Period', from: 'From', to: 'To', cancel: 'Cancel', apply: 'Apply', day: 'Day', week: 'Week', month: 'Month', custom: 'Custom' },\n    de: { selectPeriod: 'Zeitraum wählen', from: 'Von', to: 'Bis', cancel: 'Abbrechen', apply: 'Anwenden', day: 'Tag', week: 'Woche', month: 'Monat', custom: 'Custom' }\n};\n\nfunction t(key) {\n    var lang = userLanguage || 'en';\n    var langStrings = translations[lang] || translations.en;\n    return langStrings[key] || translations.en[key] || key;\n}\n\n// ========================================\n// Language Detection\n// ========================================\nfunction detectUserLanguage() {\n    try {\n        if (self.ctx && self.ctx.$scope && self.ctx.$scope.$injector) {\n            var translate = self.ctx.$scope.$injector.get('$translate');\n            if (translate && translate.use) {\n                var tbLang = translate.use();\n                if (tbLang) { userLanguage = tbLang.substring(0, 2).toLowerCase(); return; }\n            }\n        }\n    } catch (e) {}\n    try {\n        var tbSettings = localStorage.getItem('thingsboard');\n        if (tbSettings) {\n            var parsed = JSON.parse(tbSettings);\n            if (parsed && parsed.language) { userLanguage = parsed.language.substring(0, 2).toLowerCase(); return; }\n        }\n    } catch (e) {}\n    var browserLang = navigator.language || navigator.userLanguage || 'en';\n    userLanguage = browserLang.substring(0, 2).toLowerCase();\n}\n\n// ========================================\n// Stats Card Rendering\n// ========================================\nfunction renderStatsCard(config) {\n    ['top', 'bottom', 'left', 'right'].forEach(function(pos) {\n        var container = statsCardContainers[pos];\n        if (container) {\n            container.style.display = 'none';\n            while (container.firstChild) container.removeChild(container.firstChild);\n        }\n    });\n\n    var legendValues = config.legendValues || [];\n    var legendStyle = config.legendStyle || 'classic';\n    var showCard = config.showLegend && legendStyle === 'card' && config.allStats && config.allStats.length > 0;\n\n    if (!showCard) return;\n\n    var position = config.legendPosition || 'bottom';\n    var align = config.legendAlign || 'center';\n    var container = statsCardContainers[position];\n    if (!container) return;\n\n    var isVertical = (position === 'left' || position === 'right');\n    var justifyMap = { left: 'flex-start', center: 'center', right: 'flex-end' };\n\n    container.style.display = 'flex';\n    container.style.flexWrap = 'wrap';\n    container.style.gap = '8px';\n\n    if (isVertical) {\n        container.style.flexDirection = 'column';\n        container.style.alignItems = justifyMap[align];\n        container.style.justifyContent = 'flex-start';\n    } else {\n        container.style.flexDirection = 'row';\n        container.style.justifyContent = justifyMap[align];\n        container.style.alignItems = 'flex-start';\n    }\n\n    config.allStats.forEach(function(seriesInfo) {\n        var card = createStatsCard(seriesInfo, config, isVertical);\n        container.appendChild(card);\n    });\n}\n\nfunction createStatsCard(seriesInfo, config, isVertical) {\n    var stats = seriesInfo.stats;\n    var unit = seriesInfo.units || '';\n    var dec = seriesInfo.decimals !== undefined ? seriesInfo.decimals : 2;\n    var seriesColor = seriesInfo.color || '#2196F3';\n    var colorMode = config.legendCardColorMode || 'auto';\n    var manualColor = config.legendCardColor || '#2196F3';\n    var legendValues = config.legendValues || [];\n\n    var bgColor = colorMode === 'manual' ? manualColor : seriesColor;\n    var bgStyle;\n    if (colorMode === 'gradient') {\n        var gradientDir = isVertical ? '180deg' : '135deg';\n        bgStyle = 'linear-gradient(' + gradientDir + ', ' + bgColor + ' 0%, ' + colorUtils.adjust(bgColor, -40) + ' 100%)';\n    } else {\n        bgStyle = bgColor;\n    }\n\n    var card = document.createElement('div');\n    card.style.cssText = 'background: ' + bgStyle + '; border-radius: 6px; padding: ' + (isVertical ? '10px 8px' : '8px 12px') + '; color: white; box-shadow: 0 2px 6px rgba(0,0,0,0.12); width: fit-content;';\n\n    var titleEl = document.createElement('div');\n    titleEl.style.cssText = 'font-size: ' + (isVertical ? '11px' : '12px') + '; font-weight: 600; margin-bottom: 8px; opacity: 0.95;' + (isVertical ? ' text-align: center;' : '');\n    titleEl.textContent = seriesInfo.label + (unit ? ' (' + unit + ')' : '');\n    card.appendChild(titleEl);\n\n    var statsRow = document.createElement('div');\n    statsRow.style.cssText = 'display: flex; flex-wrap: wrap; gap: 6px;' + (isVertical ? ' flex-direction: column;' : '');\n\n    var statDefs = {\n        current: { label: 'Current', icon: '●', value: stats.current },\n        min: { label: 'Min', icon: '↓', value: stats.min },\n        max: { label: 'Max', icon: '↑', value: stats.max },\n        mean: { label: 'Mean', icon: 'μ', value: stats.mean },\n        median: { label: 'Median', icon: '~', value: stats.median },\n        sum: { label: 'Sum', icon: 'Σ', value: stats.sum },\n        count: { label: 'Count', icon: 'n', value: stats.count },\n        r2: { label: 'R²', icon: '⊿', value: stats.r2 }\n    };\n\n    legendValues.forEach(function(val) {\n        var def = statDefs[val];\n        if (def && def.value !== undefined && def.value !== null) {\n            var formattedVal;\n            if (val === 'count') formattedVal = String(def.value);\n            else if (val === 'r2') formattedVal = def.value.toFixed(4);\n            else formattedVal = formatUtils.value(def.value, dec);\n            var statBox = document.createElement('div');\n            statBox.style.cssText = 'background: rgba(255,255,255,0.18); border-radius: 4px; padding: ' + (isVertical ? '4px 6px' : '4px 8px') + ';' + (isVertical ? ' text-align: center;' : ' min-width: 60px;');\n            var labelEl = document.createElement('div');\n            labelEl.style.cssText = 'font-size: 9px; opacity: 0.85;';\n            labelEl.textContent = def.icon + ' ' + def.label;\n            statBox.appendChild(labelEl);\n            var valueEl = document.createElement('div');\n            valueEl.style.cssText = 'font-size: ' + (isVertical ? '12px' : '13px') + '; font-weight: 600;';\n            valueEl.textContent = formattedVal;\n            statBox.appendChild(valueEl);\n            statsRow.appendChild(statBox);\n        }\n    });\n\n    card.appendChild(statsRow);\n\n    if (config.showTimestamp && stats.lastTimestamp) {\n        var timestampEl = document.createElement('div');\n        timestampEl.style.cssText = 'font-size: 9px; opacity: 0.7; margin-top: 6px;' + (isVertical ? ' text-align: center;' : '');\n        timestampEl.textContent = formatUtils.timestamp(stats.lastTimestamp, config.timestampFormat);\n        card.appendChild(timestampEl);\n    }\n\n    return card;\n}\n\n// ========================================\n// Initialization\n// ========================================\nself.onInit = function() {\n    detectUserLanguage();\n\n    chartContainer = self.ctx.$container.find('#chart-container')[0];\n    timewindowContainer = self.ctx.$container.find('#timewindow-selector')[0];\n    statsCardContainers = {\n        top: self.ctx.$container.find('#stats-card-top')[0],\n        bottom: self.ctx.$container.find('#stats-card-bottom')[0],\n        left: self.ctx.$container.find('#stats-card-left')[0],\n        right: self.ctx.$container.find('#stats-card-right')[0]\n    };\n\n    if (!chartContainer) { console.error('ECO Scatter: Chart container not found'); return; }\n    if (typeof echarts === 'undefined') { console.error('ECO Scatter: ECharts not loaded'); return; }\n\n    chart = echarts.init(chartContainer);\n\n    fetchEntityAttributes(function() {\n        initTimewindowSelector();\n        updateChart();\n    });\n\n    [100, 250, 500, 1000].forEach(function(delay) {\n        setTimeout(function() {\n            if (chart && chartContainer) {\n                chart.resize({ width: chartContainer.offsetWidth, height: chartContainer.offsetHeight });\n            }\n        }, delay);\n    });\n\n    if (typeof ResizeObserver !== 'undefined') {\n        resizeObserver = new ResizeObserver(function() {\n            requestAnimationFrame(function() {\n                if (chart && chartContainer) {\n                    chart.resize({ width: chartContainer.offsetWidth, height: chartContainer.offsetHeight });\n                }\n            });\n        });\n        resizeObserver.observe(chartContainer);\n    }\n};\n\nself.onDataUpdated = function() {\n    updateChart();\n};\n\nself.onResize = function() {\n    if (chart && chartContainer) {\n        chart.resize({ width: chartContainer.offsetWidth, height: chartContainer.offsetHeight });\n    }\n};\n\nself.onDestroy = function() {\n    if (resizeObserver) { resizeObserver.disconnect(); resizeObserver = null; }\n    if (chart) { chart.dispose(); chart = null; }\n};\n\n// ========================================\n// Entity Attributes\n// ========================================\nfunction fetchEntityAttributes(callback) {\n    var settings = self.ctx.settings || {};\n    var attributesToFetch = [];\n    var settingsToCheck = [settings.twCustomStartTime, settings.twCustomEndTime];\n\n    settingsToCheck.forEach(function(val) {\n        if (val && typeof val === 'string') {\n            var match = val.match(/^\\$\\{(.+)\\}$/);\n            if (match && attributesToFetch.indexOf(match[1]) === -1) {\n                attributesToFetch.push(match[1]);\n            }\n        }\n    });\n\n    if (attributesToFetch.length === 0) { callback(); return; }\n    if (!self.ctx.datasources || self.ctx.datasources.length === 0) { callback(); return; }\n\n    var ds = self.ctx.datasources[0];\n    if (!ds.entity || !ds.entity.id) { callback(); return; }\n\n    var entityId = ds.entity.id.id;\n    var entityType = ds.entity.id.entityType;\n    var keysParam = attributesToFetch.join(',');\n\n    var loadedCount = 0;\n    var totalScopes = 2;\n\n    function checkComplete() {\n        loadedCount++;\n        if (loadedCount >= totalScopes) callback();\n    }\n\n    if (self.ctx.http) {\n        var serverUrl = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/values/attributes/SERVER_SCOPE?keys=' + keysParam;\n        self.ctx.http.get(serverUrl).subscribe(\n            function(response) {\n                if (response && Array.isArray(response)) {\n                    response.forEach(function(attr) { entityAttributes[attr.key] = attr.value; });\n                }\n                checkComplete();\n            },\n            function(error) { checkComplete(); }\n        );\n\n        var clientUrl = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/values/attributes/CLIENT_SCOPE?keys=' + keysParam;\n        self.ctx.http.get(clientUrl).subscribe(\n            function(response) {\n                if (response && Array.isArray(response)) {\n                    response.forEach(function(attr) {\n                        if (entityAttributes[attr.key] === undefined) {\n                            entityAttributes[attr.key] = attr.value;\n                        }\n                    });\n                }\n                checkComplete();\n            },\n            function(error) { checkComplete(); }\n        );\n    } else {\n        callback();\n    }\n}\n\n// ========================================\n// Timewindow Selector\n// ========================================\nfunction initTimewindowSelector() {\n    var settings = self.ctx.settings || {};\n    twState.mode = settings.twSelectorDefaultMode || 'custom';\n    twState.currentDate = new Date();\n\n    if (twState.mode === 'custom') {\n        if (settings.twCustomStartTime) {\n            var startMs = resolveTimeValue(settings.twCustomStartTime);\n            var endMs = settings.twCustomEndTime ? resolveTimeValue(settings.twCustomEndTime) : Date.now();\n            if (startMs && startMs > 0) {\n                twState.customStart = startMs;\n                twState.customEnd = (endMs && endMs > 0) ? endMs : Date.now();\n            } else {\n                var today = new Date();\n                today.setHours(0, 0, 0, 0);\n                twState.customStart = today.getTime();\n                twState.customEnd = Date.now();\n            }\n        } else {\n            var useDashboardTw = self.ctx.widget && self.ctx.widget.config ? self.ctx.widget.config.useDashboardTimewindow !== false : true;\n            var tw = useDashboardTw\n                ? (self.ctx.dashboard && self.ctx.dashboard.dashboardTimewindow)\n                : self.ctx.timeWindow;\n            var now = Date.now();\n            if (tw && tw.fixedTimewindow && tw.fixedTimewindow.startTimeMs) {\n                twState.customStart = tw.fixedTimewindow.startTimeMs;\n                twState.customEnd = tw.fixedTimewindow.endTimeMs || now;\n            } else if (tw && tw.history && tw.history.fixedTimewindow && tw.history.fixedTimewindow.startTimeMs) {\n                twState.customStart = tw.history.fixedTimewindow.startTimeMs;\n                twState.customEnd = tw.history.fixedTimewindow.endTimeMs || now;\n            } else {\n                var today2 = new Date();\n                today2.setHours(0, 0, 0, 0);\n                twState.customStart = today2.getTime();\n                twState.customEnd = now;\n            }\n        }\n        applyTimewindow();\n    }\n}\n\nfunction renderTimewindowSelector() {\n    if (!timewindowContainer) return;\n    var settings = self.ctx.settings || {};\n    var showSelector = settings.showTimewindowSelector === true;\n\n    if (!showSelector) { timewindowContainer.style.display = 'none'; return; }\n\n    while (timewindowContainer.firstChild) timewindowContainer.removeChild(timewindowContainer.firstChild);\n\n    var accentColor = settings.twSelectorColor || '#2196F3';\n    if (!settings.twSelectorColor && self.ctx.data && self.ctx.data[0] && self.ctx.data[0].dataKey) {\n        accentColor = self.ctx.data[0].dataKey.color || '#2196F3';\n    }\n\n    var positionMap = { left: 'flex-start', center: 'center', right: 'flex-end' };\n    var position = settings.twSelectorPosition || 'center';\n\n    timewindowContainer.style.display = 'flex';\n    timewindowContainer.style.alignItems = 'center';\n    timewindowContainer.style.justifyContent = positionMap[position] || 'center';\n    timewindowContainer.style.padding = '8px';\n\n    var wrapper = document.createElement('div');\n    wrapper.style.cssText = 'display: flex; align-items: center; gap: 6px; background: ' + accentColor + '; border-radius: 6px; padding: 6px 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.12);';\n\n    if (twState.mode !== 'custom') {\n        var navLeft = createButton('\\u25C0', function() { navigate(-1); });\n        wrapper.appendChild(navLeft);\n    }\n\n    var btnContainer = document.createElement('div');\n    btnContainer.style.cssText = 'display: flex; gap: 4px;';\n\n    var modes = [\n        { id: 'day', label: 'D', title: t('day') },\n        { id: 'week', label: 'W', title: t('week') },\n        { id: 'month', label: 'M', title: t('month') },\n        { id: 'custom', label: 'C', title: t('custom') }\n    ];\n\n    modes.forEach(function(m) {\n        var isActive = twState.mode === m.id;\n        var btn = document.createElement('button');\n        btn.textContent = m.label;\n        btn.title = m.title;\n        btn.style.cssText = 'border: none; width: 28px; height: 24px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600; transition: all 0.2s;';\n        if (isActive) { btn.style.background = 'white'; btn.style.color = accentColor; }\n        else { btn.style.background = 'rgba(255,255,255,0.2)'; btn.style.color = 'white'; }\n        btn.onmouseover = function() { if (!isActive) btn.style.background = 'rgba(255,255,255,0.35)'; };\n        btn.onmouseout = function() { if (!isActive) btn.style.background = 'rgba(255,255,255,0.2)'; };\n        btn.onclick = function() { selectMode(m.id); };\n        btnContainer.appendChild(btn);\n    });\n\n    wrapper.appendChild(btnContainer);\n\n    if (twState.mode !== 'custom') {\n        var navRight = createButton('\\u25B6', function() { navigate(1); });\n        wrapper.appendChild(navRight);\n    }\n\n    var label = document.createElement('span');\n    label.style.cssText = 'color: white; font-size: 11px; margin-left: 8px; opacity: 0.9;';\n    label.textContent = formatLabel();\n    wrapper.appendChild(label);\n\n    if (twState.mode === 'custom') {\n        var calBtn = createButton('\\uD83D\\uDCC5', function(e) { e.stopPropagation(); showDatePicker(wrapper, accentColor); });\n        calBtn.title = t('selectPeriod');\n        calBtn.style.marginLeft = '4px';\n        wrapper.appendChild(calBtn);\n    }\n\n    timewindowContainer.appendChild(wrapper);\n}\n\nfunction createButton(text, onClick) {\n    var btn = document.createElement('button');\n    btn.textContent = text;\n    btn.style.cssText = 'background: rgba(255,255,255,0.2); border: none; color: white; width: 24px; height: 24px; border-radius: 4px; cursor: pointer; font-size: 10px; display: flex; align-items: center; justify-content: center; transition: background 0.2s;';\n    btn.onmouseover = function() { btn.style.background = 'rgba(255,255,255,0.35)'; };\n    btn.onmouseout = function() { btn.style.background = 'rgba(255,255,255,0.2)'; };\n    btn.onclick = onClick;\n    return btn;\n}\n\nfunction selectMode(mode) {\n    twState.mode = mode;\n    if (mode !== 'custom') { twState.currentDate = new Date(); twState.customStart = null; twState.customEnd = null; }\n    applyTimewindow();\n    renderTimewindowSelector();\n}\n\nfunction navigate(direction) {\n    var d = new Date(twState.currentDate);\n    switch (twState.mode) {\n        case 'day': d.setDate(d.getDate() + direction); break;\n        case 'week': d.setDate(d.getDate() + (direction * 7)); break;\n        case 'month': d.setMonth(d.getMonth() + direction); break;\n    }\n    twState.currentDate = d;\n    applyTimewindow();\n    renderTimewindowSelector();\n}\n\nfunction applyTimewindow() {\n    var range = calculateRange();\n    if (!range) return;\n\n    if (self.ctx.timewindowFunctions && self.ctx.timewindowFunctions.onUpdateTimewindow) {\n        if (self.ctx.$scope && self.ctx.$scope.$$postDigest) {\n            self.ctx.$scope.$$postDigest(function() {\n                self.ctx.timewindowFunctions.onUpdateTimewindow(range.start, range.end);\n            });\n        } else {\n            setTimeout(function() {\n                self.ctx.timewindowFunctions.onUpdateTimewindow(range.start, range.end);\n            }, 0);\n        }\n    }\n}\n\nfunction calculateRange() {\n    var settings = self.ctx.settings || {};\n    var d = new Date(twState.currentDate);\n    var start, end;\n    switch (twState.mode) {\n        case 'day':\n            start = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);\n            end = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 23, 59, 59, 999);\n            break;\n        case 'week':\n            var dayOfWeek = d.getDay();\n            var diffToMonday = (dayOfWeek === 0 ? -6 : 1) - dayOfWeek;\n            var monday = new Date(d);\n            monday.setDate(d.getDate() + diffToMonday);\n            start = new Date(monday.getFullYear(), monday.getMonth(), monday.getDate(), 0, 0, 0, 0);\n            var sunday = new Date(monday);\n            sunday.setDate(monday.getDate() + 6);\n            end = new Date(sunday.getFullYear(), sunday.getMonth(), sunday.getDate(), 23, 59, 59, 999);\n            break;\n        case 'month':\n            start = new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);\n            end = new Date(d.getFullYear(), d.getMonth() + 1, 0, 23, 59, 59, 999);\n            break;\n        case 'custom':\n            if (twState.customStart && twState.customEnd) {\n                return { start: twState.customStart, end: twState.customEnd };\n            }\n            if (settings.twCustomStartTime) {\n                var startMs = resolveTimeValue(settings.twCustomStartTime);\n                var endMs = settings.twCustomEndTime ? resolveTimeValue(settings.twCustomEndTime) : Date.now();\n                if (startMs) return { start: startMs, end: endMs || Date.now() };\n            }\n            var today = new Date();\n            today.setHours(0, 0, 0, 0);\n            return { start: today.getTime(), end: Date.now() };\n    }\n    return { start: start.getTime(), end: end.getTime() };\n}\n\nfunction resolveTimeValue(valueStr) {\n    if (!valueStr || valueStr === '') return null;\n    var varMatch = valueStr.match(/^\\$\\{(.+)\\}$/);\n    if (varMatch) {\n        var attrName = varMatch[1];\n        if (entityAttributes[attrName] !== undefined) {\n            var val = Number(entityAttributes[attrName]);\n            if (!isNaN(val) && val > 0) return val;\n        }\n        if (self.ctx.datasources && self.ctx.datasources[0]) {\n            var ds = self.ctx.datasources[0];\n            if (ds.entity && ds.entity.attributes && ds.entity.attributes[attrName] !== undefined) {\n                var val2 = Number(ds.entity.attributes[attrName]);\n                if (!isNaN(val2) && val2 > 0) return val2;\n            }\n        }\n        if (self.ctx.latestData) {\n            for (var i = 0; i < self.ctx.latestData.length; i++) {\n                var ld = self.ctx.latestData[i];\n                if (ld.dataKey && ld.dataKey.name === attrName && ld.data && ld.data.length > 0) {\n                    var val3 = Number(ld.data[ld.data.length - 1][1]);\n                    if (!isNaN(val3) && val3 > 0) return val3;\n                }\n            }\n        }\n        return null;\n    }\n    var numVal = Number(valueStr);\n    if (!isNaN(numVal) && numVal > 0) return numVal;\n    var dateVal = Date.parse(valueStr);\n    if (!isNaN(dateVal)) return dateVal;\n    return null;\n}\n\nfunction formatLabel() {\n    var settings = self.ctx.settings || {};\n    var d = twState.currentDate;\n    switch (twState.mode) {\n        case 'day': return formatUtils.date(d, settings.twSelectorDayFormat || 'DD.MM.YYYY');\n        case 'week':\n            var range = calculateRange();\n            if (range) {\n                var startD = new Date(range.start);\n                var endD = new Date(range.end);\n                var fmt = settings.twSelectorWeekFormat || 'DD.MM.YYYY - DD.MM.YYYY';\n                if (fmt.indexOf(' - ') !== -1) {\n                    var parts = fmt.split(' - ');\n                    return formatUtils.date(startD, parts[0]) + ' - ' + formatUtils.date(endD, parts[1] || parts[0]);\n                }\n                return formatUtils.date(startD, 'DD.MM.YYYY') + ' - ' + formatUtils.date(endD, 'DD.MM.YYYY');\n            }\n            return '';\n        case 'month': return formatUtils.date(d, settings.twSelectorMonthFormat || 'MMMM YYYY');\n        case 'custom':\n            if (twState.customStart && twState.customEnd) {\n                return formatUtils.date(new Date(twState.customStart), 'DD.MM.YY') + ' - ' + formatUtils.date(new Date(twState.customEnd), 'DD.MM.YY');\n            }\n            if (self.ctx.dashboard && self.ctx.dashboard.dashboardTimewindow) {\n                var tw = self.ctx.dashboard.dashboardTimewindow;\n                if (tw.history && tw.history.fixedTimewindow) {\n                    return formatUtils.date(new Date(tw.history.fixedTimewindow.startTimeMs), 'DD.MM.YY') + ' - ' + formatUtils.date(new Date(tw.history.fixedTimewindow.endTimeMs), 'DD.MM.YY');\n                }\n            }\n            return 'Dashboard';\n    }\n    return '';\n}\n\nfunction showDatePicker(anchor, accentColor) {\n    var existing = document.getElementById('eco-tw-datepicker');\n    if (existing) { existing.remove(); return; }\n\n    var startDate = new Date();\n    var endDate = new Date();\n    startDate.setDate(startDate.getDate() - 7);\n\n    if (twState.customStart && twState.customEnd) {\n        startDate = new Date(twState.customStart);\n        endDate = new Date(twState.customEnd);\n    } else if (self.ctx.dashboard && self.ctx.dashboard.dashboardTimewindow) {\n        var tw = self.ctx.dashboard.dashboardTimewindow;\n        if (tw.history && tw.history.fixedTimewindow) {\n            startDate = new Date(tw.history.fixedTimewindow.startTimeMs);\n            endDate = new Date(tw.history.fixedTimewindow.endTimeMs);\n        }\n    }\n\n    function toInputDate(d) {\n        return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');\n    }\n\n    var picker = document.createElement('div');\n    picker.id = 'eco-tw-datepicker';\n    picker.style.cssText = 'position: absolute; top: 100%; left: 50%; transform: translateX(-50%); margin-top: 4px; background: white; border-radius: 8px; padding: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.25); z-index: 10000; min-width: 280px;';\n\n    var title = document.createElement('div');\n    title.style.cssText = 'font-size: 12px; font-weight: 600; color: #333; margin-bottom: 10px;';\n    title.textContent = t('selectPeriod');\n    picker.appendChild(title);\n\n    var inputsRow = document.createElement('div');\n    inputsRow.style.cssText = 'display: flex; gap: 8px;';\n\n    var startDiv = document.createElement('div');\n    startDiv.style.cssText = 'flex: 1;';\n    var startLabel = document.createElement('label');\n    startLabel.style.cssText = 'font-size: 10px; color: #666; display: block; margin-bottom: 2px;';\n    startLabel.textContent = t('from');\n    var startInput = document.createElement('input');\n    startInput.type = 'date';\n    startInput.value = toInputDate(startDate);\n    startInput.style.cssText = 'width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; box-sizing: border-box;';\n    startDiv.appendChild(startLabel);\n    startDiv.appendChild(startInput);\n    inputsRow.appendChild(startDiv);\n\n    var endDiv = document.createElement('div');\n    endDiv.style.cssText = 'flex: 1;';\n    var endLabel = document.createElement('label');\n    endLabel.style.cssText = 'font-size: 10px; color: #666; display: block; margin-bottom: 2px;';\n    endLabel.textContent = t('to');\n    var endInput = document.createElement('input');\n    endInput.type = 'date';\n    endInput.value = toInputDate(endDate);\n    endInput.style.cssText = 'width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; box-sizing: border-box;';\n    endDiv.appendChild(endLabel);\n    endDiv.appendChild(endInput);\n    inputsRow.appendChild(endDiv);\n\n    picker.appendChild(inputsRow);\n\n    var btnRow = document.createElement('div');\n    btnRow.style.cssText = 'display: flex; gap: 6px; justify-content: flex-end; margin-top: 10px;';\n\n    var cancelBtn = document.createElement('button');\n    cancelBtn.textContent = t('cancel');\n    cancelBtn.style.cssText = 'padding: 6px 12px; border: 1px solid #ddd; background: white; border-radius: 4px; font-size: 11px; cursor: pointer;';\n    cancelBtn.onclick = function(e) { e.stopPropagation(); picker.remove(); };\n\n    var applyBtn = document.createElement('button');\n    applyBtn.textContent = t('apply');\n    applyBtn.style.cssText = 'padding: 6px 12px; border: none; background: ' + accentColor + '; color: white; border-radius: 4px; font-size: 11px; cursor: pointer; font-weight: 500;';\n    applyBtn.onclick = function(e) {\n        e.stopPropagation();\n        var newStart = new Date(startInput.value);\n        var newEnd = new Date(endInput.value);\n        newEnd.setHours(23, 59, 59, 999);\n        twState.customStart = newStart.getTime();\n        twState.customEnd = newEnd.getTime();\n        applyTimewindow();\n        picker.remove();\n        renderTimewindowSelector();\n    };\n\n    btnRow.appendChild(cancelBtn);\n    btnRow.appendChild(applyBtn);\n    picker.appendChild(btnRow);\n\n    anchor.style.position = 'relative';\n    anchor.appendChild(picker);\n\n    setTimeout(function() {\n        document.addEventListener('click', function closeHandler(e) {\n            if (!picker.contains(e.target)) { picker.remove(); document.removeEventListener('click', closeHandler); }\n        });\n    }, 100);\n}\n\n// ========================================\n// Scatter-Specific: Linear Regression\n// ========================================\nfunction calculateLinearRegression(points) {\n    var n = points.length;\n    if (n < 2) return null;\n\n    var sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;\n    for (var i = 0; i < n; i++) {\n        var x = points[i][0];\n        var y = points[i][1];\n        sumX += x;\n        sumY += y;\n        sumXY += x * y;\n        sumX2 += x * x;\n        sumY2 += y * y;\n    }\n\n    var denominator = n * sumX2 - sumX * sumX;\n    if (denominator === 0) return null;\n\n    var slope = (n * sumXY - sumX * sumY) / denominator;\n    var intercept = (sumY - slope * sumX) / n;\n\n    // R² coefficient\n    var meanY = sumY / n;\n    var ssTot = 0, ssRes = 0;\n    for (var j = 0; j < n; j++) {\n        var predicted = slope * points[j][0] + intercept;\n        ssRes += Math.pow(points[j][1] - predicted, 2);\n        ssTot += Math.pow(points[j][1] - meanY, 2);\n    }\n    var r2 = ssTot === 0 ? 0 : 1 - (ssRes / ssTot);\n\n    return { slope: slope, intercept: intercept, r2: r2 };\n}\n\n// ========================================\n// Scatter-Specific: Time-Bucket Aggregation\n// ========================================\nfunction aggregateIntoBuckets(dataEntries, bucketMs) {\n    // dataEntries: array of {ts, value}\n    // Returns: array of {ts (bucket center), value (avg)} sorted by ts\n    if (!dataEntries || dataEntries.length === 0 || !bucketMs || bucketMs <= 0) return dataEntries;\n\n    var buckets = {};\n    for (var i = 0; i < dataEntries.length; i++) {\n        var bucketKey = Math.floor(dataEntries[i].ts / bucketMs) * bucketMs;\n        if (!buckets[bucketKey]) {\n            buckets[bucketKey] = { sum: 0, count: 0 };\n        }\n        buckets[bucketKey].sum += dataEntries[i].value;\n        buckets[bucketKey].count++;\n    }\n\n    var result = [];\n    var keys = Object.keys(buckets).sort(function(a, b) { return Number(a) - Number(b); });\n    for (var k = 0; k < keys.length; k++) {\n        var bk = Number(keys[k]);\n        var b = buckets[bk];\n        result.push({\n            ts: bk + Math.floor(bucketMs / 2), // bucket center\n            value: b.sum / b.count\n        });\n    }\n    return result;\n}\n\n// ========================================\n// Scatter-Specific: Timestamp Matching (X/Y Mode)\n// ========================================\nfunction findNearestTimestamp(sortedTimestamps, target, maxDiffMs) {\n    if (sortedTimestamps.length === 0) return -1;\n\n    // Binary search for nearest\n    var low = 0, high = sortedTimestamps.length - 1;\n    while (low < high) {\n        var mid = Math.floor((low + high) / 2);\n        if (sortedTimestamps[mid] < target) low = mid + 1;\n        else high = mid;\n    }\n\n    // Check neighbors\n    var bestIdx = low;\n    var bestDiff = Math.abs(sortedTimestamps[low] - target);\n    if (low > 0) {\n        var prevDiff = Math.abs(sortedTimestamps[low - 1] - target);\n        if (prevDiff < bestDiff) { bestIdx = low - 1; bestDiff = prevDiff; }\n    }\n\n    if (bestDiff <= maxDiffMs) return bestIdx;\n    return -1;\n}\n\nfunction buildScatterDataXY(data, settings) {\n    var xAxisDataKey = settings.xAxisDataKey || 'outsideTemperature';\n    var yAxisDataKey = settings.yAxisDataKey || '';\n    var maxDiffMs = (settings.maxTimestampDiffSeconds || 300) * 1000;\n    var bucketMinutes = settings.aggregateBucketMinutes || 0;\n    var bucketMs = bucketMinutes > 0 ? bucketMinutes * 60 * 1000 : 0;\n    var defaultColors = ['#2196F3', '#4CAF50', '#FF9800', '#E91E63', '#9C27B0', '#00BCD4', '#795548', '#607D8B'];\n\n    // When bucket aggregation is active, auto-adjust matching tolerance\n    if (bucketMs > 0 && maxDiffMs < bucketMs) {\n        maxDiffMs = bucketMs;\n    }\n\n    // Separate X source from Y sources\n    var xSource = null;\n    var ySources = [];\n\n    for (var i = 0; i < data.length; i++) {\n        var ds = data[i];\n        var keyName = (ds.dataKey && (ds.dataKey.name || ds.dataKey.label)) || '';\n        if (keyName === xAxisDataKey) {\n            xSource = ds;\n        } else {\n            if (!yAxisDataKey || yAxisDataKey === '' || keyName === yAxisDataKey) {\n                ySources.push(ds);\n            }\n        }\n    }\n\n    if (!xSource || !xSource.data || xSource.data.length === 0) {\n        return { series: [], xLabel: xAxisDataKey };\n    }\n\n    // Build X entries (sorted by timestamp)\n    var xEntries = [];\n    for (var xi = 0; xi < xSource.data.length; xi++) {\n        var xVal = Number(xSource.data[xi][1]);\n        if (!isNaN(xVal) && isFinite(xVal)) {\n            xEntries.push({ ts: xSource.data[xi][0], value: xVal });\n        }\n    }\n    xEntries.sort(function(a, b) { return a.ts - b.ts; });\n\n    // Apply bucket aggregation to X data\n    if (bucketMs > 0) {\n        xEntries = aggregateIntoBuckets(xEntries, bucketMs);\n    }\n\n    var xTimestamps = xEntries.map(function(e) { return e.ts; });\n\n    // Build Y series with timestamp matching\n    var seriesList = [];\n    var colorIdx = 0;\n\n    for (var yi = 0; yi < ySources.length; yi++) {\n        var yDs = ySources[yi];\n        var yDataKey = yDs.dataKey || {};\n        var yLabel = yDataKey.label || yDataKey.name || 'Series ' + (yi + 1);\n        var yColor = yDataKey.color || defaultColors[colorIdx % defaultColors.length];\n        var yUnits = yDataKey.units || '';\n        var yDecimals = yDataKey.decimals !== undefined ? yDataKey.decimals : 2;\n        colorIdx++;\n\n        if (!yDs.data || yDs.data.length === 0) continue;\n\n        // Build Y entries\n        var yEntries = [];\n        for (var yj = 0; yj < yDs.data.length; yj++) {\n            var yVal = Number(yDs.data[yj][1]);\n            if (!isNaN(yVal) && isFinite(yVal)) {\n                yEntries.push({ ts: yDs.data[yj][0], value: yVal });\n            }\n        }\n\n        // Apply bucket aggregation to Y data\n        if (bucketMs > 0) {\n            yEntries = aggregateIntoBuckets(yEntries, bucketMs);\n        }\n\n        // Match Y to X by timestamp\n        var matchedPoints = []; // [xValue, yValue, timestamp]\n        for (var yk = 0; yk < yEntries.length; yk++) {\n            var yTimestamp = yEntries[yk].ts;\n            var nearestIdx = findNearestTimestamp(xTimestamps, yTimestamp, maxDiffMs);\n            if (nearestIdx !== -1) {\n                matchedPoints.push([xEntries[nearestIdx].value, yEntries[yk].value, yTimestamp]);\n            }\n        }\n\n        if (matchedPoints.length === 0) continue;\n\n        seriesList.push({\n            label: yLabel,\n            color: yColor,\n            units: yUnits,\n            decimals: yDecimals,\n            data: matchedPoints, // [xValue, yValue, timestamp]\n            xUnits: (xSource.dataKey && xSource.dataKey.units) || settings.xAxisUnit || ''\n        });\n    }\n\n    return {\n        series: seriesList,\n        xLabel: settings.xAxisLabel || xAxisDataKey,\n        xUnits: (xSource.dataKey && xSource.dataKey.units) || settings.xAxisUnit || ''\n    };\n}\n\nfunction buildScatterDataXT(data, settings) {\n    var defaultColors = ['#2196F3', '#4CAF50', '#FF9800', '#E91E63', '#9C27B0', '#00BCD4', '#795548', '#607D8B'];\n    var bucketMinutes = settings.aggregateBucketMinutes || 0;\n    var bucketMs = bucketMinutes > 0 ? bucketMinutes * 60 * 1000 : 0;\n    var seriesList = [];\n\n    for (var i = 0; i < data.length; i++) {\n        var ds = data[i];\n        var dataKey = ds.dataKey || {};\n        var label = dataKey.label || dataKey.name || 'Series ' + (i + 1);\n        var color = dataKey.color || defaultColors[i % defaultColors.length];\n        var units = dataKey.units || '';\n        var decimals = dataKey.decimals !== undefined ? dataKey.decimals : 2;\n\n        if (!ds.data || ds.data.length === 0) continue;\n\n        var entries = [];\n        for (var j = 0; j < ds.data.length; j++) {\n            var val = Number(ds.data[j][1]);\n            if (!isNaN(val) && isFinite(val)) {\n                entries.push({ ts: ds.data[j][0], value: val });\n            }\n        }\n\n        // Apply bucket aggregation\n        if (bucketMs > 0) {\n            entries = aggregateIntoBuckets(entries, bucketMs);\n        }\n\n        var points = entries.map(function(e) { return [e.ts, e.value]; });\n\n        if (points.length === 0) continue;\n\n        seriesList.push({\n            label: label,\n            color: color,\n            units: units,\n            decimals: decimals,\n            data: points\n        });\n    }\n\n    return { series: seriesList };\n}\n\n// ========================================\n// Chart Update - Main Function\n// ========================================\nfunction updateChart() {\n    if (!chart) return;\n\n    // Clear stats cards\n    ['top', 'bottom', 'left', 'right'].forEach(function(pos) {\n        var container = statsCardContainers[pos];\n        if (container) {\n            container.style.display = 'none';\n            while (container.firstChild) container.removeChild(container.firstChild);\n        }\n    });\n\n    var settings = self.ctx.settings || {};\n    var data = self.ctx.data || [];\n\n    renderTimewindowSelector();\n\n    var axisMode = settings.axisMode || 'xy';\n    var pointSize = settings.pointSize || 6;\n    var pointOpacity = settings.pointOpacity || 0.6;\n    var symbolShape = settings.symbolShape || 'circle';\n    var showRegressionLine = settings.showRegressionLine === true;\n    var regressionLineWidth = settings.regressionLineWidth || 2;\n\n    // Data processing\n    var removeOutliers = settings.removeOutliers === true;\n    var outlierMethod = settings.outlierMethod || 'iqr';\n    var smoothingEnabled = settings.smoothingEnabled === true;\n    var smoothingWindowMinutes = settings.smoothingWindowMinutes || 15;\n\n    var showDataZoomSlider = settings.showDataZoomSlider !== false;\n    var showToolbox = settings.showToolbox !== false;\n    var toolboxFeatures = settings.toolboxFeatures || ['saveAsImage', 'dataView', 'dataZoom', 'restore'];\n\n    if (!data.length) { showNoData('No data available'); return; }\n\n    // Build scatter data based on mode\n    var scatterResult;\n    if (axisMode === 'xy') {\n        scatterResult = buildScatterDataXY(data, settings);\n    } else {\n        scatterResult = buildScatterDataXT(data, settings);\n    }\n\n    if (!scatterResult.series || scatterResult.series.length === 0) {\n        showNoData('No matching data points');\n        return;\n    }\n\n    // Apply data processing per series\n    var processedSeries = [];\n    var allStatsForCard = [];\n    var defaultColors = ['#2196F3', '#4CAF50', '#FF9800', '#E91E63', '#9C27B0', '#00BCD4', '#795548', '#607D8B'];\n\n    for (var si = 0; si < scatterResult.series.length; si++) {\n        var s = scatterResult.series[si];\n        var yValues = s.data.map(function(p) { return p[1]; });\n        var timestamps = s.data.map(function(p) { return p[axisMode === 'xy' ? 2 : 0]; });\n\n        // Apply outlier removal on Y values\n        if (removeOutliers && yValues.length > 0) {\n            var outlierResult = dataProcessingUtils.removeOutliers(yValues, timestamps, {\n                method: outlierMethod,\n                iqrMultiplier: settings.outlierIqrMultiplier || 1.5,\n                zscoreThreshold: settings.outlierZscoreThreshold || 3,\n                minValue: settings.outlierMinValue,\n                maxValue: settings.outlierMaxValue\n            });\n\n            // Rebuild data from filtered results\n            var filteredData = [];\n            for (var fi = 0; fi < outlierResult.values.length; fi++) {\n                // Find original point matching this timestamp\n                var ts = outlierResult.timestamps[fi];\n                for (var oi = 0; oi < s.data.length; oi++) {\n                    var origTs = axisMode === 'xy' ? s.data[oi][2] : s.data[oi][0];\n                    if (origTs === ts) {\n                        if (axisMode === 'xy') {\n                            filteredData.push([s.data[oi][0], outlierResult.values[fi], ts]);\n                        } else {\n                            filteredData.push([ts, outlierResult.values[fi]]);\n                        }\n                        break;\n                    }\n                }\n            }\n            s.data = filteredData;\n            yValues = s.data.map(function(p) { return p[1]; });\n        }\n\n        // Apply smoothing on Y values\n        if (smoothingEnabled && yValues.length > 1) {\n            var tsForWindow = s.data.map(function(p) { return axisMode === 'xy' ? p[2] : p[0]; });\n            var windowSize = dataProcessingUtils.getWindowSizeFromMinutes(tsForWindow, smoothingWindowMinutes);\n            var smoothed = dataProcessingUtils.movingAverage(yValues, windowSize);\n            for (var smi = 0; smi < s.data.length; smi++) {\n                s.data[smi][1] = smoothed[smi];\n            }\n            yValues = smoothed;\n        }\n\n        // Calculate stats\n        var stats = statsUtils.calculate(yValues);\n        stats.lastTimestamp = timestamps.length > 0 ? timestamps[timestamps.length - 1] : null;\n\n        // Calculate regression if enabled (only meaningful for X/Y mode, but allowed for X/t too)\n        var regression = null;\n        if (showRegressionLine && s.data.length >= 2) {\n            var regPoints = axisMode === 'xy'\n                ? s.data.map(function(p) { return [p[0], p[1]]; })\n                : s.data.map(function(p) { return [p[0], p[1]]; });\n            regression = calculateLinearRegression(regPoints);\n            if (regression) {\n                stats.r2 = regression.r2;\n            }\n        }\n\n        processedSeries.push({\n            label: s.label,\n            color: s.color,\n            units: s.units,\n            decimals: s.decimals,\n            data: s.data,\n            stats: stats,\n            regression: regression,\n            xUnits: s.xUnits || ''\n        });\n\n        allStatsForCard.push({\n            label: s.label,\n            color: s.color,\n            units: s.units,\n            decimals: s.decimals,\n            stats: stats\n        });\n    }\n\n    // Render stats card\n    renderStatsCard({\n        showLegend: settings.showLegend,\n        legendStyle: settings.legendStyle,\n        legendPosition: settings.legendPosition,\n        legendAlign: settings.legendAlign,\n        legendCardColorMode: settings.legendCardColorMode,\n        legendCardColor: settings.legendCardColor,\n        legendValues: settings.legendValues,\n        showTimestamp: settings.showTimestamp,\n        timestampFormat: settings.timestampFormat,\n        allStats: allStatsForCard\n    });\n\n    // Build ECharts option\n    var option = buildChartOption(processedSeries, settings, axisMode, scatterResult, showDataZoomSlider, showToolbox, toolboxFeatures, pointSize, pointOpacity, symbolShape, showRegressionLine, regressionLineWidth);\n\n    if (!option.title) option.title = { show: false };\n    chart.setOption(option, true);\n\n    setTimeout(function() {\n        if (chart && chartContainer) {\n            chart.resize({ width: chartContainer.offsetWidth, height: chartContainer.offsetHeight });\n        }\n    }, 100);\n}\n\n// ========================================\n// Build ECharts Option\n// ========================================\nfunction buildChartOption(processedSeries, settings, axisMode, scatterResult, showDataZoomSlider, showToolbox, toolboxFeatures, pointSize, pointOpacity, symbolShape, showRegressionLine, regressionLineWidth) {\n    var series = [];\n    var legendData = [];\n    var showClassicLegend = settings.showLegend && settings.legendStyle !== 'card';\n\n    var isXY = axisMode === 'xy';\n\n    // Build scatter series\n    for (var i = 0; i < processedSeries.length; i++) {\n        var ps = processedSeries[i];\n        legendData.push(ps.label);\n\n        var scatterData;\n        if (isXY) {\n            // X/Y mode: data is [xValue, yValue, timestamp]\n            scatterData = ps.data.map(function(p) { return [p[0], p[1]]; });\n        } else {\n            // X/t mode: data is [timestamp, value]\n            scatterData = ps.data;\n        }\n\n        series.push({\n            name: ps.label,\n            type: 'scatter',\n            data: scatterData,\n            symbolSize: pointSize,\n            symbol: symbolShape,\n            itemStyle: {\n                color: ps.color,\n                opacity: pointOpacity\n            }\n        });\n\n        // Add regression line if enabled\n        if (showRegressionLine && ps.regression) {\n            var reg = ps.regression;\n            var xValues = ps.data.map(function(p) { return p[0]; });\n            var xMin = xValues[0], xMax = xValues[0];\n            for (var vi = 1; vi < xValues.length; vi++) {\n                if (xValues[vi] < xMin) xMin = xValues[vi];\n                if (xValues[vi] > xMax) xMax = xValues[vi];\n            }\n\n            var regLabel = 'y = ' + reg.slope.toFixed(3) + 'x ' + (reg.intercept >= 0 ? '+ ' : '- ') + Math.abs(reg.intercept).toFixed(3) + ' (R\\u00B2=' + reg.r2.toFixed(4) + ')';\n\n            series.push({\n                name: ps.label + ' Regression',\n                type: 'line',\n                data: [\n                    [xMin, reg.slope * xMin + reg.intercept],\n                    [xMax, reg.slope * xMax + reg.intercept]\n                ],\n                lineStyle: {\n                    color: ps.color,\n                    width: regressionLineWidth,\n                    type: 'dashed'\n                },\n                symbol: 'none',\n                tooltip: {\n                    formatter: function(params) {\n                        return params.seriesName + '<br/>' + regLabel;\n                    }\n                }\n            });\n            legendData.push(ps.label + ' Regression');\n        }\n    }\n\n    // Tooltip\n    var tooltip;\n    if (isXY) {\n        var xLabel = scatterResult.xLabel || 'X';\n        var xUnits = scatterResult.xUnits || '';\n        tooltip = {\n            trigger: 'item',\n            formatter: function(params) {\n                if (!params || !params.value) return '';\n                var ps2 = processedSeries.find(function(s2) { return s2.label === params.seriesName; });\n                if (!ps2) return params.seriesName;\n                var dec = ps2.decimals;\n                var yUnit = ps2.units || '';\n                // Find the original data point to get timestamp\n                var timestamp = '';\n                for (var di = 0; di < ps2.data.length; di++) {\n                    if (ps2.data[di][0] === params.value[0] && ps2.data[di][1] === params.value[1]) {\n                        timestamp = formatUtils.timestamp(ps2.data[di][2]);\n                        break;\n                    }\n                }\n                var result = '';\n                if (timestamp) result += timestamp + '<br/>';\n                result += '<span style=\"display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + params.color + ';\"></span>';\n                result += xLabel + ': ' + formatUtils.value(params.value[0], 1) + (xUnits ? ' ' + xUnits : '') + '<br/>';\n                result += params.seriesName + ': ' + formatUtils.value(params.value[1], dec) + (yUnit ? ' ' + yUnit : '');\n                return result;\n            }\n        };\n    } else {\n        tooltip = {\n            trigger: 'item',\n            formatter: function(params) {\n                if (!params || !params.value) return '';\n                var d = new Date(params.value[0]);\n                var ps2 = processedSeries.find(function(s2) { return s2.label === params.seriesName; });\n                var dec = ps2 ? ps2.decimals : 2;\n                var unit = ps2 ? ps2.units : '';\n                var result = d.toLocaleString() + '<br/>';\n                result += '<span style=\"display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + params.color + ';\"></span>';\n                result += params.seriesName + ': ' + formatUtils.value(params.value[1], dec) + (unit ? ' ' + unit : '');\n                return result;\n            }\n        };\n    }\n\n    // Collect all X and Y values for axis bounds\n    var allXValues = [];\n    var allYValues = [];\n    for (var bi = 0; bi < processedSeries.length; bi++) {\n        for (var bj = 0; bj < processedSeries[bi].data.length; bj++) {\n            var pt = processedSeries[bi].data[bj];\n            allXValues.push(pt[0]);\n            allYValues.push(pt[1]);\n        }\n    }\n\n    // Auto-detect units from dataKeys\n    var xUnit = scatterResult.xUnits || settings.xAxisUnit || '';\n    var yUnit = '';\n    if (processedSeries.length > 0) {\n        yUnit = processedSeries[0].units || '';\n    }\n\n    // Auto-generate axis labels from dataKey label + unit\n    var xLabel2 = settings.xAxisLabel || scatterResult.xLabel || 'X';\n    var yLabel = settings.yAxisLabel || '';\n    if (!yLabel && processedSeries.length > 0) {\n        yLabel = processedSeries[0].label || '';\n    }\n\n    // X-axis config\n    var xAxis;\n    if (isXY) {\n        xAxis = {\n            type: 'value',\n            name: xLabel2 + (xUnit ? ' (' + xUnit + ')' : ''),\n            nameLocation: 'middle',\n            nameGap: 30,\n            nameTextStyle: { fontSize: settings.axisLabelFontSize || 11, color: settings.axisLabelColor || '#666' },\n            axisLabel: { fontSize: settings.axisTickFontSize || 10 }\n        };\n        // Apply nice axis bounds for X\n        if (allXValues.length > 0) {\n            var xDataMin = allXValues[0], xDataMax = allXValues[0];\n            for (var xbi = 1; xbi < allXValues.length; xbi++) {\n                if (allXValues[xbi] < xDataMin) xDataMin = allXValues[xbi];\n                if (allXValues[xbi] > xDataMax) xDataMax = allXValues[xbi];\n            }\n            var xBounds = axisUtils.niceAxisBounds(xDataMin, xDataMax);\n            xAxis.min = xBounds.min;\n            xAxis.max = xBounds.max;\n        }\n    } else {\n        xAxis = {\n            type: 'time',\n            axisLabel: { fontSize: settings.axisTickFontSize || 10 }\n        };\n    }\n\n    // Y-axis config\n    var yAxis = {\n        type: 'value',\n        axisLabel: { fontSize: settings.axisTickFontSize || 10 }\n    };\n    if (yLabel || yUnit) {\n        yAxis.name = yLabel + (yUnit ? ' (' + yUnit + ')' : '');\n        yAxis.nameLocation = 'middle';\n        yAxis.nameGap = 45;\n        yAxis.nameTextStyle = { fontSize: settings.axisLabelFontSize || 11, color: settings.axisLabelColor || '#666' };\n    }\n    // Apply nice axis bounds for Y\n    if (allYValues.length > 0) {\n        var yDataMin = allYValues[0], yDataMax = allYValues[0];\n        for (var ybi = 1; ybi < allYValues.length; ybi++) {\n            if (allYValues[ybi] < yDataMin) yDataMin = allYValues[ybi];\n            if (allYValues[ybi] > yDataMax) yDataMax = allYValues[ybi];\n        }\n        var yBounds = axisUtils.niceAxisBounds(yDataMin, yDataMax);\n        yAxis.min = yBounds.min;\n        yAxis.max = yBounds.max;\n    }\n\n    // DataZoom\n    var dataZoom = showDataZoomSlider\n        ? [{ type: 'inside' }, { type: 'slider', bottom: 8, height: 20 }]\n        : [{ type: 'inside' }];\n\n    // Toolbox\n    var toolbox = showToolbox ? {\n        show: true, right: 10, top: 5,\n        feature: {\n            saveAsImage: toolboxFeatures.indexOf('saveAsImage') !== -1 ? { show: true } : undefined,\n            dataZoom: toolboxFeatures.indexOf('dataZoom') !== -1 ? { show: true } : undefined,\n            restore: toolboxFeatures.indexOf('restore') !== -1 ? { show: true } : undefined\n        }\n    } : null;\n\n    return {\n        tooltip: tooltip,\n        legend: showClassicLegend ? { data: legendData, bottom: showDataZoomSlider ? 30 : 5 } : { show: false },\n        grid: { left: 60, right: 20, top: 40, bottom: showDataZoomSlider ? 60 : 40 },\n        xAxis: xAxis,\n        yAxis: yAxis,\n        dataZoom: dataZoom,\n        toolbox: toolbox,\n        series: series\n    };\n}\n\n// ========================================\n// No Data Display\n// ========================================\nfunction showNoData(msg) {\n    if (!chart) return;\n    ['top', 'bottom', 'left', 'right'].forEach(function(pos) {\n        var container = statsCardContainers[pos];\n        if (container) {\n            container.style.display = 'none';\n            while (container.firstChild) container.removeChild(container.firstChild);\n        }\n    });\n    chart.setOption({\n        title: { text: msg, left: 'center', top: 'middle', textStyle: { color: '#999', fontSize: 14 } }\n    }, true);\n}\n\nself.typeParameters = function() {\n    return {\n        previewWidth: '100%',\n        previewHeight: '100%',\n        embedTitlePanel: false,\n        hasDataExportAction: true,\n        maxDatasources: -1,\n        maxDataKeys: -1,\n        dataKeysOptional: true,\n        datasourcesOptional: false,\n        hasAdditionalLatestDataKeys: true,\n        singleEntity: false,\n        defaultDataKeysFunction: function() { return []; },\n        defaultLatestDataKeysFunction: function() { return []; }\n    };\n};\n",
    "settingsSchema": {
      "schema": {
        "type": "object",
        "title": "ECO Scatter X/Y Settings",
        "properties": {
          "axisMode": {
            "title": "Axis Mode",
            "type": "string",
            "default": "xy",
            "enum": [
              "xy",
              "xt"
            ]
          },
          "xAxisDataKey": {
            "title": "X-Axis Data Key",
            "type": "string",
            "default": "outsideTemperature"
          },
          "yAxisDataKey": {
            "title": "Y-Axis Data Key",
            "type": "string",
            "default": ""
          },
          "xAxisLabel": {
            "title": "X-Axis Label",
            "type": "string",
            "default": "Outside Temperature"
          },
          "xAxisUnit": {
            "title": "X-Axis Unit",
            "type": "string",
            "default": "°C"
          },
          "yAxisLabel": {
            "title": "Y-Axis Label",
            "type": "string",
            "default": ""
          },
          "showDataZoomSlider": {
            "title": "Show Zoom Slider",
            "type": "boolean",
            "default": true
          },
          "pointSize": {
            "title": "Point Size",
            "type": "number",
            "default": 6,
            "minimum": 2,
            "maximum": 20
          },
          "pointOpacity": {
            "title": "Point Opacity",
            "type": "number",
            "default": 0.6,
            "minimum": 0.1,
            "maximum": 1.0
          },
          "symbolShape": {
            "title": "Point Shape",
            "type": "string",
            "default": "circle",
            "enum": [
              "circle",
              "rect",
              "triangle",
              "diamond"
            ]
          },
          "showRegressionLine": {
            "title": "Show Regression Line",
            "type": "boolean",
            "default": false
          },
          "regressionLineWidth": {
            "title": "Regression Line Width",
            "type": "number",
            "default": 2
          },
          "maxTimestampDiffSeconds": {
            "title": "Max Timestamp Diff (seconds)",
            "type": "number",
            "default": 300
          },
          "removeOutliers": {
            "title": "Remove Outliers",
            "type": "boolean",
            "default": false
          },
          "outlierMethod": {
            "title": "Outlier Method",
            "type": "string",
            "default": "iqr",
            "enum": [
              "iqr",
              "zscore",
              "manual"
            ]
          },
          "outlierIqrMultiplier": {
            "title": "IQR Multiplier",
            "type": "number",
            "default": 1.5
          },
          "outlierZscoreThreshold": {
            "title": "Z-Score Threshold",
            "type": "number",
            "default": 3
          },
          "outlierMinValue": {
            "title": "Minimum Value",
            "type": "number"
          },
          "outlierMaxValue": {
            "title": "Maximum Value",
            "type": "number"
          },
          "smoothingEnabled": {
            "title": "Enable Smoothing",
            "type": "boolean",
            "default": false
          },
          "smoothingWindowMinutes": {
            "title": "Smoothing Window (minutes)",
            "type": "number",
            "default": 15
          },
          "showLegend": {
            "title": "Show Legend",
            "type": "boolean",
            "default": true
          },
          "legendStyle": {
            "title": "Legend Style",
            "type": "string",
            "default": "classic",
            "enum": [
              "classic",
              "card"
            ]
          },
          "legendPosition": {
            "title": "Legend Position",
            "type": "string",
            "default": "bottom",
            "enum": [
              "top",
              "bottom",
              "left",
              "right"
            ]
          },
          "legendAlign": {
            "title": "Legend Alignment",
            "type": "string",
            "default": "center",
            "enum": [
              "left",
              "center",
              "right"
            ]
          },
          "legendCardColorMode": {
            "title": "Card Color Mode",
            "type": "string",
            "default": "auto",
            "enum": [
              "auto",
              "manual",
              "gradient"
            ]
          },
          "legendCardColor": {
            "title": "Card Color",
            "type": "string",
            "default": "#2196F3"
          },
          "legendValues": {
            "title": "Statistics to Display",
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": [
              "count",
              "mean",
              "min",
              "max"
            ]
          },
          "showTimestamp": {
            "title": "Show Timestamp",
            "type": "boolean",
            "default": true
          },
          "timestampFormat": {
            "title": "Timestamp Format",
            "type": "string",
            "default": "YYYY-MM-DD HH:mm:ss"
          },
          "showToolbox": {
            "title": "Show Toolbox",
            "type": "boolean",
            "default": true
          },
          "toolboxFeatures": {
            "title": "Toolbox Features",
            "type": "array",
            "items": {
              "type": "string"
            },
            "default": [
              "saveAsImage",
              "dataView",
              "dataZoom",
              "restore"
            ]
          },
          "showTimewindowSelector": {
            "title": "Show Timewindow Selector",
            "type": "boolean",
            "default": false
          },
          "twSelectorColor": {
            "title": "Selector Color",
            "type": "string",
            "default": ""
          },
          "twSelectorPosition": {
            "title": "Selector Position",
            "type": "string",
            "default": "center",
            "enum": [
              "left",
              "center",
              "right"
            ]
          },
          "twSelectorDayFormat": {
            "title": "Day Format",
            "type": "string",
            "default": "DD.MM.YYYY"
          },
          "twSelectorWeekFormat": {
            "title": "Week Format",
            "type": "string",
            "default": "DD.MM.YYYY - DD.MM.YYYY"
          },
          "twSelectorMonthFormat": {
            "title": "Month Format",
            "type": "string",
            "default": "MMMM YYYY"
          },
          "twSelectorDefaultMode": {
            "title": "Default Mode",
            "type": "string",
            "default": "custom",
            "enum": [
              "custom",
              "day",
              "week",
              "month"
            ]
          },
          "twCustomStartTime": {
            "title": "Custom Start Time",
            "type": "string",
            "default": ""
          },
          "twCustomEndTime": {
            "title": "Custom End Time",
            "type": "string",
            "default": ""
          },
          "twAggregationType": {
            "title": "Aggregation",
            "type": "string",
            "default": "NONE",
            "enum": [
              "NONE",
              "AVG",
              "MIN",
              "MAX",
              "SUM",
              "COUNT"
            ]
          },
          "twMaxDataPoints": {
            "title": "Max Data Points",
            "type": "number",
            "default": 100000
          },
          "axisLabelFontSize": {
            "title": "Axis Label Font Size",
            "type": "number",
            "default": 11
          },
          "axisLabelColor": {
            "title": "Axis Label Color",
            "type": "string",
            "default": "#666666"
          },
          "axisTickFontSize": {
            "title": "Axis Tick Font Size",
            "type": "number",
            "default": 10
          },
          "aggregateBucketMinutes": {
            "title": "Aggregation Bucket (minutes)",
            "type": "number",
            "default": 0
          }
        },
        "required": []
      },
      "form": [
        [
          {
            "key": "axisMode",
            "type": "rc-select",
            "multiple": false,
            "items": [
              {
                "value": "xy",
                "label": "X/Y Mode (Value on X-Axis)"
              },
              {
                "value": "xt",
                "label": "X/t Mode (Time on X-Axis)"
              }
            ]
          },
          {
            "key": "xAxisDataKey",
            "condition": "model.axisMode === 'xy'",
            "description": "Exact key name for X-axis datasource (e.g. outsideTemperature)"
          },
          {
            "key": "yAxisDataKey",
            "condition": "model.axisMode === 'xy'",
            "description": "Key name for Y-axis (empty = all non-X keys)"
          },
          {
            "key": "xAxisLabel",
            "condition": "model.axisMode === 'xy'"
          },
          {
            "key": "xAxisUnit",
            "condition": "model.axisMode === 'xy'"
          },
          "yAxisLabel",
          "showDataZoomSlider"
        ],
        [
          "pointSize",
          "pointOpacity",
          {
            "key": "symbolShape",
            "type": "rc-select",
            "multiple": false,
            "items": [
              {
                "value": "circle",
                "label": "Circle"
              },
              {
                "value": "rect",
                "label": "Rectangle"
              },
              {
                "value": "triangle",
                "label": "Triangle"
              },
              {
                "value": "diamond",
                "label": "Diamond"
              }
            ]
          },
          "showRegressionLine",
          {
            "key": "regressionLineWidth",
            "condition": "model.showRegressionLine === true"
          }
        ],
        [
          {
            "key": "maxTimestampDiffSeconds",
            "condition": "model.axisMode === 'xy'",
            "description": "Max time difference in seconds for matching X and Y data points"
          },
          {
            "key": "aggregateBucketMinutes",
            "description": "Aggregate data into time buckets before matching (0 = disabled, 60 = 1h). Useful when X and Y data have different resolutions."
          },
          "removeOutliers",
          {
            "key": "outlierMethod",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.removeOutliers === true",
            "items": [
              {
                "value": "iqr",
                "label": "IQR (Interquartile Range)"
              },
              {
                "value": "zscore",
                "label": "Z-Score"
              },
              {
                "value": "manual",
                "label": "Manual Thresholds"
              }
            ]
          },
          {
            "key": "outlierIqrMultiplier",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'iqr'"
          },
          {
            "key": "outlierZscoreThreshold",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'zscore'"
          },
          {
            "key": "outlierMinValue",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'manual'"
          },
          {
            "key": "outlierMaxValue",
            "condition": "model.removeOutliers === true && model.outlierMethod === 'manual'"
          },
          "smoothingEnabled",
          {
            "key": "smoothingWindowMinutes",
            "condition": "model.smoothingEnabled === true"
          }
        ],
        [
          "showLegend",
          {
            "key": "legendStyle",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true",
            "items": [
              {
                "value": "classic",
                "label": "Classic (Text)"
              },
              {
                "value": "card",
                "label": "Statistics Card"
              }
            ]
          },
          {
            "key": "legendPosition",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true",
            "items": [
              {
                "value": "top",
                "label": "Top"
              },
              {
                "value": "bottom",
                "label": "Bottom"
              },
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "legendAlign",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "center",
                "label": "Center"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "legendCardColorMode",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "auto",
                "label": "Auto (Series Color)"
              },
              {
                "value": "manual",
                "label": "Manual Color"
              },
              {
                "value": "gradient",
                "label": "Gradient"
              }
            ]
          },
          {
            "key": "legendCardColor",
            "type": "color",
            "condition": "model.showLegend === true && model.legendStyle === 'card' && model.legendCardColorMode === 'manual'"
          },
          {
            "key": "legendValues",
            "type": "rc-select",
            "multiple": true,
            "condition": "model.showLegend === true && model.legendStyle === 'card'",
            "items": [
              {
                "value": "current",
                "label": "Current Value"
              },
              {
                "value": "min",
                "label": "Minimum"
              },
              {
                "value": "max",
                "label": "Maximum"
              },
              {
                "value": "mean",
                "label": "Mean"
              },
              {
                "value": "median",
                "label": "Median"
              },
              {
                "value": "sum",
                "label": "Sum"
              },
              {
                "value": "count",
                "label": "Count"
              },
              {
                "value": "r2",
                "label": "R² (Regression)"
              }
            ]
          },
          {
            "key": "showTimestamp",
            "condition": "model.showLegend === true && model.legendStyle === 'card'"
          },
          {
            "key": "timestampFormat",
            "condition": "model.showLegend === true && model.legendStyle === 'card' && model.showTimestamp === true"
          }
        ],
        [
          "showToolbox",
          {
            "key": "toolboxFeatures",
            "type": "rc-select",
            "multiple": true,
            "condition": "model.showToolbox === true",
            "items": [
              {
                "value": "saveAsImage",
                "label": "Save as Image"
              },
              {
                "value": "dataView",
                "label": "Data View"
              },
              {
                "value": "dataZoom",
                "label": "Data Zoom"
              },
              {
                "value": "restore",
                "label": "Restore"
              }
            ]
          }
        ],
        [
          "showTimewindowSelector",
          {
            "key": "twSelectorColor",
            "type": "color",
            "condition": "model.showTimewindowSelector === true",
            "description": "Leave empty for auto (uses series color)"
          },
          {
            "key": "twSelectorPosition",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "left",
                "label": "Left"
              },
              {
                "value": "center",
                "label": "Center"
              },
              {
                "value": "right",
                "label": "Right"
              }
            ]
          },
          {
            "key": "twSelectorDefaultMode",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "custom",
                "label": "Custom (C) - Dashboard Timewindow"
              },
              {
                "value": "day",
                "label": "Day (D)"
              },
              {
                "value": "week",
                "label": "Week (W)"
              },
              {
                "value": "month",
                "label": "Month (M)"
              }
            ]
          },
          {
            "key": "twSelectorDayFormat",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "DD.MM.YYYY",
                "label": "DD.MM.YYYY (25.01.2026)"
              },
              {
                "value": "D.M.YYYY",
                "label": "D.M.YYYY (25.1.2026)"
              },
              {
                "value": "DD.MM.YY",
                "label": "DD.MM.YY (25.01.26)"
              },
              {
                "value": "D MMM YYYY",
                "label": "D MMM YYYY (25 Jan 2026)"
              },
              {
                "value": "D MMMM YYYY",
                "label": "D MMMM YYYY (25 Januar 2026)"
              }
            ]
          },
          {
            "key": "twSelectorWeekFormat",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "DD.MM.YYYY - DD.MM.YYYY",
                "label": "DD.MM.YYYY - DD.MM.YYYY (19.01.2026 - 25.01.2026)"
              },
              {
                "value": "DD.MM. - DD.MM.YYYY",
                "label": "DD.MM. - DD.MM.YYYY (19.01. - 25.01.2026)"
              },
              {
                "value": "DD.MM.YY - DD.MM.YY",
                "label": "DD.MM.YY - DD.MM.YY (19.01.26 - 25.01.26)"
              },
              {
                "value": "D-D MMM YYYY",
                "label": "D-D MMM YYYY (19-25 Jan 2026)"
              },
              {
                "value": "D MMM - D MMM",
                "label": "D MMM - D MMM (19 Jan - 25 Jan)"
              }
            ]
          },
          {
            "key": "twSelectorMonthFormat",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "MMMM YYYY",
                "label": "MMMM YYYY (Januar 2026)"
              },
              {
                "value": "MMM YYYY",
                "label": "MMM YYYY (Jan 2026)"
              },
              {
                "value": "MM/YYYY",
                "label": "MM/YYYY (01/2026)"
              },
              {
                "value": "MM.YYYY",
                "label": "MM.YYYY (01.2026)"
              }
            ]
          },
          {
            "key": "twCustomStartTime",
            "condition": "model.showTimewindowSelector === true",
            "description": "Use ${attributeName} for entity attributes, e.g. ${startTimeMs}"
          },
          {
            "key": "twCustomEndTime",
            "condition": "model.showTimewindowSelector === true",
            "description": "Use ${attributeName} for entity attributes, e.g. ${endTimeMs}"
          },
          {
            "key": "twAggregationType",
            "type": "rc-select",
            "multiple": false,
            "condition": "model.showTimewindowSelector === true",
            "items": [
              {
                "value": "NONE",
                "label": "None (Raw Data)"
              },
              {
                "value": "AVG",
                "label": "Average"
              },
              {
                "value": "MIN",
                "label": "Minimum"
              },
              {
                "value": "MAX",
                "label": "Maximum"
              },
              {
                "value": "SUM",
                "label": "Sum"
              },
              {
                "value": "COUNT",
                "label": "Count"
              }
            ]
          },
          {
            "key": "twMaxDataPoints",
            "condition": "model.showTimewindowSelector === true",
            "description": "Maximum number of data points to fetch (default: 100000)"
          }
        ],
        [
          "axisLabelFontSize",
          {
            "key": "axisLabelColor",
            "type": "color"
          },
          "axisTickFontSize"
        ]
      ],
      "groupInfoes": [
        {
          "formIndex": 0,
          "GroupTitle": "Axis Mode & Labels"
        },
        {
          "formIndex": 1,
          "GroupTitle": "Scatter Settings"
        },
        {
          "formIndex": 2,
          "GroupTitle": "Data Processing"
        },
        {
          "formIndex": 3,
          "GroupTitle": "Legend & Stats Card"
        },
        {
          "formIndex": 4,
          "GroupTitle": "Toolbox Settings"
        },
        {
          "formIndex": 5,
          "GroupTitle": "Timewindow Selector"
        },
        {
          "formIndex": 6,
          "GroupTitle": "Appearance"
        }
      ]
    },
    "dataKeySettingsSchema": {
      "schema": {
        "type": "object",
        "title": "Data Key Settings",
        "properties": {}
      },
      "form": []
    },
    "latestDataKeySettingsSchema": {},
    "defaultConfig": "{\"datasources\": [{\"type\": \"function\", \"name\": \"function\", \"dataKeys\": [{\"name\": \"f(x)\", \"type\": \"function\", \"label\": \"outsideTemperature\", \"color\": \"#FF9800\", \"settings\": {}, \"_hash\": 0.111, \"funcBody\": \"var value = prevValue + Math.random() * 2 - 1;\\nif (value < -10) value = -10;\\nif (value > 35) value = 35;\\nreturn value;\", \"units\": \"\\u00b0C\", \"decimals\": 1}, {\"name\": \"f(x)\", \"type\": \"function\", \"label\": \"T_flow_C\", \"color\": \"#E91E63\", \"settings\": {}, \"_hash\": 0.222, \"funcBody\": \"var temp = prevValue + Math.random() * 4 - 2;\\nif (temp < 25) temp = 25;\\nif (temp > 80) temp = 80;\\nreturn temp;\", \"units\": \"\\u00b0C\", \"decimals\": 1}]}], \"timewindow\": {\"hideInterval\": false, \"hideLastInterval\": false, \"hideQuickInterval\": false, \"hideAggregation\": false, \"hideAggInterval\": false, \"hideTimezone\": false, \"selectedTab\": 0, \"realtime\": {\"realtimeType\": 0, \"timewindowMs\": 3600000, \"quickInterval\": \"CURRENT_HOUR\", \"interval\": 5000}, \"aggregation\": {\"type\": \"AVG\", \"limit\": 25000}}, \"showTitle\": true, \"backgroundColor\": \"#fff\", \"color\": \"rgba(0, 0, 0, 0.87)\", \"padding\": \"8px\", \"settings\": {\"axisMode\": \"xy\", \"xAxisDataKey\": \"outsideTemperature\", \"xAxisLabel\": \"Outside Temperature\", \"xAxisUnit\": \"\\u00b0C\", \"pointSize\": 6, \"pointOpacity\": 0.6, \"symbolShape\": \"circle\", \"showRegressionLine\": true, \"showLegend\": true, \"legendStyle\": \"classic\", \"legendPosition\": \"bottom\", \"showDataZoomSlider\": true, \"showToolbox\": true, \"toolboxFeatures\": [\"saveAsImage\", \"dataView\", \"dataZoom\", \"restore\"]}, \"title\": \"ECO Scatter X/Y\", \"dropShadow\": true, \"enableFullscreen\": true, \"useDashboardTimewindow\": true, \"displayTimewindow\": true, \"hasAdditionalLatestDataKeys\": true}"
  }
}